# coding=utf-8
# --------------------------------------------------------------------------
# Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.10.1, generator: @autorest/python@5.16.0)
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------

from azure.core.exceptions import HttpResponseError
import msrest.serialization


class Accreditation(msrest.serialization.Model):
    """Accreditation.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar education:
    :vartype education: str
    :ivar input_str:
    :vartype input_str: str
    :ivar match_str:
    :vartype match_str: str
    :ivar education_level:
    :vartype education_level: str
    """

    _validation = {
        "input_str": {"readonly": True},
        "match_str": {"readonly": True},
        "education_level": {"readonly": True},
    }

    _attribute_map = {
        "education": {"key": "education", "type": "str"},
        "input_str": {"key": "inputStr", "type": "str"},
        "match_str": {"key": "matchStr", "type": "str"},
        "education_level": {"key": "educationLevel", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword education:
        :paramtype education: str
        """
        super(Accreditation, self).__init__(**kwargs)
        self.education = kwargs.get("education", None)
        self.input_str = None
        self.match_str = None
        self.education_level = None


class Annotation(msrest.serialization.Model):
    """Annotation.

    All required parameters must be populated in order to send to Azure.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id: Required. Annotation's ID.
    :vartype id: int
    :ivar rectangle: Required. x/y coordinates for the rectangular bounding box containing the
     data.
    :vartype rectangle: ~affinda.models.Rectangle
    :ivar rectangles: Required. x/y coordinates for the rectangles containing the data. An
     annotation can be contained within multiple rectangles.
    :vartype rectangles: list[~affinda.models.Rectangle]
    :ivar document: Required. Unique identifier for the document.
    :vartype document: str
    :ivar page_index: Required. The page number within the document, starting from 0.
    :vartype page_index: int
    :ivar raw: Required. Raw data extracted from the before any post-processing.
    :vartype raw: str
    :ivar confidence: Required. The overall confidence that the model's prediction is correct.
    :vartype confidence: float
    :ivar classification_confidence: Required. The model's confidence that the text has been
     classified correctly.
    :vartype classification_confidence: float
    :ivar text_extraction_confidence: Required. If the document was submitted as an image, this is
     the confidence that the text in the image has been correctly read by the model.
    :vartype text_extraction_confidence: float
    :ivar is_verified: Required. Indicates whether the data has been validated, either by a human
     using our validation tool or through auto-validation rules.
    :vartype is_verified: bool
    :ivar is_client_verified: Required. Indicates whether the data has been validated by a human.
    :vartype is_client_verified: bool
    :ivar is_auto_verified: Required. Indicates whether the data has been auto-validated.
    :vartype is_auto_verified: bool
    :ivar data_point: Required. Data point's identifier.
    :vartype data_point: str
    :ivar content_type: Required. The different data types of annotations. Known values are:
     "text", "integer", "float", "decimal", "date", "datetime", "daterange", "boolean", "enum",
     "location", "phonenumber", "json", "table", "expectedremuneration", "jobtitle", "language",
     "skill", "yearsexperience", "group", "table_deprecated", "url", "image".
    :vartype content_type: str or ~affinda.models.AnnotationContentType
    :ivar parent: The parent annotation's ID.
    :vartype parent: int
    """

    _validation = {
        "id": {"required": True, "minimum": 1},
        "rectangle": {"required": True},
        "rectangles": {"required": True},
        "document": {"required": True},
        "page_index": {"required": True, "minimum": 0},
        "raw": {"required": True},
        "confidence": {"required": True},
        "classification_confidence": {"required": True},
        "text_extraction_confidence": {"required": True},
        "is_verified": {"required": True},
        "is_client_verified": {"required": True},
        "is_auto_verified": {"required": True},
        "data_point": {"required": True},
        "content_type": {"required": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "int"},
        "rectangle": {"key": "rectangle", "type": "Rectangle"},
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "document": {"key": "document", "type": "str"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "confidence": {"key": "confidence", "type": "float"},
        "classification_confidence": {"key": "classificationConfidence", "type": "float"},
        "text_extraction_confidence": {"key": "textExtractionConfidence", "type": "float"},
        "is_verified": {"key": "isVerified", "type": "bool"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "is_auto_verified": {"key": "isAutoVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "content_type": {"key": "contentType", "type": "str"},
        "parent": {"key": "parent", "type": "int"},
    }

    def __init__(self, **kwargs):
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword id: Required. Annotation's ID.
        :paramtype id: int
        :keyword rectangle: Required. x/y coordinates for the rectangular bounding box containing the
         data.
        :paramtype rectangle: ~affinda.models.Rectangle
        :keyword rectangles: Required. x/y coordinates for the rectangles containing the data. An
         annotation can be contained within multiple rectangles.
        :paramtype rectangles: list[~affinda.models.Rectangle]
        :keyword document: Required. Unique identifier for the document.
        :paramtype document: str
        :keyword page_index: Required. The page number within the document, starting from 0.
        :paramtype page_index: int
        :keyword raw: Required. Raw data extracted from the before any post-processing.
        :paramtype raw: str
        :keyword confidence: Required. The overall confidence that the model's prediction is correct.
        :paramtype confidence: float
        :keyword classification_confidence: Required. The model's confidence that the text has been
         classified correctly.
        :paramtype classification_confidence: float
        :keyword text_extraction_confidence: Required. If the document was submitted as an image, this
         is the confidence that the text in the image has been correctly read by the model.
        :paramtype text_extraction_confidence: float
        :keyword is_verified: Required. Indicates whether the data has been validated, either by a
         human using our validation tool or through auto-validation rules.
        :paramtype is_verified: bool
        :keyword is_client_verified: Required. Indicates whether the data has been validated by a
         human.
        :paramtype is_client_verified: bool
        :keyword is_auto_verified: Required. Indicates whether the data has been auto-validated.
        :paramtype is_auto_verified: bool
        :keyword data_point: Required. Data point's identifier.
        :paramtype data_point: str
        :keyword content_type: Required. The different data types of annotations. Known values are:
         "text", "integer", "float", "decimal", "date", "datetime", "daterange", "boolean", "enum",
         "location", "phonenumber", "json", "table", "expectedremuneration", "jobtitle", "language",
         "skill", "yearsexperience", "group", "table_deprecated", "url", "image".
        :paramtype content_type: str or ~affinda.models.AnnotationContentType
        :keyword parent: The parent annotation's ID.
        :paramtype parent: int
        """
        super(Annotation, self).__init__(**kwargs)
        self.additional_properties = kwargs.get("additional_properties", None)
        self.id = kwargs["id"]
        self.rectangle = kwargs["rectangle"]
        self.rectangles = kwargs["rectangles"]
        self.document = kwargs["document"]
        self.page_index = kwargs["page_index"]
        self.raw = kwargs["raw"]
        self.confidence = kwargs["confidence"]
        self.classification_confidence = kwargs["classification_confidence"]
        self.text_extraction_confidence = kwargs["text_extraction_confidence"]
        self.is_verified = kwargs["is_verified"]
        self.is_client_verified = kwargs["is_client_verified"]
        self.is_auto_verified = kwargs["is_auto_verified"]
        self.data_point = kwargs["data_point"]
        self.content_type = kwargs["content_type"]
        self.parent = kwargs.get("parent", None)


class AnnotationBase(msrest.serialization.Model):
    """AnnotationBase.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id:
    :vartype id: int
    :ivar rectangle:
    :vartype rectangle: ~affinda.models.Rectangle
    :ivar rectangles:
    :vartype rectangles: list[~affinda.models.Rectangle]
    :ivar page_index:
    :vartype page_index: int
    :ivar raw:
    :vartype raw: str
    :ivar confidence: The overall confidence that the model's prediction is correct.
    :vartype confidence: float
    :ivar classification_confidence: The model's confidence that the text has been classified
     correctly.
    :vartype classification_confidence: float
    :ivar text_extraction_confidence: If the document was submitted as an image, this is the
     confidence that the text in the image has been correctly read by the model.
    :vartype text_extraction_confidence: float
    :ivar is_verified:
    :vartype is_verified: bool
    :ivar is_client_verified:
    :vartype is_client_verified: bool
    :ivar is_auto_verified:
    :vartype is_auto_verified: bool
    :ivar data_point:
    :vartype data_point: str
    :ivar content_type:
    :vartype content_type: str
    """

    _validation = {
        "rectangles": {"readonly": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "int"},
        "rectangle": {"key": "rectangle", "type": "Rectangle"},
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "confidence": {"key": "confidence", "type": "float"},
        "classification_confidence": {"key": "classificationConfidence", "type": "float"},
        "text_extraction_confidence": {"key": "textExtractionConfidence", "type": "float"},
        "is_verified": {"key": "isVerified", "type": "bool"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "is_auto_verified": {"key": "isAutoVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "content_type": {"key": "contentType", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword id:
        :paramtype id: int
        :keyword rectangle:
        :paramtype rectangle: ~affinda.models.Rectangle
        :keyword page_index:
        :paramtype page_index: int
        :keyword raw:
        :paramtype raw: str
        :keyword confidence: The overall confidence that the model's prediction is correct.
        :paramtype confidence: float
        :keyword classification_confidence: The model's confidence that the text has been classified
         correctly.
        :paramtype classification_confidence: float
        :keyword text_extraction_confidence: If the document was submitted as an image, this is the
         confidence that the text in the image has been correctly read by the model.
        :paramtype text_extraction_confidence: float
        :keyword is_verified:
        :paramtype is_verified: bool
        :keyword is_client_verified:
        :paramtype is_client_verified: bool
        :keyword is_auto_verified:
        :paramtype is_auto_verified: bool
        :keyword data_point:
        :paramtype data_point: str
        :keyword content_type:
        :paramtype content_type: str
        """
        super(AnnotationBase, self).__init__(**kwargs)
        self.additional_properties = kwargs.get("additional_properties", None)
        self.id = kwargs.get("id", None)
        self.rectangle = kwargs.get("rectangle", None)
        self.rectangles = None
        self.page_index = kwargs.get("page_index", None)
        self.raw = kwargs.get("raw", None)
        self.confidence = kwargs.get("confidence", None)
        self.classification_confidence = kwargs.get("classification_confidence", None)
        self.text_extraction_confidence = kwargs.get("text_extraction_confidence", None)
        self.is_verified = kwargs.get("is_verified", None)
        self.is_client_verified = kwargs.get("is_client_verified", None)
        self.is_auto_verified = kwargs.get("is_auto_verified", None)
        self.data_point = kwargs.get("data_point", None)
        self.content_type = kwargs.get("content_type", None)


class AnnotationBatchUpdate(msrest.serialization.Model):
    """AnnotationBatchUpdate.

    All required parameters must be populated in order to send to Azure.

    :ivar id: Required. Annotation's ID.
    :vartype id: int
    :ivar rectangles: x/y coordinates for the rectangles containing the data. An annotation can be
     contained within multiple rectangles.
    :vartype rectangles: list[~affinda.models.Rectangle]
    :ivar document: Unique identifier for the document.
    :vartype document: str
    :ivar page_index: The page number within the document, starting from 0.
    :vartype page_index: int
    :ivar raw: Raw data extracted from the before any post-processing.
    :vartype raw: str
    :ivar parsed: Anything.
    :vartype parsed: any
    :ivar is_client_verified: Indicates whether the data has been validated by a human.
    :vartype is_client_verified: bool
    :ivar data_point: Data point's identifier.
    :vartype data_point: str
    :ivar parent: The parent annotation's ID.
    :vartype parent: int
    :ivar validation_results: The validation results created, changed or deleted as a result of
     updating the annotation.
    :vartype validation_results: list[~affinda.models.ChangedValidationResults]
    """

    _validation = {
        "id": {"required": True, "minimum": 1},
        "page_index": {"minimum": 0},
    }

    _attribute_map = {
        "id": {"key": "id", "type": "int"},
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "document": {"key": "document", "type": "str"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "parsed": {"key": "parsed", "type": "object"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "parent": {"key": "parent", "type": "int"},
        "validation_results": {"key": "validationResults", "type": "[ChangedValidationResults]"},
    }

    def __init__(self, **kwargs):
        """
        :keyword id: Required. Annotation's ID.
        :paramtype id: int
        :keyword rectangles: x/y coordinates for the rectangles containing the data. An annotation can
         be contained within multiple rectangles.
        :paramtype rectangles: list[~affinda.models.Rectangle]
        :keyword document: Unique identifier for the document.
        :paramtype document: str
        :keyword page_index: The page number within the document, starting from 0.
        :paramtype page_index: int
        :keyword raw: Raw data extracted from the before any post-processing.
        :paramtype raw: str
        :keyword parsed: Anything.
        :paramtype parsed: any
        :keyword is_client_verified: Indicates whether the data has been validated by a human.
        :paramtype is_client_verified: bool
        :keyword data_point: Data point's identifier.
        :paramtype data_point: str
        :keyword parent: The parent annotation's ID.
        :paramtype parent: int
        :keyword validation_results: The validation results created, changed or deleted as a result of
         updating the annotation.
        :paramtype validation_results: list[~affinda.models.ChangedValidationResults]
        """
        super(AnnotationBatchUpdate, self).__init__(**kwargs)
        self.id = kwargs["id"]
        self.rectangles = kwargs.get("rectangles", None)
        self.document = kwargs.get("document", None)
        self.page_index = kwargs.get("page_index", None)
        self.raw = kwargs.get("raw", None)
        self.parsed = kwargs.get("parsed", None)
        self.is_client_verified = kwargs.get("is_client_verified", None)
        self.data_point = kwargs.get("data_point", None)
        self.parent = kwargs.get("parent", None)
        self.validation_results = kwargs.get("validation_results", None)


class AnnotationCreate(msrest.serialization.Model):
    """AnnotationCreate.

    All required parameters must be populated in order to send to Azure.

    :ivar rectangles: x/y coordinates for the rectangles containing the data. An annotation can be
     contained within multiple rectangles.
    :vartype rectangles: list[~affinda.models.Rectangle]
    :ivar document: Required. Unique identifier for the document.
    :vartype document: str
    :ivar page_index: Required. The page number within the document, starting from 0.
    :vartype page_index: int
    :ivar data_point: Required. Data point's identifier.
    :vartype data_point: str
    :ivar raw: Raw data extracted from the before any post-processing.
    :vartype raw: str
    :ivar parsed: Anything.
    :vartype parsed: any
    :ivar is_client_verified: Indicates whether the data has been validated by a human.
    :vartype is_client_verified: bool
    :ivar parent: The parent annotation's ID.
    :vartype parent: int
    :ivar validation_results: The validation results created, changed or deleted as a result of
     creating the annotation.
    :vartype validation_results: list[~affinda.models.ChangedValidationResults]
    """

    _validation = {
        "document": {"required": True},
        "page_index": {"required": True, "minimum": 0},
        "data_point": {"required": True},
    }

    _attribute_map = {
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "document": {"key": "document", "type": "str"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "raw": {"key": "raw", "type": "str"},
        "parsed": {"key": "parsed", "type": "object"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "parent": {"key": "parent", "type": "int"},
        "validation_results": {"key": "validationResults", "type": "[ChangedValidationResults]"},
    }

    def __init__(self, **kwargs):
        """
        :keyword rectangles: x/y coordinates for the rectangles containing the data. An annotation can
         be contained within multiple rectangles.
        :paramtype rectangles: list[~affinda.models.Rectangle]
        :keyword document: Required. Unique identifier for the document.
        :paramtype document: str
        :keyword page_index: Required. The page number within the document, starting from 0.
        :paramtype page_index: int
        :keyword data_point: Required. Data point's identifier.
        :paramtype data_point: str
        :keyword raw: Raw data extracted from the before any post-processing.
        :paramtype raw: str
        :keyword parsed: Anything.
        :paramtype parsed: any
        :keyword is_client_verified: Indicates whether the data has been validated by a human.
        :paramtype is_client_verified: bool
        :keyword parent: The parent annotation's ID.
        :paramtype parent: int
        :keyword validation_results: The validation results created, changed or deleted as a result of
         creating the annotation.
        :paramtype validation_results: list[~affinda.models.ChangedValidationResults]
        """
        super(AnnotationCreate, self).__init__(**kwargs)
        self.rectangles = kwargs.get("rectangles", None)
        self.document = kwargs["document"]
        self.page_index = kwargs["page_index"]
        self.data_point = kwargs["data_point"]
        self.raw = kwargs.get("raw", None)
        self.parsed = kwargs.get("parsed", None)
        self.is_client_verified = kwargs.get("is_client_verified", None)
        self.parent = kwargs.get("parent", None)
        self.validation_results = kwargs.get("validation_results", None)


class AnnotationUpdate(msrest.serialization.Model):
    """AnnotationUpdate.

    :ivar rectangles: x/y coordinates for the rectangles containing the data. An annotation can be
     contained within multiple rectangles.
    :vartype rectangles: list[~affinda.models.Rectangle]
    :ivar document: Unique identifier for the document.
    :vartype document: str
    :ivar page_index: The page number within the document, starting from 0.
    :vartype page_index: int
    :ivar raw: Raw data extracted from the before any post-processing.
    :vartype raw: str
    :ivar parsed: Anything.
    :vartype parsed: any
    :ivar is_client_verified: Indicates whether the data has been validated by a human.
    :vartype is_client_verified: bool
    :ivar data_point: Data point's identifier.
    :vartype data_point: str
    :ivar parent: The parent annotation's ID.
    :vartype parent: int
    :ivar validation_results: The validation results created, changed or deleted as a result of
     updating the annotation.
    :vartype validation_results: list[~affinda.models.ChangedValidationResults]
    """

    _validation = {
        "page_index": {"minimum": 0},
    }

    _attribute_map = {
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "document": {"key": "document", "type": "str"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "parsed": {"key": "parsed", "type": "object"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "parent": {"key": "parent", "type": "int"},
        "validation_results": {"key": "validationResults", "type": "[ChangedValidationResults]"},
    }

    def __init__(self, **kwargs):
        """
        :keyword rectangles: x/y coordinates for the rectangles containing the data. An annotation can
         be contained within multiple rectangles.
        :paramtype rectangles: list[~affinda.models.Rectangle]
        :keyword document: Unique identifier for the document.
        :paramtype document: str
        :keyword page_index: The page number within the document, starting from 0.
        :paramtype page_index: int
        :keyword raw: Raw data extracted from the before any post-processing.
        :paramtype raw: str
        :keyword parsed: Anything.
        :paramtype parsed: any
        :keyword is_client_verified: Indicates whether the data has been validated by a human.
        :paramtype is_client_verified: bool
        :keyword data_point: Data point's identifier.
        :paramtype data_point: str
        :keyword parent: The parent annotation's ID.
        :paramtype parent: int
        :keyword validation_results: The validation results created, changed or deleted as a result of
         updating the annotation.
        :paramtype validation_results: list[~affinda.models.ChangedValidationResults]
        """
        super(AnnotationUpdate, self).__init__(**kwargs)
        self.rectangles = kwargs.get("rectangles", None)
        self.document = kwargs.get("document", None)
        self.page_index = kwargs.get("page_index", None)
        self.raw = kwargs.get("raw", None)
        self.parsed = kwargs.get("parsed", None)
        self.is_client_verified = kwargs.get("is_client_verified", None)
        self.data_point = kwargs.get("data_point", None)
        self.parent = kwargs.get("parent", None)
        self.validation_results = kwargs.get("validation_results", None)


class AnnotationWithValidationResults(Annotation):
    """AnnotationWithValidationResults.

    All required parameters must be populated in order to send to Azure.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id: Required. Annotation's ID.
    :vartype id: int
    :ivar rectangle: Required. x/y coordinates for the rectangular bounding box containing the
     data.
    :vartype rectangle: ~affinda.models.Rectangle
    :ivar rectangles: Required. x/y coordinates for the rectangles containing the data. An
     annotation can be contained within multiple rectangles.
    :vartype rectangles: list[~affinda.models.Rectangle]
    :ivar document: Required. Unique identifier for the document.
    :vartype document: str
    :ivar page_index: Required. The page number within the document, starting from 0.
    :vartype page_index: int
    :ivar raw: Required. Raw data extracted from the before any post-processing.
    :vartype raw: str
    :ivar confidence: Required. The overall confidence that the model's prediction is correct.
    :vartype confidence: float
    :ivar classification_confidence: Required. The model's confidence that the text has been
     classified correctly.
    :vartype classification_confidence: float
    :ivar text_extraction_confidence: Required. If the document was submitted as an image, this is
     the confidence that the text in the image has been correctly read by the model.
    :vartype text_extraction_confidence: float
    :ivar is_verified: Required. Indicates whether the data has been validated, either by a human
     using our validation tool or through auto-validation rules.
    :vartype is_verified: bool
    :ivar is_client_verified: Required. Indicates whether the data has been validated by a human.
    :vartype is_client_verified: bool
    :ivar is_auto_verified: Required. Indicates whether the data has been auto-validated.
    :vartype is_auto_verified: bool
    :ivar data_point: Required. Data point's identifier.
    :vartype data_point: str
    :ivar content_type: Required. The different data types of annotations. Known values are:
     "text", "integer", "float", "decimal", "date", "datetime", "daterange", "boolean", "enum",
     "location", "phonenumber", "json", "table", "expectedremuneration", "jobtitle", "language",
     "skill", "yearsexperience", "group", "table_deprecated", "url", "image".
    :vartype content_type: str or ~affinda.models.AnnotationContentType
    :ivar parent: The parent annotation's ID.
    :vartype parent: int
    :ivar validation_results: List of validation results for this annotation.
    :vartype validation_results: list[~affinda.models.ValidationResult]
    """

    _validation = {
        "id": {"required": True, "minimum": 1},
        "rectangle": {"required": True},
        "rectangles": {"required": True},
        "document": {"required": True},
        "page_index": {"required": True, "minimum": 0},
        "raw": {"required": True},
        "confidence": {"required": True},
        "classification_confidence": {"required": True},
        "text_extraction_confidence": {"required": True},
        "is_verified": {"required": True},
        "is_client_verified": {"required": True},
        "is_auto_verified": {"required": True},
        "data_point": {"required": True},
        "content_type": {"required": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "int"},
        "rectangle": {"key": "rectangle", "type": "Rectangle"},
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "document": {"key": "document", "type": "str"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "confidence": {"key": "confidence", "type": "float"},
        "classification_confidence": {"key": "classificationConfidence", "type": "float"},
        "text_extraction_confidence": {"key": "textExtractionConfidence", "type": "float"},
        "is_verified": {"key": "isVerified", "type": "bool"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "is_auto_verified": {"key": "isAutoVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "content_type": {"key": "contentType", "type": "str"},
        "parent": {"key": "parent", "type": "int"},
        "validation_results": {"key": "validationResults", "type": "[ValidationResult]"},
    }

    def __init__(self, **kwargs):
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword id: Required. Annotation's ID.
        :paramtype id: int
        :keyword rectangle: Required. x/y coordinates for the rectangular bounding box containing the
         data.
        :paramtype rectangle: ~affinda.models.Rectangle
        :keyword rectangles: Required. x/y coordinates for the rectangles containing the data. An
         annotation can be contained within multiple rectangles.
        :paramtype rectangles: list[~affinda.models.Rectangle]
        :keyword document: Required. Unique identifier for the document.
        :paramtype document: str
        :keyword page_index: Required. The page number within the document, starting from 0.
        :paramtype page_index: int
        :keyword raw: Required. Raw data extracted from the before any post-processing.
        :paramtype raw: str
        :keyword confidence: Required. The overall confidence that the model's prediction is correct.
        :paramtype confidence: float
        :keyword classification_confidence: Required. The model's confidence that the text has been
         classified correctly.
        :paramtype classification_confidence: float
        :keyword text_extraction_confidence: Required. If the document was submitted as an image, this
         is the confidence that the text in the image has been correctly read by the model.
        :paramtype text_extraction_confidence: float
        :keyword is_verified: Required. Indicates whether the data has been validated, either by a
         human using our validation tool or through auto-validation rules.
        :paramtype is_verified: bool
        :keyword is_client_verified: Required. Indicates whether the data has been validated by a
         human.
        :paramtype is_client_verified: bool
        :keyword is_auto_verified: Required. Indicates whether the data has been auto-validated.
        :paramtype is_auto_verified: bool
        :keyword data_point: Required. Data point's identifier.
        :paramtype data_point: str
        :keyword content_type: Required. The different data types of annotations. Known values are:
         "text", "integer", "float", "decimal", "date", "datetime", "daterange", "boolean", "enum",
         "location", "phonenumber", "json", "table", "expectedremuneration", "jobtitle", "language",
         "skill", "yearsexperience", "group", "table_deprecated", "url", "image".
        :paramtype content_type: str or ~affinda.models.AnnotationContentType
        :keyword parent: The parent annotation's ID.
        :paramtype parent: int
        :keyword validation_results: List of validation results for this annotation.
        :paramtype validation_results: list[~affinda.models.ValidationResult]
        """
        super(AnnotationWithValidationResults, self).__init__(**kwargs)
        self.validation_results = kwargs.get("validation_results", None)


class AnotationDelete(msrest.serialization.Model):
    """AnotationDelete.

    :ivar validation_results: The validation results created, changed or deleted as a result of
     deleting the annotation.
    :vartype validation_results: any
    """

    _attribute_map = {
        "validation_results": {"key": "validationResults", "type": "object"},
    }

    def __init__(self, **kwargs):
        """
        :keyword validation_results: The validation results created, changed or deleted as a result of
         deleting the annotation.
        :paramtype validation_results: any
        """
        super(AnotationDelete, self).__init__(**kwargs)
        self.validation_results = kwargs.get("validation_results", None)


class ApiUserCreate(msrest.serialization.Model):
    """ApiUserCreate.

    All required parameters must be populated in order to send to Azure.

    :ivar name:
    :vartype name: str
    :ivar username:
    :vartype username: str
    :ivar email:
    :vartype email: str
    :ivar avatar: URL of the user's avatar.
    :vartype avatar: str
    :ivar organization: Required. Uniquely identify an organization.
    :vartype organization: str
    """

    _validation = {
        "organization": {"required": True},
    }

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "username": {"key": "username", "type": "str"},
        "email": {"key": "email", "type": "str"},
        "avatar": {"key": "avatar", "type": "str"},
        "organization": {"key": "organization", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword name:
        :paramtype name: str
        :keyword username:
        :paramtype username: str
        :keyword email:
        :paramtype email: str
        :keyword avatar: URL of the user's avatar.
        :paramtype avatar: str
        :keyword organization: Required. Uniquely identify an organization.
        :paramtype organization: str
        """
        super(ApiUserCreate, self).__init__(**kwargs)
        self.name = kwargs.get("name", None)
        self.username = kwargs.get("username", None)
        self.email = kwargs.get("email", None)
        self.avatar = kwargs.get("avatar", None)
        self.organization = kwargs["organization"]


class ApiUserUpdate(msrest.serialization.Model):
    """ApiUserUpdate.

    :ivar name:
    :vartype name: str
    :ivar username:
    :vartype username: str
    :ivar email:
    :vartype email: str
    :ivar avatar: URL of the user's avatar.
    :vartype avatar: str
    """

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "username": {"key": "username", "type": "str"},
        "email": {"key": "email", "type": "str"},
        "avatar": {"key": "avatar", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword name:
        :paramtype name: str
        :keyword username:
        :paramtype username: str
        :keyword email:
        :paramtype email: str
        :keyword avatar: URL of the user's avatar.
        :paramtype avatar: str
        """
        super(ApiUserUpdate, self).__init__(**kwargs)
        self.name = kwargs.get("name", None)
        self.username = kwargs.get("username", None)
        self.email = kwargs.get("email", None)
        self.avatar = kwargs.get("avatar", None)


class ApiUserWithKey(msrest.serialization.Model):
    """ApiUserWithKey.

    All required parameters must be populated in order to send to Azure.

    :ivar id: Required. Uniquely identify a user.
    :vartype id: int
    :ivar name: Required.
    :vartype name: str
    :ivar username: Required.
    :vartype username: str
    :ivar email: Required.
    :vartype email: str
    :ivar avatar: Required. URL of the user's avatar.
    :vartype avatar: str
    :ivar organizations: Required.
    :vartype organizations: list[~affinda.models.ApiUserWithKeyOrganizationsItem]
    :ivar api_key: Required. Use this key to authenticate with the API.
    :vartype api_key: str
    :ivar api_key_last_chars: The last 4 characters of the API key.
    :vartype api_key_last_chars: str
    """

    _validation = {
        "id": {"required": True, "minimum": 1},
        "name": {"required": True},
        "username": {"required": True},
        "email": {"required": True},
        "avatar": {"required": True},
        "organizations": {"required": True},
        "api_key": {"required": True},
    }

    _attribute_map = {
        "id": {"key": "id", "type": "int"},
        "name": {"key": "name", "type": "str"},
        "username": {"key": "username", "type": "str"},
        "email": {"key": "email", "type": "str"},
        "avatar": {"key": "avatar", "type": "str"},
        "organizations": {"key": "organizations", "type": "[ApiUserWithKeyOrganizationsItem]"},
        "api_key": {"key": "apiKey", "type": "str"},
        "api_key_last_chars": {"key": "apiKeyLastChars", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword id: Required. Uniquely identify a user.
        :paramtype id: int
        :keyword name: Required.
        :paramtype name: str
        :keyword username: Required.
        :paramtype username: str
        :keyword email: Required.
        :paramtype email: str
        :keyword avatar: Required. URL of the user's avatar.
        :paramtype avatar: str
        :keyword organizations: Required.
        :paramtype organizations: list[~affinda.models.ApiUserWithKeyOrganizationsItem]
        :keyword api_key: Required. Use this key to authenticate with the API.
        :paramtype api_key: str
        :keyword api_key_last_chars: The last 4 characters of the API key.
        :paramtype api_key_last_chars: str
        """
        super(ApiUserWithKey, self).__init__(**kwargs)
        self.id = kwargs["id"]
        self.name = kwargs["name"]
        self.username = kwargs["username"]
        self.email = kwargs["email"]
        self.avatar = kwargs["avatar"]
        self.organizations = kwargs["organizations"]
        self.api_key = kwargs["api_key"]
        self.api_key_last_chars = kwargs.get("api_key_last_chars", None)


class ApiUserWithKeyOrganizationsItem(msrest.serialization.Model):
    """ApiUserWithKeyOrganizationsItem.

    All required parameters must be populated in order to send to Azure.

    :ivar identifier: Required. Uniquely identify an organization.
    :vartype identifier: str
    :ivar name: Required.
    :vartype name: str
    """

    _validation = {
        "identifier": {"required": True},
        "name": {"required": True},
    }

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
        "name": {"key": "name", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword identifier: Required. Uniquely identify an organization.
        :paramtype identifier: str
        :keyword name: Required.
        :paramtype name: str
        """
        super(ApiUserWithKeyOrganizationsItem, self).__init__(**kwargs)
        self.identifier = kwargs["identifier"]
        self.name = kwargs["name"]


class ApiUserWithoutKey(msrest.serialization.Model):
    """ApiUserWithoutKey.

    All required parameters must be populated in order to send to Azure.

    :ivar id: Required. Uniquely identify a user.
    :vartype id: int
    :ivar name: Required.
    :vartype name: str
    :ivar username: Required.
    :vartype username: str
    :ivar email: Required.
    :vartype email: str
    :ivar avatar: Required. URL of the user's avatar.
    :vartype avatar: str
    :ivar organizations: Required.
    :vartype organizations: list[~affinda.models.ApiUserWithoutKeyOrganizationsItem]
    :ivar api_key_last_chars: The last 4 characters of the API key.
    :vartype api_key_last_chars: str
    """

    _validation = {
        "id": {"required": True, "minimum": 1},
        "name": {"required": True},
        "username": {"required": True},
        "email": {"required": True},
        "avatar": {"required": True},
        "organizations": {"required": True},
    }

    _attribute_map = {
        "id": {"key": "id", "type": "int"},
        "name": {"key": "name", "type": "str"},
        "username": {"key": "username", "type": "str"},
        "email": {"key": "email", "type": "str"},
        "avatar": {"key": "avatar", "type": "str"},
        "organizations": {"key": "organizations", "type": "[ApiUserWithoutKeyOrganizationsItem]"},
        "api_key_last_chars": {"key": "apiKeyLastChars", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword id: Required. Uniquely identify a user.
        :paramtype id: int
        :keyword name: Required.
        :paramtype name: str
        :keyword username: Required.
        :paramtype username: str
        :keyword email: Required.
        :paramtype email: str
        :keyword avatar: Required. URL of the user's avatar.
        :paramtype avatar: str
        :keyword organizations: Required.
        :paramtype organizations: list[~affinda.models.ApiUserWithoutKeyOrganizationsItem]
        :keyword api_key_last_chars: The last 4 characters of the API key.
        :paramtype api_key_last_chars: str
        """
        super(ApiUserWithoutKey, self).__init__(**kwargs)
        self.id = kwargs["id"]
        self.name = kwargs["name"]
        self.username = kwargs["username"]
        self.email = kwargs["email"]
        self.avatar = kwargs["avatar"]
        self.organizations = kwargs["organizations"]
        self.api_key_last_chars = kwargs.get("api_key_last_chars", None)


class ApiUserWithoutKeyOrganizationsItem(msrest.serialization.Model):
    """ApiUserWithoutKeyOrganizationsItem.

    All required parameters must be populated in order to send to Azure.

    :ivar identifier: Required. Uniquely identify an organization.
    :vartype identifier: str
    :ivar name: Required.
    :vartype name: str
    """

    _validation = {
        "identifier": {"required": True},
        "name": {"required": True},
    }

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
        "name": {"key": "name", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword identifier: Required. Uniquely identify an organization.
        :paramtype identifier: str
        :keyword name: Required.
        :paramtype name: str
        """
        super(ApiUserWithoutKeyOrganizationsItem, self).__init__(**kwargs)
        self.identifier = kwargs["identifier"]
        self.name = kwargs["name"]


class BaseExtractor(msrest.serialization.Model):
    """BaseExtractor.

    All required parameters must be populated in order to send to Azure.

    :ivar identifier: Required. Uniquely identify an extractor.
    :vartype identifier: str
    :ivar name: Required.
    :vartype name: str
    :ivar name_plural: Required.
    :vartype name_plural: str
    :ivar validatable: Required.
    :vartype validatable: bool
    :ivar is_custom:
    :vartype is_custom: bool
    :ivar created_dt:
    :vartype created_dt: ~datetime.datetime
    """

    _validation = {
        "identifier": {"required": True},
        "name": {"required": True},
        "name_plural": {"required": True},
        "validatable": {"required": True},
    }

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "name_plural": {"key": "namePlural", "type": "str"},
        "validatable": {"key": "validatable", "type": "bool"},
        "is_custom": {"key": "isCustom", "type": "bool"},
        "created_dt": {"key": "createdDt", "type": "iso-8601"},
    }

    def __init__(self, **kwargs):
        """
        :keyword identifier: Required. Uniquely identify an extractor.
        :paramtype identifier: str
        :keyword name: Required.
        :paramtype name: str
        :keyword name_plural: Required.
        :paramtype name_plural: str
        :keyword validatable: Required.
        :paramtype validatable: bool
        :keyword is_custom:
        :paramtype is_custom: bool
        :keyword created_dt:
        :paramtype created_dt: ~datetime.datetime
        """
        super(BaseExtractor, self).__init__(**kwargs)
        self.identifier = kwargs["identifier"]
        self.name = kwargs["name"]
        self.name_plural = kwargs["name_plural"]
        self.validatable = kwargs["validatable"]
        self.is_custom = kwargs.get("is_custom", None)
        self.created_dt = kwargs.get("created_dt", None)


class BatchAddTagRequest(msrest.serialization.Model):
    """BatchAddTagRequest.

    :ivar identifiers: List of documents to tag.
    :vartype identifiers: list[str]
    :ivar tag: The tag's ID.
    :vartype tag: int
    """

    _attribute_map = {
        "identifiers": {"key": "identifiers", "type": "[str]"},
        "tag": {"key": "tag", "type": "int"},
    }

    def __init__(self, **kwargs):
        """
        :keyword identifiers: List of documents to tag.
        :paramtype identifiers: list[str]
        :keyword tag: The tag's ID.
        :paramtype tag: int
        """
        super(BatchAddTagRequest, self).__init__(**kwargs)
        self.identifiers = kwargs.get("identifiers", None)
        self.tag = kwargs.get("tag", None)


class BatchDeleteAnnotationsResponse(msrest.serialization.Model):
    """BatchDeleteAnnotationsResponse.

    :ivar validation_results: The validation results created, changed or deleted as a result of
     deleting the annotations.
    :vartype validation_results: any
    """

    _attribute_map = {
        "validation_results": {"key": "validationResults", "type": "object"},
    }

    def __init__(self, **kwargs):
        """
        :keyword validation_results: The validation results created, changed or deleted as a result of
         deleting the annotations.
        :paramtype validation_results: any
        """
        super(BatchDeleteAnnotationsResponse, self).__init__(**kwargs)
        self.validation_results = kwargs.get("validation_results", None)


class BatchDeleteValidationResultsRequest(msrest.serialization.Model):
    """BatchDeleteValidationResultsRequest.

    All required parameters must be populated in order to send to Azure.

    :ivar ids: Required. List of validation result IDs to delete.
    :vartype ids: list[int]
    """

    _validation = {
        "ids": {"required": True},
    }

    _attribute_map = {
        "ids": {"key": "ids", "type": "[int]"},
    }

    def __init__(self, **kwargs):
        """
        :keyword ids: Required. List of validation result IDs to delete.
        :paramtype ids: list[int]
        """
        super(BatchDeleteValidationResultsRequest, self).__init__(**kwargs)
        self.ids = kwargs["ids"]


class BatchRemoveTagRequest(msrest.serialization.Model):
    """BatchRemoveTagRequest.

    :ivar identifiers: List of documents to remove tag from.
    :vartype identifiers: list[str]
    :ivar tag: The tag's ID.
    :vartype tag: int
    """

    _attribute_map = {
        "identifiers": {"key": "identifiers", "type": "[str]"},
        "tag": {"key": "tag", "type": "int"},
    }

    def __init__(self, **kwargs):
        """
        :keyword identifiers: List of documents to remove tag from.
        :paramtype identifiers: list[str]
        :keyword tag: The tag's ID.
        :paramtype tag: int
        """
        super(BatchRemoveTagRequest, self).__init__(**kwargs)
        self.identifiers = kwargs.get("identifiers", None)
        self.tag = kwargs.get("tag", None)


class ChangedValidationResults(msrest.serialization.Model):
    """ChangedValidationResults.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar created: List of validation results created during this operation.
    :vartype created: list[~affinda.models.ValidationResult]
    :ivar updated: List of validation results updated during this operation.
    :vartype updated: list[~affinda.models.ValidationResult]
    :ivar deleted: List of validation results deleted during this operation.
    :vartype deleted: list[~affinda.models.ValidationResult]
    """

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "created": {"key": "created", "type": "[ValidationResult]"},
        "updated": {"key": "updated", "type": "[ValidationResult]"},
        "deleted": {"key": "deleted", "type": "[ValidationResult]"},
    }

    def __init__(self, **kwargs):
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword created: List of validation results created during this operation.
        :paramtype created: list[~affinda.models.ValidationResult]
        :keyword updated: List of validation results updated during this operation.
        :paramtype updated: list[~affinda.models.ValidationResult]
        :keyword deleted: List of validation results deleted during this operation.
        :paramtype deleted: list[~affinda.models.ValidationResult]
        """
        super(ChangedValidationResults, self).__init__(**kwargs)
        self.additional_properties = kwargs.get("additional_properties", None)
        self.created = kwargs.get("created", None)
        self.updated = kwargs.get("updated", None)
        self.deleted = kwargs.get("deleted", None)


class Collection(msrest.serialization.Model):
    """Collection.

    All required parameters must be populated in order to send to Azure.

    :ivar identifier: Required. Uniquely identify a collection.
    :vartype identifier: str
    :ivar name:
    :vartype name: str
    :ivar workspace:
    :vartype workspace: ~affinda.models.CollectionWorkspace
    :ivar extractor:
    :vartype extractor: ~affinda.models.Extractor
    :ivar auto_validation_threshold:
    :vartype auto_validation_threshold: float
    :ivar auto_validate_if_validation_rules_pass:
    :vartype auto_validate_if_validation_rules_pass: bool
    :ivar fields:
    :vartype fields: list[~affinda.models.FieldGroup]
    :ivar fields_layout:
    :vartype fields_layout: ~affinda.models.FieldsLayout
    :ivar fields_configured:
    :vartype fields_configured: bool
    :ivar date_format_preference: Known values are: "DMY", "MDY", "YMD".
    :vartype date_format_preference: str or ~affinda.models.CollectionDateFormatPreference
    :ivar date_format_from_document: Predict the date format from any dates in the document that is
     not ambiguous.
    :vartype date_format_from_document: bool
    :ivar extractor_config: Extra configurations specific to an extractor.
    :vartype extractor_config: ~affinda.models.ExtractorConfig
    :ivar unvalidated_docs_count: Number of unvalidated documents in the collection.
    :vartype unvalidated_docs_count: int
    :ivar confirmed_docs_count: Number of validated documents in the collection.
    :vartype confirmed_docs_count: int
    :ivar ingest_email: When you send email to this address, any document attached in the body will
     be uploaded to this collection.
    :vartype ingest_email: str
    :ivar tailored_extractor_requested: Whether a tailored extractor has been requested for this
     collection.
    :vartype tailored_extractor_requested: bool
    :ivar allow_openai: Whether to allow OpenAI API to be used to assist in creating a model for
     this collection.
    :vartype allow_openai: bool
    :ivar trains_extractor: Whether this collection feeds documents into the extractor's training
     queue. This setting can only be toggled for custom extractors.
    :vartype trains_extractor: bool
    :ivar disable_confirmation_if_validation_rules_fail: If True, users cannot validate documents
     with missing mandatory fields, or failing validation rules.
    :vartype disable_confirmation_if_validation_rules_fail: bool
    """

    _validation = {
        "identifier": {"required": True},
        "unvalidated_docs_count": {"minimum": 0},
        "confirmed_docs_count": {"minimum": 0},
    }

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "workspace": {"key": "workspace", "type": "CollectionWorkspace"},
        "extractor": {"key": "extractor", "type": "Extractor"},
        "auto_validation_threshold": {"key": "autoValidationThreshold", "type": "float"},
        "auto_validate_if_validation_rules_pass": {
            "key": "autoValidateIfValidationRulesPass",
            "type": "bool",
        },
        "fields": {"key": "fields", "type": "[FieldGroup]"},
        "fields_layout": {"key": "fieldsLayout", "type": "FieldsLayout"},
        "fields_configured": {"key": "fieldsConfigured", "type": "bool"},
        "date_format_preference": {"key": "dateFormatPreference", "type": "str"},
        "date_format_from_document": {"key": "dateFormatFromDocument", "type": "bool"},
        "extractor_config": {"key": "extractorConfig", "type": "ExtractorConfig"},
        "unvalidated_docs_count": {"key": "unvalidatedDocsCount", "type": "int"},
        "confirmed_docs_count": {"key": "confirmedDocsCount", "type": "int"},
        "ingest_email": {"key": "ingestEmail", "type": "str"},
        "tailored_extractor_requested": {"key": "tailoredExtractorRequested", "type": "bool"},
        "allow_openai": {"key": "allowOpenai", "type": "bool"},
        "trains_extractor": {"key": "trainsExtractor", "type": "bool"},
        "disable_confirmation_if_validation_rules_fail": {
            "key": "disableConfirmationIfValidationRulesFail",
            "type": "bool",
        },
    }

    def __init__(self, **kwargs):
        """
        :keyword identifier: Required. Uniquely identify a collection.
        :paramtype identifier: str
        :keyword name:
        :paramtype name: str
        :keyword workspace:
        :paramtype workspace: ~affinda.models.CollectionWorkspace
        :keyword extractor:
        :paramtype extractor: ~affinda.models.Extractor
        :keyword auto_validation_threshold:
        :paramtype auto_validation_threshold: float
        :keyword auto_validate_if_validation_rules_pass:
        :paramtype auto_validate_if_validation_rules_pass: bool
        :keyword fields:
        :paramtype fields: list[~affinda.models.FieldGroup]
        :keyword fields_layout:
        :paramtype fields_layout: ~affinda.models.FieldsLayout
        :keyword fields_configured:
        :paramtype fields_configured: bool
        :keyword date_format_preference: Known values are: "DMY", "MDY", "YMD".
        :paramtype date_format_preference: str or ~affinda.models.CollectionDateFormatPreference
        :keyword date_format_from_document: Predict the date format from any dates in the document that
         is not ambiguous.
        :paramtype date_format_from_document: bool
        :keyword extractor_config: Extra configurations specific to an extractor.
        :paramtype extractor_config: ~affinda.models.ExtractorConfig
        :keyword unvalidated_docs_count: Number of unvalidated documents in the collection.
        :paramtype unvalidated_docs_count: int
        :keyword confirmed_docs_count: Number of validated documents in the collection.
        :paramtype confirmed_docs_count: int
        :keyword ingest_email: When you send email to this address, any document attached in the body
         will be uploaded to this collection.
        :paramtype ingest_email: str
        :keyword tailored_extractor_requested: Whether a tailored extractor has been requested for this
         collection.
        :paramtype tailored_extractor_requested: bool
        :keyword allow_openai: Whether to allow OpenAI API to be used to assist in creating a model for
         this collection.
        :paramtype allow_openai: bool
        :keyword trains_extractor: Whether this collection feeds documents into the extractor's
         training queue. This setting can only be toggled for custom extractors.
        :paramtype trains_extractor: bool
        :keyword disable_confirmation_if_validation_rules_fail: If True, users cannot validate
         documents with missing mandatory fields, or failing validation rules.
        :paramtype disable_confirmation_if_validation_rules_fail: bool
        """
        super(Collection, self).__init__(**kwargs)
        self.identifier = kwargs["identifier"]
        self.name = kwargs.get("name", None)
        self.workspace = kwargs.get("workspace", None)
        self.extractor = kwargs.get("extractor", None)
        self.auto_validation_threshold = kwargs.get("auto_validation_threshold", None)
        self.auto_validate_if_validation_rules_pass = kwargs.get(
            "auto_validate_if_validation_rules_pass", None
        )
        self.fields = kwargs.get("fields", None)
        self.fields_layout = kwargs.get("fields_layout", None)
        self.fields_configured = kwargs.get("fields_configured", None)
        self.date_format_preference = kwargs.get("date_format_preference", None)
        self.date_format_from_document = kwargs.get("date_format_from_document", None)
        self.extractor_config = kwargs.get("extractor_config", None)
        self.unvalidated_docs_count = kwargs.get("unvalidated_docs_count", None)
        self.confirmed_docs_count = kwargs.get("confirmed_docs_count", None)
        self.ingest_email = kwargs.get("ingest_email", None)
        self.tailored_extractor_requested = kwargs.get("tailored_extractor_requested", None)
        self.allow_openai = kwargs.get("allow_openai", False)
        self.trains_extractor = kwargs.get("trains_extractor", None)
        self.disable_confirmation_if_validation_rules_fail = kwargs.get(
            "disable_confirmation_if_validation_rules_fail", False
        )


class CollectionCreate(msrest.serialization.Model):
    """CollectionCreate.

    All required parameters must be populated in order to send to Azure.

    :ivar name: Required.
    :vartype name: str
    :ivar workspace: Required. Uniquely identify a workspace.
    :vartype workspace: str
    :ivar extractor: Uniquely identify an extractor. Required if you are not a super user.
    :vartype extractor: str
    :ivar base_extractor: Not applicable, please leave empty. This feature is reserved for super
     user.
    :vartype base_extractor: str
    :ivar auto_validation_threshold:
    :vartype auto_validation_threshold: float
    :ivar fields:
    :vartype fields: list[~affinda.models.FieldGroup]
    :ivar fields_layout:
    :vartype fields_layout: ~affinda.models.FieldsLayout
    :ivar date_format_preference: Known values are: "DMY", "MDY", "YMD".
    :vartype date_format_preference: str or ~affinda.models.DateFormatPreference
    :ivar date_format_from_document: Predict the date format from any dates in the document that is
     not ambiguous.
    :vartype date_format_from_document: bool
    :ivar extractor_config: Extra configurations specific to an extractor.
    :vartype extractor_config: ~affinda.models.ExtractorConfig
    :ivar allow_openai: Whether to allow OpenAI API to be used to assist in creating a model for
     this collection.
    :vartype allow_openai: bool
    :ivar trains_extractor: Whether this collection feeds documents into the extractor's training
     queue. This setting can only be toggled for custom extractors.
    :vartype trains_extractor: bool
    :ivar disable_confirmation_if_validation_rules_fail: If True, users cannot validate documents
     with missing mandatory fields, or failing validation rules.
    :vartype disable_confirmation_if_validation_rules_fail: bool
    """

    _validation = {
        "name": {"required": True},
        "workspace": {"required": True},
    }

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "workspace": {"key": "workspace", "type": "str"},
        "extractor": {"key": "extractor", "type": "str"},
        "base_extractor": {"key": "baseExtractor", "type": "str"},
        "auto_validation_threshold": {"key": "autoValidationThreshold", "type": "float"},
        "fields": {"key": "fields", "type": "[FieldGroup]"},
        "fields_layout": {"key": "fieldsLayout", "type": "FieldsLayout"},
        "date_format_preference": {"key": "dateFormatPreference", "type": "str"},
        "date_format_from_document": {"key": "dateFormatFromDocument", "type": "bool"},
        "extractor_config": {"key": "extractorConfig", "type": "ExtractorConfig"},
        "allow_openai": {"key": "allowOpenai", "type": "bool"},
        "trains_extractor": {"key": "trainsExtractor", "type": "bool"},
        "disable_confirmation_if_validation_rules_fail": {
            "key": "disableConfirmationIfValidationRulesFail",
            "type": "bool",
        },
    }

    def __init__(self, **kwargs):
        """
        :keyword name: Required.
        :paramtype name: str
        :keyword workspace: Required. Uniquely identify a workspace.
        :paramtype workspace: str
        :keyword extractor: Uniquely identify an extractor. Required if you are not a super user.
        :paramtype extractor: str
        :keyword base_extractor: Not applicable, please leave empty. This feature is reserved for super
         user.
        :paramtype base_extractor: str
        :keyword auto_validation_threshold:
        :paramtype auto_validation_threshold: float
        :keyword fields:
        :paramtype fields: list[~affinda.models.FieldGroup]
        :keyword fields_layout:
        :paramtype fields_layout: ~affinda.models.FieldsLayout
        :keyword date_format_preference: Known values are: "DMY", "MDY", "YMD".
        :paramtype date_format_preference: str or ~affinda.models.DateFormatPreference
        :keyword date_format_from_document: Predict the date format from any dates in the document that
         is not ambiguous.
        :paramtype date_format_from_document: bool
        :keyword extractor_config: Extra configurations specific to an extractor.
        :paramtype extractor_config: ~affinda.models.ExtractorConfig
        :keyword allow_openai: Whether to allow OpenAI API to be used to assist in creating a model for
         this collection.
        :paramtype allow_openai: bool
        :keyword trains_extractor: Whether this collection feeds documents into the extractor's
         training queue. This setting can only be toggled for custom extractors.
        :paramtype trains_extractor: bool
        :keyword disable_confirmation_if_validation_rules_fail: If True, users cannot validate
         documents with missing mandatory fields, or failing validation rules.
        :paramtype disable_confirmation_if_validation_rules_fail: bool
        """
        super(CollectionCreate, self).__init__(**kwargs)
        self.name = kwargs["name"]
        self.workspace = kwargs["workspace"]
        self.extractor = kwargs.get("extractor", None)
        self.base_extractor = kwargs.get("base_extractor", None)
        self.auto_validation_threshold = kwargs.get("auto_validation_threshold", None)
        self.fields = kwargs.get("fields", None)
        self.fields_layout = kwargs.get("fields_layout", None)
        self.date_format_preference = kwargs.get("date_format_preference", None)
        self.date_format_from_document = kwargs.get("date_format_from_document", None)
        self.extractor_config = kwargs.get("extractor_config", None)
        self.allow_openai = kwargs.get("allow_openai", False)
        self.trains_extractor = kwargs.get("trains_extractor", None)
        self.disable_confirmation_if_validation_rules_fail = kwargs.get(
            "disable_confirmation_if_validation_rules_fail", False
        )


class CollectionField(msrest.serialization.Model):
    """CollectionField.

    :ivar label:
    :vartype label: str
    :ivar field_type: The different data types of annotations. Known values are: "text", "integer",
     "float", "decimal", "date", "datetime", "daterange", "boolean", "enum", "location",
     "phonenumber", "json", "table", "expectedremuneration", "jobtitle", "language", "skill",
     "yearsexperience", "group", "table_deprecated", "url", "image".
    :vartype field_type: str or ~affinda.models.AnnotationContentType
    :ivar mandatory:
    :vartype mandatory: bool
    :ivar show_dropdown:
    :vartype show_dropdown: bool
    :ivar display_enum_value: If true, both the value and the label for the enums will appear in
     the dropdown in the validation tool.
    :vartype display_enum_value: bool
    :ivar auto_validation_threshold:
    :vartype auto_validation_threshold: float
    :ivar data_source: Data source mapping identifier.
    :vartype data_source: str
    :ivar mapping: Defines how the data point is mapped to the data source.
    :vartype mapping: str
    :ivar display_raw_text: Defines how the data point is mapped to the data source.
    :vartype display_raw_text: str
    """

    _validation = {
        "auto_validation_threshold": {"maximum": 1, "minimum": 0},
    }

    _attribute_map = {
        "label": {"key": "label", "type": "str"},
        "field_type": {"key": "fieldType", "type": "str"},
        "mandatory": {"key": "mandatory", "type": "bool"},
        "show_dropdown": {"key": "showDropdown", "type": "bool"},
        "display_enum_value": {"key": "displayEnumValue", "type": "bool"},
        "auto_validation_threshold": {"key": "autoValidationThreshold", "type": "float"},
        "data_source": {"key": "dataSource", "type": "str"},
        "mapping": {"key": "mapping", "type": "str"},
        "display_raw_text": {"key": "displayRawText", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword label:
        :paramtype label: str
        :keyword field_type: The different data types of annotations. Known values are: "text",
         "integer", "float", "decimal", "date", "datetime", "daterange", "boolean", "enum", "location",
         "phonenumber", "json", "table", "expectedremuneration", "jobtitle", "language", "skill",
         "yearsexperience", "group", "table_deprecated", "url", "image".
        :paramtype field_type: str or ~affinda.models.AnnotationContentType
        :keyword mandatory:
        :paramtype mandatory: bool
        :keyword show_dropdown:
        :paramtype show_dropdown: bool
        :keyword display_enum_value: If true, both the value and the label for the enums will appear in
         the dropdown in the validation tool.
        :paramtype display_enum_value: bool
        :keyword auto_validation_threshold:
        :paramtype auto_validation_threshold: float
        :keyword data_source: Data source mapping identifier.
        :paramtype data_source: str
        :keyword mapping: Defines how the data point is mapped to the data source.
        :paramtype mapping: str
        :keyword display_raw_text: Defines how the data point is mapped to the data source.
        :paramtype display_raw_text: str
        """
        super(CollectionField, self).__init__(**kwargs)
        self.label = kwargs.get("label", None)
        self.field_type = kwargs.get("field_type", None)
        self.mandatory = kwargs.get("mandatory", None)
        self.show_dropdown = kwargs.get("show_dropdown", None)
        self.display_enum_value = kwargs.get("display_enum_value", None)
        self.auto_validation_threshold = kwargs.get("auto_validation_threshold", None)
        self.data_source = kwargs.get("data_source", None)
        self.mapping = kwargs.get("mapping", None)
        self.display_raw_text = kwargs.get("display_raw_text", None)


class CollectionUpdate(msrest.serialization.Model):
    """CollectionUpdate.

    :ivar name:
    :vartype name: str
    :ivar auto_validation_threshold:
    :vartype auto_validation_threshold: float
    :ivar fields:
    :vartype fields: list[~affinda.models.FieldGroup]
    :ivar fields_layout:
    :vartype fields_layout: ~affinda.models.FieldsLayout
    :ivar date_format_preference: Known values are: "DMY", "MDY", "YMD".
    :vartype date_format_preference: str or ~affinda.models.DateFormatPreference
    :ivar date_format_from_document: Predict the date format from any dates in the document that is
     not ambiguous.
    :vartype date_format_from_document: bool
    :ivar extractor_config: Extra configurations specific to an extractor.
    :vartype extractor_config: ~affinda.models.ExtractorConfig
    :ivar allow_openai: Whether to allow OpenAI API to be used to assist in creating a model for
     this collection.
    :vartype allow_openai: bool
    :ivar trains_extractor: Whether this collection feeds documents into the extractor's training
     queue. This setting can only be toggled for custom extractors.
    :vartype trains_extractor: bool
    :ivar disable_confirmation_if_validation_rules_fail: If True, users cannot validate documents
     with missing mandatory fields, or failing validation rules.
    :vartype disable_confirmation_if_validation_rules_fail: bool
    """

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "auto_validation_threshold": {"key": "autoValidationThreshold", "type": "float"},
        "fields": {"key": "fields", "type": "[FieldGroup]"},
        "fields_layout": {"key": "fieldsLayout", "type": "FieldsLayout"},
        "date_format_preference": {"key": "dateFormatPreference", "type": "str"},
        "date_format_from_document": {"key": "dateFormatFromDocument", "type": "bool"},
        "extractor_config": {"key": "extractorConfig", "type": "ExtractorConfig"},
        "allow_openai": {"key": "allowOpenai", "type": "bool"},
        "trains_extractor": {"key": "trainsExtractor", "type": "bool"},
        "disable_confirmation_if_validation_rules_fail": {
            "key": "disableConfirmationIfValidationRulesFail",
            "type": "bool",
        },
    }

    def __init__(self, **kwargs):
        """
        :keyword name:
        :paramtype name: str
        :keyword auto_validation_threshold:
        :paramtype auto_validation_threshold: float
        :keyword fields:
        :paramtype fields: list[~affinda.models.FieldGroup]
        :keyword fields_layout:
        :paramtype fields_layout: ~affinda.models.FieldsLayout
        :keyword date_format_preference: Known values are: "DMY", "MDY", "YMD".
        :paramtype date_format_preference: str or ~affinda.models.DateFormatPreference
        :keyword date_format_from_document: Predict the date format from any dates in the document that
         is not ambiguous.
        :paramtype date_format_from_document: bool
        :keyword extractor_config: Extra configurations specific to an extractor.
        :paramtype extractor_config: ~affinda.models.ExtractorConfig
        :keyword allow_openai: Whether to allow OpenAI API to be used to assist in creating a model for
         this collection.
        :paramtype allow_openai: bool
        :keyword trains_extractor: Whether this collection feeds documents into the extractor's
         training queue. This setting can only be toggled for custom extractors.
        :paramtype trains_extractor: bool
        :keyword disable_confirmation_if_validation_rules_fail: If True, users cannot validate
         documents with missing mandatory fields, or failing validation rules.
        :paramtype disable_confirmation_if_validation_rules_fail: bool
        """
        super(CollectionUpdate, self).__init__(**kwargs)
        self.name = kwargs.get("name", None)
        self.auto_validation_threshold = kwargs.get("auto_validation_threshold", None)
        self.fields = kwargs.get("fields", None)
        self.fields_layout = kwargs.get("fields_layout", None)
        self.date_format_preference = kwargs.get("date_format_preference", None)
        self.date_format_from_document = kwargs.get("date_format_from_document", None)
        self.extractor_config = kwargs.get("extractor_config", None)
        self.allow_openai = kwargs.get("allow_openai", False)
        self.trains_extractor = kwargs.get("trains_extractor", None)
        self.disable_confirmation_if_validation_rules_fail = kwargs.get(
            "disable_confirmation_if_validation_rules_fail", False
        )


class CollectionWorkspace(msrest.serialization.Model):
    """CollectionWorkspace.

    :ivar identifier: Uniquely identify a workspace.
    :vartype identifier: str
    :ivar organization:
    :vartype organization: ~affinda.models.Organization
    :ivar name:
    :vartype name: str
    """

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
        "organization": {"key": "organization", "type": "Organization"},
        "name": {"key": "name", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword identifier: Uniquely identify a workspace.
        :paramtype identifier: str
        :keyword organization:
        :paramtype organization: ~affinda.models.Organization
        :keyword name:
        :paramtype name: str
        """
        super(CollectionWorkspace, self).__init__(**kwargs)
        self.identifier = kwargs.get("identifier", None)
        self.organization = kwargs.get("organization", None)
        self.name = kwargs.get("name", None)


class Components159Ji55SchemasResumesearchdetailPropertiesLanguagesPropertiesValueItemsAllof1(
    msrest.serialization.Model
):
    """Components159Ji55SchemasResumesearchdetailPropertiesLanguagesPropertiesValueItemsAllof1.

    :ivar match:
    :vartype match: bool
    """

    _attribute_map = {
        "match": {"key": "match", "type": "bool"},
    }

    def __init__(self, **kwargs):
        """
        :keyword match:
        :paramtype match: bool
        """
        super(
            Components159Ji55SchemasResumesearchdetailPropertiesLanguagesPropertiesValueItemsAllof1,
            self,
        ).__init__(**kwargs)
        self.match = kwargs.get("match", None)


class Components1Kwk9B6SchemasThemeconfigPropertiesPalettePropertiesBackgroundOneof1(
    msrest.serialization.Model
):
    """Components1Kwk9B6SchemasThemeconfigPropertiesPalettePropertiesBackgroundOneof1.

    :ivar default:
    :vartype default: str
    :ivar paper:
    :vartype paper: str
    """

    _attribute_map = {
        "default": {"key": "default", "type": "str"},
        "paper": {"key": "paper", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword default:
        :paramtype default: str
        :keyword paper:
        :paramtype paper: str
        """
        super(
            Components1Kwk9B6SchemasThemeconfigPropertiesPalettePropertiesBackgroundOneof1, self
        ).__init__(**kwargs)
        self.default = kwargs.get("default", None)
        self.paper = kwargs.get("paper", None)


class Components1TlnsonSchemasJobdescriptionsearchdetailPropertiesLocationPropertiesValueAllof1(
    msrest.serialization.Model
):
    """Components1TlnsonSchemasJobdescriptionsearchdetailPropertiesLocationPropertiesValueAllof1.

    :ivar match:
    :vartype match: bool
    """

    _attribute_map = {
        "match": {"key": "match", "type": "bool"},
    }

    def __init__(self, **kwargs):
        """
        :keyword match:
        :paramtype match: bool
        """
        super(
            Components1TlnsonSchemasJobdescriptionsearchdetailPropertiesLocationPropertiesValueAllof1,
            self,
        ).__init__(**kwargs)
        self.match = kwargs.get("match", None)


class Components1TryetgSchemasResumedataPropertiesWorkexperienceItemsPropertiesOccupationPropertiesClassification(
    msrest.serialization.Model
):
    """Components1TryetgSchemasResumedataPropertiesWorkexperienceItemsPropertiesOccupationPropertiesClassification.

    :ivar title: SOC2020 classification for this job title.
    :vartype title: str
    :ivar minor_group: SOC2020 minor group.
    :vartype minor_group: str
    :ivar sub_major_group: SOC2020 sub major group.
    :vartype sub_major_group: str
    :ivar major_group: SOC2020 major group.
    :vartype major_group: str
    :ivar soc_code: The 4 digit code representing the SOC2020 classification for this job title.
    :vartype soc_code: int
    :ivar minor_group_code: The 4 digit code representing the SOC2020 classification for this job
     title.
    :vartype minor_group_code: int
    :ivar sub_major_group_code: The 4 digit code representing the SOC2020 classification for this
     job title.
    :vartype sub_major_group_code: int
    :ivar major_group_code: The 4 digit code representing the SOC2020 classification for this job
     title.
    :vartype major_group_code: int
    """

    _validation = {
        "soc_code": {"maximum": 9999, "minimum": 1},
        "minor_group_code": {"maximum": 9999, "minimum": 1},
        "sub_major_group_code": {"maximum": 9999, "minimum": 1},
        "major_group_code": {"maximum": 9999, "minimum": 1},
    }

    _attribute_map = {
        "title": {"key": "title", "type": "str"},
        "minor_group": {"key": "minorGroup", "type": "str"},
        "sub_major_group": {"key": "subMajorGroup", "type": "str"},
        "major_group": {"key": "majorGroup", "type": "str"},
        "soc_code": {"key": "socCode", "type": "int"},
        "minor_group_code": {"key": "minorGroupCode", "type": "int"},
        "sub_major_group_code": {"key": "subMajorGroupCode", "type": "int"},
        "major_group_code": {"key": "majorGroupCode", "type": "int"},
    }

    def __init__(self, **kwargs):
        """
        :keyword title: SOC2020 classification for this job title.
        :paramtype title: str
        :keyword minor_group: SOC2020 minor group.
        :paramtype minor_group: str
        :keyword sub_major_group: SOC2020 sub major group.
        :paramtype sub_major_group: str
        :keyword major_group: SOC2020 major group.
        :paramtype major_group: str
        :keyword soc_code: The 4 digit code representing the SOC2020 classification for this job title.
        :paramtype soc_code: int
        :keyword minor_group_code: The 4 digit code representing the SOC2020 classification for this
         job title.
        :paramtype minor_group_code: int
        :keyword sub_major_group_code: The 4 digit code representing the SOC2020 classification for
         this job title.
        :paramtype sub_major_group_code: int
        :keyword major_group_code: The 4 digit code representing the SOC2020 classification for this
         job title.
        :paramtype major_group_code: int
        """
        super(
            Components1TryetgSchemasResumedataPropertiesWorkexperienceItemsPropertiesOccupationPropertiesClassification,
            self,
        ).__init__(**kwargs)
        self.title = kwargs.get("title", None)
        self.minor_group = kwargs.get("minor_group", None)
        self.sub_major_group = kwargs.get("sub_major_group", None)
        self.major_group = kwargs.get("major_group", None)
        self.soc_code = kwargs.get("soc_code", None)
        self.minor_group_code = kwargs.get("minor_group_code", None)
        self.sub_major_group_code = kwargs.get("sub_major_group_code", None)
        self.major_group_code = kwargs.get("major_group_code", None)


class ComponentsH65QjbSchemasResumesearchdetailPropertiesSkillsPropertiesValueItemsAllof1(
    msrest.serialization.Model
):
    """ComponentsH65QjbSchemasResumesearchdetailPropertiesSkillsPropertiesValueItemsAllof1.

    :ivar match:
    :vartype match: bool
    """

    _attribute_map = {
        "match": {"key": "match", "type": "bool"},
    }

    def __init__(self, **kwargs):
        """
        :keyword match:
        :paramtype match: bool
        """
        super(
            ComponentsH65QjbSchemasResumesearchdetailPropertiesSkillsPropertiesValueItemsAllof1,
            self,
        ).__init__(**kwargs)
        self.match = kwargs.get("match", None)


class ComponentsN9ShogSchemasResumesearchdetailPropertiesLocationPropertiesValueAllof1(
    msrest.serialization.Model
):
    """ComponentsN9ShogSchemasResumesearchdetailPropertiesLocationPropertiesValueAllof1.

    :ivar match:
    :vartype match: bool
    """

    _attribute_map = {
        "match": {"key": "match", "type": "bool"},
    }

    def __init__(self, **kwargs):
        """
        :keyword match:
        :paramtype match: bool
        """
        super(
            ComponentsN9ShogSchemasResumesearchdetailPropertiesLocationPropertiesValueAllof1, self
        ).__init__(**kwargs)
        self.match = kwargs.get("match", None)


class ComponentsNqbw24SchemasCustomdatasearchscorecomponentAdditionalproperties(
    msrest.serialization.Model
):
    """ComponentsNqbw24SchemasCustomdatasearchscorecomponentAdditionalproperties.

    All required parameters must be populated in order to send to Azure.

    :ivar value:
    :vartype value: str
    :ivar label: Required.
    :vartype label: str
    :ivar score:
    :vartype score: float
    """

    _validation = {
        "label": {"required": True},
    }

    _attribute_map = {
        "value": {"key": "value", "type": "str"},
        "label": {"key": "label", "type": "str"},
        "score": {"key": "score", "type": "float"},
    }

    def __init__(self, **kwargs):
        """
        :keyword value:
        :paramtype value: str
        :keyword label: Required.
        :paramtype label: str
        :keyword score:
        :paramtype score: float
        """
        super(
            ComponentsNqbw24SchemasCustomdatasearchscorecomponentAdditionalproperties, self
        ).__init__(**kwargs)
        self.value = kwargs.get("value", None)
        self.label = kwargs["label"]
        self.score = kwargs.get("score", None)


class ComponentsSxu0N3SchemasResumesearchdetailPropertiesEducationPropertiesValueItemsAllof1(
    msrest.serialization.Model
):
    """ComponentsSxu0N3SchemasResumesearchdetailPropertiesEducationPropertiesValueItemsAllof1.

    :ivar match:
    :vartype match: bool
    """

    _attribute_map = {
        "match": {"key": "match", "type": "bool"},
    }

    def __init__(self, **kwargs):
        """
        :keyword match:
        :paramtype match: bool
        """
        super(
            ComponentsSxu0N3SchemasResumesearchdetailPropertiesEducationPropertiesValueItemsAllof1,
            self,
        ).__init__(**kwargs)
        self.match = kwargs.get("match", None)


class CurrencyCodeAnnotation(Annotation):
    """CurrencyCodeAnnotation.

    All required parameters must be populated in order to send to Azure.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id: Required. Annotation's ID.
    :vartype id: int
    :ivar rectangle: Required. x/y coordinates for the rectangular bounding box containing the
     data.
    :vartype rectangle: ~affinda.models.Rectangle
    :ivar rectangles: Required. x/y coordinates for the rectangles containing the data. An
     annotation can be contained within multiple rectangles.
    :vartype rectangles: list[~affinda.models.Rectangle]
    :ivar document: Required. Unique identifier for the document.
    :vartype document: str
    :ivar page_index: Required. The page number within the document, starting from 0.
    :vartype page_index: int
    :ivar raw: Required. Raw data extracted from the before any post-processing.
    :vartype raw: str
    :ivar confidence: Required. The overall confidence that the model's prediction is correct.
    :vartype confidence: float
    :ivar classification_confidence: Required. The model's confidence that the text has been
     classified correctly.
    :vartype classification_confidence: float
    :ivar text_extraction_confidence: Required. If the document was submitted as an image, this is
     the confidence that the text in the image has been correctly read by the model.
    :vartype text_extraction_confidence: float
    :ivar is_verified: Required. Indicates whether the data has been validated, either by a human
     using our validation tool or through auto-validation rules.
    :vartype is_verified: bool
    :ivar is_client_verified: Required. Indicates whether the data has been validated by a human.
    :vartype is_client_verified: bool
    :ivar is_auto_verified: Required. Indicates whether the data has been auto-validated.
    :vartype is_auto_verified: bool
    :ivar data_point: Required. Data point's identifier.
    :vartype data_point: str
    :ivar content_type: Required. The different data types of annotations. Known values are:
     "text", "integer", "float", "decimal", "date", "datetime", "daterange", "boolean", "enum",
     "location", "phonenumber", "json", "table", "expectedremuneration", "jobtitle", "language",
     "skill", "yearsexperience", "group", "table_deprecated", "url", "image".
    :vartype content_type: str or ~affinda.models.AnnotationContentType
    :ivar parent: The parent annotation's ID.
    :vartype parent: int
    :ivar parsed:
    :vartype parsed: ~affinda.models.DataPointChoice
    """

    _validation = {
        "id": {"required": True, "minimum": 1},
        "rectangle": {"required": True},
        "rectangles": {"required": True},
        "document": {"required": True},
        "page_index": {"required": True, "minimum": 0},
        "raw": {"required": True},
        "confidence": {"required": True},
        "classification_confidence": {"required": True},
        "text_extraction_confidence": {"required": True},
        "is_verified": {"required": True},
        "is_client_verified": {"required": True},
        "is_auto_verified": {"required": True},
        "data_point": {"required": True},
        "content_type": {"required": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "int"},
        "rectangle": {"key": "rectangle", "type": "Rectangle"},
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "document": {"key": "document", "type": "str"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "confidence": {"key": "confidence", "type": "float"},
        "classification_confidence": {"key": "classificationConfidence", "type": "float"},
        "text_extraction_confidence": {"key": "textExtractionConfidence", "type": "float"},
        "is_verified": {"key": "isVerified", "type": "bool"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "is_auto_verified": {"key": "isAutoVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "content_type": {"key": "contentType", "type": "str"},
        "parent": {"key": "parent", "type": "int"},
        "parsed": {"key": "parsed", "type": "DataPointChoice"},
    }

    def __init__(self, **kwargs):
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword id: Required. Annotation's ID.
        :paramtype id: int
        :keyword rectangle: Required. x/y coordinates for the rectangular bounding box containing the
         data.
        :paramtype rectangle: ~affinda.models.Rectangle
        :keyword rectangles: Required. x/y coordinates for the rectangles containing the data. An
         annotation can be contained within multiple rectangles.
        :paramtype rectangles: list[~affinda.models.Rectangle]
        :keyword document: Required. Unique identifier for the document.
        :paramtype document: str
        :keyword page_index: Required. The page number within the document, starting from 0.
        :paramtype page_index: int
        :keyword raw: Required. Raw data extracted from the before any post-processing.
        :paramtype raw: str
        :keyword confidence: Required. The overall confidence that the model's prediction is correct.
        :paramtype confidence: float
        :keyword classification_confidence: Required. The model's confidence that the text has been
         classified correctly.
        :paramtype classification_confidence: float
        :keyword text_extraction_confidence: Required. If the document was submitted as an image, this
         is the confidence that the text in the image has been correctly read by the model.
        :paramtype text_extraction_confidence: float
        :keyword is_verified: Required. Indicates whether the data has been validated, either by a
         human using our validation tool or through auto-validation rules.
        :paramtype is_verified: bool
        :keyword is_client_verified: Required. Indicates whether the data has been validated by a
         human.
        :paramtype is_client_verified: bool
        :keyword is_auto_verified: Required. Indicates whether the data has been auto-validated.
        :paramtype is_auto_verified: bool
        :keyword data_point: Required. Data point's identifier.
        :paramtype data_point: str
        :keyword content_type: Required. The different data types of annotations. Known values are:
         "text", "integer", "float", "decimal", "date", "datetime", "daterange", "boolean", "enum",
         "location", "phonenumber", "json", "table", "expectedremuneration", "jobtitle", "language",
         "skill", "yearsexperience", "group", "table_deprecated", "url", "image".
        :paramtype content_type: str or ~affinda.models.AnnotationContentType
        :keyword parent: The parent annotation's ID.
        :paramtype parent: int
        :keyword parsed:
        :paramtype parsed: ~affinda.models.DataPointChoice
        """
        super(CurrencyCodeAnnotation, self).__init__(**kwargs)
        self.parsed = kwargs.get("parsed", None)


class CustomFieldConfig(msrest.serialization.Model):
    """CustomFieldConfig.

    All required parameters must be populated in order to send to Azure.

    :ivar data_point: Required. Data point identifier.
    :vartype data_point: str
    :ivar weight: Required.
    :vartype weight: float
    """

    _validation = {
        "data_point": {"required": True},
        "weight": {"required": True, "maximum": 1, "minimum": 0},
    }

    _attribute_map = {
        "data_point": {"key": "dataPoint", "type": "str"},
        "weight": {"key": "weight", "type": "float"},
    }

    def __init__(self, **kwargs):
        """
        :keyword data_point: Required. Data point identifier.
        :paramtype data_point: str
        :keyword weight: Required.
        :paramtype weight: float
        """
        super(CustomFieldConfig, self).__init__(**kwargs)
        self.data_point = kwargs["data_point"]
        self.weight = kwargs.get("weight", 0.5)


class DataField(msrest.serialization.Model):
    """DataField.

    All required parameters must be populated in order to send to Azure.

    :ivar category_label: The label of the category that this field will be put into. If not
     provided, the field will be put into the default category. If no category exists with the
     specified label, a new category will be created.
    :vartype category_label: str
    :ivar field: Required. The field to be created.
    :vartype field: ~affinda.models.DataFieldField
    :ivar data_point: Required. The data point to be created for this field. If a data point with
     the same slug and collection already exists, it will be reused.
    :vartype data_point: ~affinda.models.DataFieldDataPoint
    """

    _validation = {
        "field": {"required": True},
        "data_point": {"required": True},
    }

    _attribute_map = {
        "category_label": {"key": "categoryLabel", "type": "str"},
        "field": {"key": "field", "type": "DataFieldField"},
        "data_point": {"key": "dataPoint", "type": "DataFieldDataPoint"},
    }

    def __init__(self, **kwargs):
        """
        :keyword category_label: The label of the category that this field will be put into. If not
         provided, the field will be put into the default category. If no category exists with the
         specified label, a new category will be created.
        :paramtype category_label: str
        :keyword field: Required. The field to be created.
        :paramtype field: ~affinda.models.DataFieldField
        :keyword data_point: Required. The data point to be created for this field. If a data point
         with the same slug and collection already exists, it will be reused.
        :paramtype data_point: ~affinda.models.DataFieldDataPoint
        """
        super(DataField, self).__init__(**kwargs)
        self.category_label = kwargs.get("category_label", None)
        self.field = kwargs["field"]
        self.data_point = kwargs["data_point"]


class DataFieldCreate(msrest.serialization.Model):
    """DataFieldCreate.

    All required parameters must be populated in order to send to Azure.

    :ivar category_label: The label of the category that this field will be put into. If not
     provided, the field will be put into the default category. If no category exists with the
     specified label, a new category will be created.
    :vartype category_label: str
    :ivar field: Required. The field to be created.
    :vartype field: ~affinda.models.DataFieldCreateField
    :ivar data_point: Required. The data point to be created for this field. If a data point with
     the same slug and collection already exists, it will be reused.
    :vartype data_point: ~affinda.models.DataFieldCreateDataPoint
    """

    _validation = {
        "field": {"required": True},
        "data_point": {"required": True},
    }

    _attribute_map = {
        "category_label": {"key": "categoryLabel", "type": "str"},
        "field": {"key": "field", "type": "DataFieldCreateField"},
        "data_point": {"key": "dataPoint", "type": "DataFieldCreateDataPoint"},
    }

    def __init__(self, **kwargs):
        """
        :keyword category_label: The label of the category that this field will be put into. If not
         provided, the field will be put into the default category. If no category exists with the
         specified label, a new category will be created.
        :paramtype category_label: str
        :keyword field: Required. The field to be created.
        :paramtype field: ~affinda.models.DataFieldCreateField
        :keyword data_point: Required. The data point to be created for this field. If a data point
         with the same slug and collection already exists, it will be reused.
        :paramtype data_point: ~affinda.models.DataFieldCreateDataPoint
        """
        super(DataFieldCreate, self).__init__(**kwargs)
        self.category_label = kwargs.get("category_label", None)
        self.field = kwargs["field"]
        self.data_point = kwargs["data_point"]


class DataFieldCreateDataPoint(msrest.serialization.Model):
    """The data point to be created for this field. If a data point with the same slug and collection already exists, it will be reused.

    All required parameters must be populated in order to send to Azure.

    :ivar name: Required. Name of the data point.
    :vartype name: str
    :ivar slug: Required. A camelCase string that will be used as the key in the API response.
    :vartype slug: str
    :ivar description:
    :vartype description: str
    :ivar type: Required. The different data types of annotations. Known values are: "text",
     "integer", "float", "decimal", "date", "datetime", "daterange", "boolean", "enum", "location",
     "phonenumber", "json", "table", "expectedremuneration", "jobtitle", "language", "skill",
     "yearsexperience", "group", "table_deprecated", "url", "image".
    :vartype type: str or ~affinda.models.AnnotationContentType
    :ivar multiple:
    :vartype multiple: bool
    :ivar no_rect:
    :vartype no_rect: bool
    :ivar parent: The identifier of the parent data point if applicable.
    :vartype parent: str
    :ivar manual_entry: If true, the model will not be used to predict this data point. Instead,
     the user will be able to manually enter the value in the validation tool.
    :vartype manual_entry: bool
    :ivar mapping_data_source: If populated, the model will learn to predict this field using the
     data source, rather than relying on fuzzy string matching.
    :vartype mapping_data_source: str
    """

    _validation = {
        "name": {"required": True},
        "slug": {"required": True},
        "type": {"required": True},
    }

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "slug": {"key": "slug", "type": "str"},
        "description": {"key": "description", "type": "str"},
        "type": {"key": "type", "type": "str"},
        "multiple": {"key": "multiple", "type": "bool"},
        "no_rect": {"key": "noRect", "type": "bool"},
        "parent": {"key": "parent", "type": "str"},
        "manual_entry": {"key": "manualEntry", "type": "bool"},
        "mapping_data_source": {"key": "mappingDataSource", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword name: Required. Name of the data point.
        :paramtype name: str
        :keyword slug: Required. A camelCase string that will be used as the key in the API response.
        :paramtype slug: str
        :keyword description:
        :paramtype description: str
        :keyword type: Required. The different data types of annotations. Known values are: "text",
         "integer", "float", "decimal", "date", "datetime", "daterange", "boolean", "enum", "location",
         "phonenumber", "json", "table", "expectedremuneration", "jobtitle", "language", "skill",
         "yearsexperience", "group", "table_deprecated", "url", "image".
        :paramtype type: str or ~affinda.models.AnnotationContentType
        :keyword multiple:
        :paramtype multiple: bool
        :keyword no_rect:
        :paramtype no_rect: bool
        :keyword parent: The identifier of the parent data point if applicable.
        :paramtype parent: str
        :keyword manual_entry: If true, the model will not be used to predict this data point. Instead,
         the user will be able to manually enter the value in the validation tool.
        :paramtype manual_entry: bool
        :keyword mapping_data_source: If populated, the model will learn to predict this field using
         the data source, rather than relying on fuzzy string matching.
        :paramtype mapping_data_source: str
        """
        super(DataFieldCreateDataPoint, self).__init__(**kwargs)
        self.name = kwargs["name"]
        self.slug = kwargs["slug"]
        self.description = kwargs.get("description", None)
        self.type = kwargs["type"]
        self.multiple = kwargs.get("multiple", None)
        self.no_rect = kwargs.get("no_rect", None)
        self.parent = kwargs.get("parent", None)
        self.manual_entry = kwargs.get("manual_entry", None)
        self.mapping_data_source = kwargs.get("mapping_data_source", None)


class DataFieldCreateField(msrest.serialization.Model):
    """The field to be created.

    All required parameters must be populated in order to send to Azure.

    :ivar label: Required.
    :vartype label: str
    :ivar field_type: The different data types of annotations. Known values are: "text", "integer",
     "float", "decimal", "date", "datetime", "daterange", "boolean", "enum", "location",
     "phonenumber", "json", "table", "expectedremuneration", "jobtitle", "language", "skill",
     "yearsexperience", "group", "table_deprecated", "url", "image".
    :vartype field_type: str or ~affinda.models.AnnotationContentType
    :ivar mandatory:
    :vartype mandatory: bool
    :ivar show_dropdown:
    :vartype show_dropdown: bool
    :ivar display_enum_value: If true, both the value and the label for the enums will appear in
     the dropdown in the validation tool.
    :vartype display_enum_value: bool
    :ivar auto_validation_threshold:
    :vartype auto_validation_threshold: float
    :ivar data_source: Data source mapping identifier.
    :vartype data_source: str
    :ivar mapping: Defines how the data point is mapped to the data source.
    :vartype mapping: str
    :ivar display_raw_text: If true, then the validation tool will show the user the raw text found
     on the page, not the value that has been parsed to a specific type.
    :vartype display_raw_text: bool
    """

    _validation = {
        "label": {"required": True},
        "auto_validation_threshold": {"maximum": 1, "minimum": 0},
    }

    _attribute_map = {
        "label": {"key": "label", "type": "str"},
        "field_type": {"key": "fieldType", "type": "str"},
        "mandatory": {"key": "mandatory", "type": "bool"},
        "show_dropdown": {"key": "showDropdown", "type": "bool"},
        "display_enum_value": {"key": "displayEnumValue", "type": "bool"},
        "auto_validation_threshold": {"key": "autoValidationThreshold", "type": "float"},
        "data_source": {"key": "dataSource", "type": "str"},
        "mapping": {"key": "mapping", "type": "str"},
        "display_raw_text": {"key": "displayRawText", "type": "bool"},
    }

    def __init__(self, **kwargs):
        """
        :keyword label: Required.
        :paramtype label: str
        :keyword field_type: The different data types of annotations. Known values are: "text",
         "integer", "float", "decimal", "date", "datetime", "daterange", "boolean", "enum", "location",
         "phonenumber", "json", "table", "expectedremuneration", "jobtitle", "language", "skill",
         "yearsexperience", "group", "table_deprecated", "url", "image".
        :paramtype field_type: str or ~affinda.models.AnnotationContentType
        :keyword mandatory:
        :paramtype mandatory: bool
        :keyword show_dropdown:
        :paramtype show_dropdown: bool
        :keyword display_enum_value: If true, both the value and the label for the enums will appear in
         the dropdown in the validation tool.
        :paramtype display_enum_value: bool
        :keyword auto_validation_threshold:
        :paramtype auto_validation_threshold: float
        :keyword data_source: Data source mapping identifier.
        :paramtype data_source: str
        :keyword mapping: Defines how the data point is mapped to the data source.
        :paramtype mapping: str
        :keyword display_raw_text: If true, then the validation tool will show the user the raw text
         found on the page, not the value that has been parsed to a specific type.
        :paramtype display_raw_text: bool
        """
        super(DataFieldCreateField, self).__init__(**kwargs)
        self.label = kwargs["label"]
        self.field_type = kwargs.get("field_type", None)
        self.mandatory = kwargs.get("mandatory", None)
        self.show_dropdown = kwargs.get("show_dropdown", None)
        self.display_enum_value = kwargs.get("display_enum_value", None)
        self.auto_validation_threshold = kwargs.get("auto_validation_threshold", None)
        self.data_source = kwargs.get("data_source", None)
        self.mapping = kwargs.get("mapping", None)
        self.display_raw_text = kwargs.get("display_raw_text", None)


class DataFieldDataPoint(msrest.serialization.Model):
    """The data point to be created for this field. If a data point with the same slug and collection already exists, it will be reused.

    All required parameters must be populated in order to send to Azure.

    :ivar identifier: Required. Uniquely identify a data point.
    :vartype identifier: str
    :ivar name: Required. Name of the data point.
    :vartype name: str
    :ivar slug: Required. A camelCase string that will be used as the key in the API response.
    :vartype slug: str
    :ivar description: Required.
    :vartype description: str
    :ivar type: Required. The different data types of annotations. Known values are: "text",
     "integer", "float", "decimal", "date", "datetime", "daterange", "boolean", "enum", "location",
     "phonenumber", "json", "table", "expectedremuneration", "jobtitle", "language", "skill",
     "yearsexperience", "group", "table_deprecated", "url", "image".
    :vartype type: str or ~affinda.models.AnnotationContentType
    :ivar multiple: Required.
    :vartype multiple: bool
    :ivar no_rect: Required.
    :vartype no_rect: bool
    :ivar parent: Required. The identifier of the parent data point if applicable.
    :vartype parent: str
    :ivar children: Required.
    :vartype children: list[~affinda.models.DataPoint]
    :ivar manual_entry: If true, the model will not be used to predict this data point. Instead,
     the user will be able to manually enter the value in the validation tool.
    :vartype manual_entry: bool
    :ivar available_data_sources:
    :vartype available_data_sources: list[~affinda.models.MappingDataSource]
    """

    _validation = {
        "identifier": {"required": True},
        "name": {"required": True},
        "slug": {"required": True},
        "description": {"required": True},
        "type": {"required": True},
        "multiple": {"required": True},
        "no_rect": {"required": True},
        "parent": {"required": True},
        "children": {"required": True},
    }

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "slug": {"key": "slug", "type": "str"},
        "description": {"key": "description", "type": "str"},
        "type": {"key": "type", "type": "str"},
        "multiple": {"key": "multiple", "type": "bool"},
        "no_rect": {"key": "noRect", "type": "bool"},
        "parent": {"key": "parent", "type": "str"},
        "children": {"key": "children", "type": "[DataPoint]"},
        "manual_entry": {"key": "manualEntry", "type": "bool"},
        "available_data_sources": {"key": "availableDataSources", "type": "[MappingDataSource]"},
    }

    def __init__(self, **kwargs):
        """
        :keyword identifier: Required. Uniquely identify a data point.
        :paramtype identifier: str
        :keyword name: Required. Name of the data point.
        :paramtype name: str
        :keyword slug: Required. A camelCase string that will be used as the key in the API response.
        :paramtype slug: str
        :keyword description: Required.
        :paramtype description: str
        :keyword type: Required. The different data types of annotations. Known values are: "text",
         "integer", "float", "decimal", "date", "datetime", "daterange", "boolean", "enum", "location",
         "phonenumber", "json", "table", "expectedremuneration", "jobtitle", "language", "skill",
         "yearsexperience", "group", "table_deprecated", "url", "image".
        :paramtype type: str or ~affinda.models.AnnotationContentType
        :keyword multiple: Required.
        :paramtype multiple: bool
        :keyword no_rect: Required.
        :paramtype no_rect: bool
        :keyword parent: Required. The identifier of the parent data point if applicable.
        :paramtype parent: str
        :keyword children: Required.
        :paramtype children: list[~affinda.models.DataPoint]
        :keyword manual_entry: If true, the model will not be used to predict this data point. Instead,
         the user will be able to manually enter the value in the validation tool.
        :paramtype manual_entry: bool
        :keyword available_data_sources:
        :paramtype available_data_sources: list[~affinda.models.MappingDataSource]
        """
        super(DataFieldDataPoint, self).__init__(**kwargs)
        self.identifier = kwargs["identifier"]
        self.name = kwargs["name"]
        self.slug = kwargs["slug"]
        self.description = kwargs["description"]
        self.type = kwargs["type"]
        self.multiple = kwargs["multiple"]
        self.no_rect = kwargs["no_rect"]
        self.parent = kwargs["parent"]
        self.children = kwargs["children"]
        self.manual_entry = kwargs.get("manual_entry", None)
        self.available_data_sources = kwargs.get("available_data_sources", None)


class DataFieldField(msrest.serialization.Model):
    """The field to be created.

    All required parameters must be populated in order to send to Azure.

    :ivar label: Required.
    :vartype label: str
    :ivar field_type: The different data types of annotations. Known values are: "text", "integer",
     "float", "decimal", "date", "datetime", "daterange", "boolean", "enum", "location",
     "phonenumber", "json", "table", "expectedremuneration", "jobtitle", "language", "skill",
     "yearsexperience", "group", "table_deprecated", "url", "image".
    :vartype field_type: str or ~affinda.models.AnnotationContentType
    :ivar mandatory: Required.
    :vartype mandatory: bool
    :ivar show_dropdown:
    :vartype show_dropdown: bool
    :ivar display_enum_value: Required. If true, both the value and the label for the enums will
     appear in the dropdown in the validation tool.
    :vartype display_enum_value: bool
    :ivar auto_validation_threshold: Required.
    :vartype auto_validation_threshold: float
    :ivar enabled_child_fields: Required.
    :vartype enabled_child_fields: list[~affinda.models.Field]
    :ivar disabled_child_fields: Required.
    :vartype disabled_child_fields: list[~affinda.models.Field]
    :ivar data_source: Data source mapping identifier.
    :vartype data_source: str
    :ivar mapping: Defines how the data point is mapped to the data source.
    :vartype mapping: str
    :ivar display_raw_text: If true, then the validation tool will show the user the raw text found
     on the page, not the value that has been parsed to a specific type.
    :vartype display_raw_text: bool
    """

    _validation = {
        "label": {"required": True},
        "mandatory": {"required": True},
        "display_enum_value": {"required": True},
        "auto_validation_threshold": {"required": True, "maximum": 1, "minimum": 0},
        "enabled_child_fields": {"required": True},
        "disabled_child_fields": {"required": True},
    }

    _attribute_map = {
        "label": {"key": "label", "type": "str"},
        "field_type": {"key": "fieldType", "type": "str"},
        "mandatory": {"key": "mandatory", "type": "bool"},
        "show_dropdown": {"key": "showDropdown", "type": "bool"},
        "display_enum_value": {"key": "displayEnumValue", "type": "bool"},
        "auto_validation_threshold": {"key": "autoValidationThreshold", "type": "float"},
        "enabled_child_fields": {"key": "enabledChildFields", "type": "[Field]"},
        "disabled_child_fields": {"key": "disabledChildFields", "type": "[Field]"},
        "data_source": {"key": "dataSource", "type": "str"},
        "mapping": {"key": "mapping", "type": "str"},
        "display_raw_text": {"key": "displayRawText", "type": "bool"},
    }

    def __init__(self, **kwargs):
        """
        :keyword label: Required.
        :paramtype label: str
        :keyword field_type: The different data types of annotations. Known values are: "text",
         "integer", "float", "decimal", "date", "datetime", "daterange", "boolean", "enum", "location",
         "phonenumber", "json", "table", "expectedremuneration", "jobtitle", "language", "skill",
         "yearsexperience", "group", "table_deprecated", "url", "image".
        :paramtype field_type: str or ~affinda.models.AnnotationContentType
        :keyword mandatory: Required.
        :paramtype mandatory: bool
        :keyword show_dropdown:
        :paramtype show_dropdown: bool
        :keyword display_enum_value: Required. If true, both the value and the label for the enums will
         appear in the dropdown in the validation tool.
        :paramtype display_enum_value: bool
        :keyword auto_validation_threshold: Required.
        :paramtype auto_validation_threshold: float
        :keyword enabled_child_fields: Required.
        :paramtype enabled_child_fields: list[~affinda.models.Field]
        :keyword disabled_child_fields: Required.
        :paramtype disabled_child_fields: list[~affinda.models.Field]
        :keyword data_source: Data source mapping identifier.
        :paramtype data_source: str
        :keyword mapping: Defines how the data point is mapped to the data source.
        :paramtype mapping: str
        :keyword display_raw_text: If true, then the validation tool will show the user the raw text
         found on the page, not the value that has been parsed to a specific type.
        :paramtype display_raw_text: bool
        """
        super(DataFieldField, self).__init__(**kwargs)
        self.label = kwargs["label"]
        self.field_type = kwargs.get("field_type", None)
        self.mandatory = kwargs["mandatory"]
        self.show_dropdown = kwargs.get("show_dropdown", None)
        self.display_enum_value = kwargs["display_enum_value"]
        self.auto_validation_threshold = kwargs["auto_validation_threshold"]
        self.enabled_child_fields = kwargs["enabled_child_fields"]
        self.disabled_child_fields = kwargs["disabled_child_fields"]
        self.data_source = kwargs.get("data_source", None)
        self.mapping = kwargs.get("mapping", None)
        self.display_raw_text = kwargs.get("display_raw_text", None)


class DataPoint(msrest.serialization.Model):
    """DataPoint.

    All required parameters must be populated in order to send to Azure.

    :ivar identifier: Required. Uniquely identify a data point.
    :vartype identifier: str
    :ivar name: Required. Name of the data point.
    :vartype name: str
    :ivar slug: Required. A camelCase string that will be used as the key in the API response.
    :vartype slug: str
    :ivar description:
    :vartype description: str
    :ivar annotation_content_type: Required. The different data types of annotations. Known values
     are: "text", "integer", "float", "decimal", "date", "datetime", "daterange", "boolean", "enum",
     "location", "phonenumber", "json", "table", "expectedremuneration", "jobtitle", "language",
     "skill", "yearsexperience", "group", "table_deprecated", "url", "image".
    :vartype annotation_content_type: str or ~affinda.models.AnnotationContentType
    :ivar organization: Required.
    :vartype organization: ~affinda.models.Organization
    :ivar extractor: Required. Uniquely identify an extractor.
    :vartype extractor: str
    :ivar multiple:
    :vartype multiple: bool
    :ivar no_rect:
    :vartype no_rect: bool
    :ivar parent: The identifier of the parent data point if applicable.
    :vartype parent: str
    :ivar children:
    :vartype children: list[~affinda.models.DataPoint]
    :ivar available_data_sources:
    :vartype available_data_sources: list[~affinda.models.MappingDataSource]
    :ivar mapping_data_source: If populated, the model will learn to predict this field using the
     data source, rather than relying on fuzzy string matching.
    :vartype mapping_data_source: str
    :ivar manual_entry: If true, the model will not be used to predict this data point. Instead,
     the user will be able to manually enter the value in the validation tool.
    :vartype manual_entry: bool
    """

    _validation = {
        "identifier": {"required": True},
        "name": {"required": True},
        "slug": {"required": True},
        "annotation_content_type": {"required": True},
        "organization": {"required": True},
        "extractor": {"required": True},
    }

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "slug": {"key": "slug", "type": "str"},
        "description": {"key": "description", "type": "str"},
        "annotation_content_type": {"key": "annotationContentType", "type": "str"},
        "organization": {"key": "organization", "type": "Organization"},
        "extractor": {"key": "extractor", "type": "str"},
        "multiple": {"key": "multiple", "type": "bool"},
        "no_rect": {"key": "noRect", "type": "bool"},
        "parent": {"key": "parent", "type": "str"},
        "children": {"key": "children", "type": "[DataPoint]"},
        "available_data_sources": {"key": "availableDataSources", "type": "[MappingDataSource]"},
        "mapping_data_source": {"key": "mappingDataSource", "type": "str"},
        "manual_entry": {"key": "manualEntry", "type": "bool"},
    }

    def __init__(self, **kwargs):
        """
        :keyword identifier: Required. Uniquely identify a data point.
        :paramtype identifier: str
        :keyword name: Required. Name of the data point.
        :paramtype name: str
        :keyword slug: Required. A camelCase string that will be used as the key in the API response.
        :paramtype slug: str
        :keyword description:
        :paramtype description: str
        :keyword annotation_content_type: Required. The different data types of annotations. Known
         values are: "text", "integer", "float", "decimal", "date", "datetime", "daterange", "boolean",
         "enum", "location", "phonenumber", "json", "table", "expectedremuneration", "jobtitle",
         "language", "skill", "yearsexperience", "group", "table_deprecated", "url", "image".
        :paramtype annotation_content_type: str or ~affinda.models.AnnotationContentType
        :keyword organization: Required.
        :paramtype organization: ~affinda.models.Organization
        :keyword extractor: Required. Uniquely identify an extractor.
        :paramtype extractor: str
        :keyword multiple:
        :paramtype multiple: bool
        :keyword no_rect:
        :paramtype no_rect: bool
        :keyword parent: The identifier of the parent data point if applicable.
        :paramtype parent: str
        :keyword children:
        :paramtype children: list[~affinda.models.DataPoint]
        :keyword available_data_sources:
        :paramtype available_data_sources: list[~affinda.models.MappingDataSource]
        :keyword mapping_data_source: If populated, the model will learn to predict this field using
         the data source, rather than relying on fuzzy string matching.
        :paramtype mapping_data_source: str
        :keyword manual_entry: If true, the model will not be used to predict this data point. Instead,
         the user will be able to manually enter the value in the validation tool.
        :paramtype manual_entry: bool
        """
        super(DataPoint, self).__init__(**kwargs)
        self.identifier = kwargs["identifier"]
        self.name = kwargs["name"]
        self.slug = kwargs["slug"]
        self.description = kwargs.get("description", None)
        self.annotation_content_type = kwargs["annotation_content_type"]
        self.organization = kwargs["organization"]
        self.extractor = kwargs["extractor"]
        self.multiple = kwargs.get("multiple", None)
        self.no_rect = kwargs.get("no_rect", None)
        self.parent = kwargs.get("parent", None)
        self.children = kwargs.get("children", None)
        self.available_data_sources = kwargs.get("available_data_sources", None)
        self.mapping_data_source = kwargs.get("mapping_data_source", None)
        self.manual_entry = kwargs.get("manual_entry", None)


class DataPointChoice(msrest.serialization.Model):
    """DataPointChoice.

    All required parameters must be populated in order to send to Azure.

    :ivar id: Required. Data point choice's ID.
    :vartype id: int
    :ivar label: Required.
    :vartype label: str
    :ivar value: Required.
    :vartype value: str
    :ivar synonyms:
    :vartype synonyms: list[str]
    :ivar description:
    :vartype description: str
    """

    _validation = {
        "id": {"required": True, "minimum": 1},
        "label": {"required": True},
        "value": {"required": True},
    }

    _attribute_map = {
        "id": {"key": "id", "type": "int"},
        "label": {"key": "label", "type": "str"},
        "value": {"key": "value", "type": "str"},
        "synonyms": {"key": "synonyms", "type": "[str]"},
        "description": {"key": "description", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword id: Required. Data point choice's ID.
        :paramtype id: int
        :keyword label: Required.
        :paramtype label: str
        :keyword value: Required.
        :paramtype value: str
        :keyword synonyms:
        :paramtype synonyms: list[str]
        :keyword description:
        :paramtype description: str
        """
        super(DataPointChoice, self).__init__(**kwargs)
        self.id = kwargs["id"]
        self.label = kwargs["label"]
        self.value = kwargs["value"]
        self.synonyms = kwargs.get("synonyms", None)
        self.description = kwargs.get("description", None)


class DataPointChoiceCreate(msrest.serialization.Model):
    """DataPointChoiceCreate.

    All required parameters must be populated in order to send to Azure.

    :ivar data_point: Required. Uniquely identify a data point.
    :vartype data_point: str
    :ivar organization: Uniquely identify an organization.
    :vartype organization: str
    :ivar collection: Uniquely identify a collection.
    :vartype collection: str
    :ivar label: Required.
    :vartype label: str
    :ivar value: Required.
    :vartype value: str
    :ivar synonyms:
    :vartype synonyms: list[str]
    :ivar description:
    :vartype description: str
    """

    _validation = {
        "data_point": {"required": True},
        "label": {"required": True},
        "value": {"required": True},
    }

    _attribute_map = {
        "data_point": {"key": "dataPoint", "type": "str"},
        "organization": {"key": "organization", "type": "str"},
        "collection": {"key": "collection", "type": "str"},
        "label": {"key": "label", "type": "str"},
        "value": {"key": "value", "type": "str"},
        "synonyms": {"key": "synonyms", "type": "[str]"},
        "description": {"key": "description", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword data_point: Required. Uniquely identify a data point.
        :paramtype data_point: str
        :keyword organization: Uniquely identify an organization.
        :paramtype organization: str
        :keyword collection: Uniquely identify a collection.
        :paramtype collection: str
        :keyword label: Required.
        :paramtype label: str
        :keyword value: Required.
        :paramtype value: str
        :keyword synonyms:
        :paramtype synonyms: list[str]
        :keyword description:
        :paramtype description: str
        """
        super(DataPointChoiceCreate, self).__init__(**kwargs)
        self.data_point = kwargs["data_point"]
        self.organization = kwargs.get("organization", None)
        self.collection = kwargs.get("collection", None)
        self.label = kwargs["label"]
        self.value = kwargs["value"]
        self.synonyms = kwargs.get("synonyms", None)
        self.description = kwargs.get("description", None)


class DataPointChoiceForReplace(msrest.serialization.Model):
    """DataPointChoiceForReplace.

    All required parameters must be populated in order to send to Azure.

    :ivar value: Required.
    :vartype value: str
    :ivar label:
    :vartype label: str
    :ivar synonyms:
    :vartype synonyms: list[str]
    :ivar description:
    :vartype description: str
    """

    _validation = {
        "value": {"required": True},
    }

    _attribute_map = {
        "value": {"key": "value", "type": "str"},
        "label": {"key": "label", "type": "str"},
        "synonyms": {"key": "synonyms", "type": "[str]"},
        "description": {"key": "description", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword value: Required.
        :paramtype value: str
        :keyword label:
        :paramtype label: str
        :keyword synonyms:
        :paramtype synonyms: list[str]
        :keyword description:
        :paramtype description: str
        """
        super(DataPointChoiceForReplace, self).__init__(**kwargs)
        self.value = kwargs["value"]
        self.label = kwargs.get("label", None)
        self.synonyms = kwargs.get("synonyms", None)
        self.description = kwargs.get("description", None)


class DataPointChoiceReplaceRequest(msrest.serialization.Model):
    """Request body for replacing choices of a data point. Either ``collection`` or ``organization`` is required.

    All required parameters must be populated in order to send to Azure.

    :ivar data_point: Required. Uniquely identify a data point.
    :vartype data_point: str
    :ivar collection: Uniquely identify a collection.
    :vartype collection: str
    :ivar organization: Uniquely identify an organization.
    :vartype organization: str
    :ivar choices: Required. Incoming choices to replace existing choices of a data point. Existing
     choices and incoming choices are matched base on their ``value``. New ``value`` will be
     created, existing ``value`` will be updated, and ``value`` not in incoming choices will be
     deleted.
    :vartype choices: list[~affinda.models.DataPointChoiceForReplace]
    """

    _validation = {
        "data_point": {"required": True},
        "choices": {"required": True},
    }

    _attribute_map = {
        "data_point": {"key": "dataPoint", "type": "str"},
        "collection": {"key": "collection", "type": "str"},
        "organization": {"key": "organization", "type": "str"},
        "choices": {"key": "choices", "type": "[DataPointChoiceForReplace]"},
    }

    def __init__(self, **kwargs):
        """
        :keyword data_point: Required. Uniquely identify a data point.
        :paramtype data_point: str
        :keyword collection: Uniquely identify a collection.
        :paramtype collection: str
        :keyword organization: Uniquely identify an organization.
        :paramtype organization: str
        :keyword choices: Required. Incoming choices to replace existing choices of a data point.
         Existing choices and incoming choices are matched base on their ``value``. New ``value`` will
         be created, existing ``value`` will be updated, and ``value`` not in incoming choices will be
         deleted.
        :paramtype choices: list[~affinda.models.DataPointChoiceForReplace]
        """
        super(DataPointChoiceReplaceRequest, self).__init__(**kwargs)
        self.data_point = kwargs["data_point"]
        self.collection = kwargs.get("collection", None)
        self.organization = kwargs.get("organization", None)
        self.choices = kwargs["choices"]


class DataPointChoiceReplaceResponse(msrest.serialization.Model):
    """DataPointChoiceReplaceResponse.

    All required parameters must be populated in order to send to Azure.

    :ivar data_point: Required. Uniquely identify a data point.
    :vartype data_point: str
    :ivar collection: Required. Uniquely identify a collection.
    :vartype collection: str
    :ivar organization: Required. Uniquely identify an organization.
    :vartype organization: str
    :ivar choices: Required.
    :vartype choices: list[~affinda.models.DataPointChoiceReplaceResponseChoicesItem]
    """

    _validation = {
        "data_point": {"required": True},
        "collection": {"required": True},
        "organization": {"required": True},
        "choices": {"required": True},
    }

    _attribute_map = {
        "data_point": {"key": "dataPoint", "type": "str"},
        "collection": {"key": "collection", "type": "str"},
        "organization": {"key": "organization", "type": "str"},
        "choices": {"key": "choices", "type": "[DataPointChoiceReplaceResponseChoicesItem]"},
    }

    def __init__(self, **kwargs):
        """
        :keyword data_point: Required. Uniquely identify a data point.
        :paramtype data_point: str
        :keyword collection: Required. Uniquely identify a collection.
        :paramtype collection: str
        :keyword organization: Required. Uniquely identify an organization.
        :paramtype organization: str
        :keyword choices: Required.
        :paramtype choices: list[~affinda.models.DataPointChoiceReplaceResponseChoicesItem]
        """
        super(DataPointChoiceReplaceResponse, self).__init__(**kwargs)
        self.data_point = kwargs["data_point"]
        self.collection = kwargs["collection"]
        self.organization = kwargs["organization"]
        self.choices = kwargs["choices"]


class DataPointChoiceReplaceResponseChoicesItem(msrest.serialization.Model):
    """DataPointChoiceReplaceResponseChoicesItem.

    All required parameters must be populated in order to send to Azure.

    :ivar id: Required. Data point choice's ID.
    :vartype id: int
    :ivar value: Required.
    :vartype value: str
    :ivar label: Required.
    :vartype label: str
    :ivar synonyms: Required.
    :vartype synonyms: list[str]
    :ivar description: Required.
    :vartype description: str
    """

    _validation = {
        "id": {"required": True, "minimum": 1},
        "value": {"required": True},
        "label": {"required": True},
        "synonyms": {"required": True},
        "description": {"required": True},
    }

    _attribute_map = {
        "id": {"key": "id", "type": "int"},
        "value": {"key": "value", "type": "str"},
        "label": {"key": "label", "type": "str"},
        "synonyms": {"key": "synonyms", "type": "[str]"},
        "description": {"key": "description", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword id: Required. Data point choice's ID.
        :paramtype id: int
        :keyword value: Required.
        :paramtype value: str
        :keyword label: Required.
        :paramtype label: str
        :keyword synonyms: Required.
        :paramtype synonyms: list[str]
        :keyword description: Required.
        :paramtype description: str
        """
        super(DataPointChoiceReplaceResponseChoicesItem, self).__init__(**kwargs)
        self.id = kwargs["id"]
        self.value = kwargs["value"]
        self.label = kwargs["label"]
        self.synonyms = kwargs["synonyms"]
        self.description = kwargs["description"]


class DataPointChoiceUpdate(msrest.serialization.Model):
    """DataPointChoiceUpdate.

    :ivar data_point: Uniquely identify a data point.
    :vartype data_point: str
    :ivar organization: Uniquely identify an organization.
    :vartype organization: str
    :ivar collection: Uniquely identify a collection.
    :vartype collection: str
    :ivar label:
    :vartype label: str
    :ivar value:
    :vartype value: str
    :ivar synonyms:
    :vartype synonyms: list[str]
    :ivar description:
    :vartype description: str
    """

    _attribute_map = {
        "data_point": {"key": "dataPoint", "type": "str"},
        "organization": {"key": "organization", "type": "str"},
        "collection": {"key": "collection", "type": "str"},
        "label": {"key": "label", "type": "str"},
        "value": {"key": "value", "type": "str"},
        "synonyms": {"key": "synonyms", "type": "[str]"},
        "description": {"key": "description", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword data_point: Uniquely identify a data point.
        :paramtype data_point: str
        :keyword organization: Uniquely identify an organization.
        :paramtype organization: str
        :keyword collection: Uniquely identify a collection.
        :paramtype collection: str
        :keyword label:
        :paramtype label: str
        :keyword value:
        :paramtype value: str
        :keyword synonyms:
        :paramtype synonyms: list[str]
        :keyword description:
        :paramtype description: str
        """
        super(DataPointChoiceUpdate, self).__init__(**kwargs)
        self.data_point = kwargs.get("data_point", None)
        self.organization = kwargs.get("organization", None)
        self.collection = kwargs.get("collection", None)
        self.label = kwargs.get("label", None)
        self.value = kwargs.get("value", None)
        self.synonyms = kwargs.get("synonyms", None)
        self.description = kwargs.get("description", None)


class DataPointCreate(msrest.serialization.Model):
    """DataPointCreate.

    All required parameters must be populated in order to send to Azure.

    :ivar name: Required. Name of the data point.
    :vartype name: str
    :ivar slug: Required. A camelCase string that will be used as the key in the API response.
    :vartype slug: str
    :ivar description:
    :vartype description: str
    :ivar annotation_content_type: Required. The different data types of annotations. Known values
     are: "text", "integer", "float", "decimal", "date", "datetime", "daterange", "boolean", "enum",
     "location", "phonenumber", "json", "table", "expectedremuneration", "jobtitle", "language",
     "skill", "yearsexperience", "group", "table_deprecated", "url", "image".
    :vartype annotation_content_type: str or ~affinda.models.AnnotationContentType
    :ivar organization: Required. Uniquely identify an organization.
    :vartype organization: str
    :ivar extractor: Required. Uniquely identify an extractor.
    :vartype extractor: str
    :ivar multiple:
    :vartype multiple: bool
    :ivar no_rect:
    :vartype no_rect: bool
    :ivar parent: The identifier of the parent data point if applicable.
    :vartype parent: str
    :ivar manual_entry: If true, the model will not be used to predict this data point. Instead,
     the user will be able to manually enter the value in the validation tool.
    :vartype manual_entry: bool
    :ivar mapping_data_source: If populated, the model will learn to predict this field using the
     data source, rather than relying on fuzzy string matching.
    :vartype mapping_data_source: str
    """

    _validation = {
        "name": {"required": True},
        "slug": {"required": True},
        "annotation_content_type": {"required": True},
        "organization": {"required": True},
        "extractor": {"required": True},
    }

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "slug": {"key": "slug", "type": "str"},
        "description": {"key": "description", "type": "str"},
        "annotation_content_type": {"key": "annotationContentType", "type": "str"},
        "organization": {"key": "organization", "type": "str"},
        "extractor": {"key": "extractor", "type": "str"},
        "multiple": {"key": "multiple", "type": "bool"},
        "no_rect": {"key": "noRect", "type": "bool"},
        "parent": {"key": "parent", "type": "str"},
        "manual_entry": {"key": "manualEntry", "type": "bool"},
        "mapping_data_source": {"key": "mappingDataSource", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword name: Required. Name of the data point.
        :paramtype name: str
        :keyword slug: Required. A camelCase string that will be used as the key in the API response.
        :paramtype slug: str
        :keyword description:
        :paramtype description: str
        :keyword annotation_content_type: Required. The different data types of annotations. Known
         values are: "text", "integer", "float", "decimal", "date", "datetime", "daterange", "boolean",
         "enum", "location", "phonenumber", "json", "table", "expectedremuneration", "jobtitle",
         "language", "skill", "yearsexperience", "group", "table_deprecated", "url", "image".
        :paramtype annotation_content_type: str or ~affinda.models.AnnotationContentType
        :keyword organization: Required. Uniquely identify an organization.
        :paramtype organization: str
        :keyword extractor: Required. Uniquely identify an extractor.
        :paramtype extractor: str
        :keyword multiple:
        :paramtype multiple: bool
        :keyword no_rect:
        :paramtype no_rect: bool
        :keyword parent: The identifier of the parent data point if applicable.
        :paramtype parent: str
        :keyword manual_entry: If true, the model will not be used to predict this data point. Instead,
         the user will be able to manually enter the value in the validation tool.
        :paramtype manual_entry: bool
        :keyword mapping_data_source: If populated, the model will learn to predict this field using
         the data source, rather than relying on fuzzy string matching.
        :paramtype mapping_data_source: str
        """
        super(DataPointCreate, self).__init__(**kwargs)
        self.name = kwargs["name"]
        self.slug = kwargs["slug"]
        self.description = kwargs.get("description", None)
        self.annotation_content_type = kwargs["annotation_content_type"]
        self.organization = kwargs["organization"]
        self.extractor = kwargs["extractor"]
        self.multiple = kwargs.get("multiple", None)
        self.no_rect = kwargs.get("no_rect", None)
        self.parent = kwargs.get("parent", None)
        self.manual_entry = kwargs.get("manual_entry", None)
        self.mapping_data_source = kwargs.get("mapping_data_source", None)


class DataPointUpdate(msrest.serialization.Model):
    """DataPointUpdate.

    :ivar name: Name of the data point.
    :vartype name: str
    :ivar slug: A camelCase string that will be used as the key in the API response.
    :vartype slug: str
    :ivar description:
    :vartype description: str
    :ivar parent: The identifier of the parent data point if applicable.
    :vartype parent: str
    :ivar mapping_data_source: If populated, the model will learn to predict this field using the
     data source, rather than relying on fuzzy string matching.
    :vartype mapping_data_source: str
    """

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "slug": {"key": "slug", "type": "str"},
        "description": {"key": "description", "type": "str"},
        "parent": {"key": "parent", "type": "str"},
        "mapping_data_source": {"key": "mappingDataSource", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword name: Name of the data point.
        :paramtype name: str
        :keyword slug: A camelCase string that will be used as the key in the API response.
        :paramtype slug: str
        :keyword description:
        :paramtype description: str
        :keyword parent: The identifier of the parent data point if applicable.
        :paramtype parent: str
        :keyword mapping_data_source: If populated, the model will learn to predict this field using
         the data source, rather than relying on fuzzy string matching.
        :paramtype mapping_data_source: str
        """
        super(DataPointUpdate, self).__init__(**kwargs)
        self.name = kwargs.get("name", None)
        self.slug = kwargs.get("slug", None)
        self.description = kwargs.get("description", None)
        self.parent = kwargs.get("parent", None)
        self.mapping_data_source = kwargs.get("mapping_data_source", None)


class DateAnnotation(Annotation):
    """DateAnnotation.

    All required parameters must be populated in order to send to Azure.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id: Required. Annotation's ID.
    :vartype id: int
    :ivar rectangle: Required. x/y coordinates for the rectangular bounding box containing the
     data.
    :vartype rectangle: ~affinda.models.Rectangle
    :ivar rectangles: Required. x/y coordinates for the rectangles containing the data. An
     annotation can be contained within multiple rectangles.
    :vartype rectangles: list[~affinda.models.Rectangle]
    :ivar document: Required. Unique identifier for the document.
    :vartype document: str
    :ivar page_index: Required. The page number within the document, starting from 0.
    :vartype page_index: int
    :ivar raw: Required. Raw data extracted from the before any post-processing.
    :vartype raw: str
    :ivar confidence: Required. The overall confidence that the model's prediction is correct.
    :vartype confidence: float
    :ivar classification_confidence: Required. The model's confidence that the text has been
     classified correctly.
    :vartype classification_confidence: float
    :ivar text_extraction_confidence: Required. If the document was submitted as an image, this is
     the confidence that the text in the image has been correctly read by the model.
    :vartype text_extraction_confidence: float
    :ivar is_verified: Required. Indicates whether the data has been validated, either by a human
     using our validation tool or through auto-validation rules.
    :vartype is_verified: bool
    :ivar is_client_verified: Required. Indicates whether the data has been validated by a human.
    :vartype is_client_verified: bool
    :ivar is_auto_verified: Required. Indicates whether the data has been auto-validated.
    :vartype is_auto_verified: bool
    :ivar data_point: Required. Data point's identifier.
    :vartype data_point: str
    :ivar content_type: Required. The different data types of annotations. Known values are:
     "text", "integer", "float", "decimal", "date", "datetime", "daterange", "boolean", "enum",
     "location", "phonenumber", "json", "table", "expectedremuneration", "jobtitle", "language",
     "skill", "yearsexperience", "group", "table_deprecated", "url", "image".
    :vartype content_type: str or ~affinda.models.AnnotationContentType
    :ivar parent: The parent annotation's ID.
    :vartype parent: int
    :ivar parsed:
    :vartype parsed: ~datetime.date
    """

    _validation = {
        "id": {"required": True, "minimum": 1},
        "rectangle": {"required": True},
        "rectangles": {"required": True},
        "document": {"required": True},
        "page_index": {"required": True, "minimum": 0},
        "raw": {"required": True},
        "confidence": {"required": True},
        "classification_confidence": {"required": True},
        "text_extraction_confidence": {"required": True},
        "is_verified": {"required": True},
        "is_client_verified": {"required": True},
        "is_auto_verified": {"required": True},
        "data_point": {"required": True},
        "content_type": {"required": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "int"},
        "rectangle": {"key": "rectangle", "type": "Rectangle"},
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "document": {"key": "document", "type": "str"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "confidence": {"key": "confidence", "type": "float"},
        "classification_confidence": {"key": "classificationConfidence", "type": "float"},
        "text_extraction_confidence": {"key": "textExtractionConfidence", "type": "float"},
        "is_verified": {"key": "isVerified", "type": "bool"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "is_auto_verified": {"key": "isAutoVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "content_type": {"key": "contentType", "type": "str"},
        "parent": {"key": "parent", "type": "int"},
        "parsed": {"key": "parsed", "type": "date"},
    }

    def __init__(self, **kwargs):
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword id: Required. Annotation's ID.
        :paramtype id: int
        :keyword rectangle: Required. x/y coordinates for the rectangular bounding box containing the
         data.
        :paramtype rectangle: ~affinda.models.Rectangle
        :keyword rectangles: Required. x/y coordinates for the rectangles containing the data. An
         annotation can be contained within multiple rectangles.
        :paramtype rectangles: list[~affinda.models.Rectangle]
        :keyword document: Required. Unique identifier for the document.
        :paramtype document: str
        :keyword page_index: Required. The page number within the document, starting from 0.
        :paramtype page_index: int
        :keyword raw: Required. Raw data extracted from the before any post-processing.
        :paramtype raw: str
        :keyword confidence: Required. The overall confidence that the model's prediction is correct.
        :paramtype confidence: float
        :keyword classification_confidence: Required. The model's confidence that the text has been
         classified correctly.
        :paramtype classification_confidence: float
        :keyword text_extraction_confidence: Required. If the document was submitted as an image, this
         is the confidence that the text in the image has been correctly read by the model.
        :paramtype text_extraction_confidence: float
        :keyword is_verified: Required. Indicates whether the data has been validated, either by a
         human using our validation tool or through auto-validation rules.
        :paramtype is_verified: bool
        :keyword is_client_verified: Required. Indicates whether the data has been validated by a
         human.
        :paramtype is_client_verified: bool
        :keyword is_auto_verified: Required. Indicates whether the data has been auto-validated.
        :paramtype is_auto_verified: bool
        :keyword data_point: Required. Data point's identifier.
        :paramtype data_point: str
        :keyword content_type: Required. The different data types of annotations. Known values are:
         "text", "integer", "float", "decimal", "date", "datetime", "daterange", "boolean", "enum",
         "location", "phonenumber", "json", "table", "expectedremuneration", "jobtitle", "language",
         "skill", "yearsexperience", "group", "table_deprecated", "url", "image".
        :paramtype content_type: str or ~affinda.models.AnnotationContentType
        :keyword parent: The parent annotation's ID.
        :paramtype parent: int
        :keyword parsed:
        :paramtype parsed: ~datetime.date
        """
        super(DateAnnotation, self).__init__(**kwargs)
        self.parsed = kwargs.get("parsed", None)


class DateAnnotationUpdate(AnnotationBase):
    """DateAnnotationUpdate.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id:
    :vartype id: int
    :ivar rectangle:
    :vartype rectangle: ~affinda.models.Rectangle
    :ivar rectangles:
    :vartype rectangles: list[~affinda.models.Rectangle]
    :ivar page_index:
    :vartype page_index: int
    :ivar raw:
    :vartype raw: str
    :ivar confidence: The overall confidence that the model's prediction is correct.
    :vartype confidence: float
    :ivar classification_confidence: The model's confidence that the text has been classified
     correctly.
    :vartype classification_confidence: float
    :ivar text_extraction_confidence: If the document was submitted as an image, this is the
     confidence that the text in the image has been correctly read by the model.
    :vartype text_extraction_confidence: float
    :ivar is_verified:
    :vartype is_verified: bool
    :ivar is_client_verified:
    :vartype is_client_verified: bool
    :ivar is_auto_verified:
    :vartype is_auto_verified: bool
    :ivar data_point:
    :vartype data_point: str
    :ivar content_type:
    :vartype content_type: str
    :ivar parsed:
    :vartype parsed: ~datetime.date
    """

    _validation = {
        "rectangles": {"readonly": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "int"},
        "rectangle": {"key": "rectangle", "type": "Rectangle"},
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "confidence": {"key": "confidence", "type": "float"},
        "classification_confidence": {"key": "classificationConfidence", "type": "float"},
        "text_extraction_confidence": {"key": "textExtractionConfidence", "type": "float"},
        "is_verified": {"key": "isVerified", "type": "bool"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "is_auto_verified": {"key": "isAutoVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "content_type": {"key": "contentType", "type": "str"},
        "parsed": {"key": "parsed", "type": "date"},
    }

    def __init__(self, **kwargs):
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword id:
        :paramtype id: int
        :keyword rectangle:
        :paramtype rectangle: ~affinda.models.Rectangle
        :keyword page_index:
        :paramtype page_index: int
        :keyword raw:
        :paramtype raw: str
        :keyword confidence: The overall confidence that the model's prediction is correct.
        :paramtype confidence: float
        :keyword classification_confidence: The model's confidence that the text has been classified
         correctly.
        :paramtype classification_confidence: float
        :keyword text_extraction_confidence: If the document was submitted as an image, this is the
         confidence that the text in the image has been correctly read by the model.
        :paramtype text_extraction_confidence: float
        :keyword is_verified:
        :paramtype is_verified: bool
        :keyword is_client_verified:
        :paramtype is_client_verified: bool
        :keyword is_auto_verified:
        :paramtype is_auto_verified: bool
        :keyword data_point:
        :paramtype data_point: str
        :keyword content_type:
        :paramtype content_type: str
        :keyword parsed:
        :paramtype parsed: ~datetime.date
        """
        super(DateAnnotationUpdate, self).__init__(**kwargs)
        self.parsed = kwargs.get("parsed", None)


class DateRangeAnnotation(Annotation):
    """DateRangeAnnotation.

    All required parameters must be populated in order to send to Azure.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id: Required. Annotation's ID.
    :vartype id: int
    :ivar rectangle: Required. x/y coordinates for the rectangular bounding box containing the
     data.
    :vartype rectangle: ~affinda.models.Rectangle
    :ivar rectangles: Required. x/y coordinates for the rectangles containing the data. An
     annotation can be contained within multiple rectangles.
    :vartype rectangles: list[~affinda.models.Rectangle]
    :ivar document: Required. Unique identifier for the document.
    :vartype document: str
    :ivar page_index: Required. The page number within the document, starting from 0.
    :vartype page_index: int
    :ivar raw: Required. Raw data extracted from the before any post-processing.
    :vartype raw: str
    :ivar confidence: Required. The overall confidence that the model's prediction is correct.
    :vartype confidence: float
    :ivar classification_confidence: Required. The model's confidence that the text has been
     classified correctly.
    :vartype classification_confidence: float
    :ivar text_extraction_confidence: Required. If the document was submitted as an image, this is
     the confidence that the text in the image has been correctly read by the model.
    :vartype text_extraction_confidence: float
    :ivar is_verified: Required. Indicates whether the data has been validated, either by a human
     using our validation tool or through auto-validation rules.
    :vartype is_verified: bool
    :ivar is_client_verified: Required. Indicates whether the data has been validated by a human.
    :vartype is_client_verified: bool
    :ivar is_auto_verified: Required. Indicates whether the data has been auto-validated.
    :vartype is_auto_verified: bool
    :ivar data_point: Required. Data point's identifier.
    :vartype data_point: str
    :ivar content_type: Required. The different data types of annotations. Known values are:
     "text", "integer", "float", "decimal", "date", "datetime", "daterange", "boolean", "enum",
     "location", "phonenumber", "json", "table", "expectedremuneration", "jobtitle", "language",
     "skill", "yearsexperience", "group", "table_deprecated", "url", "image".
    :vartype content_type: str or ~affinda.models.AnnotationContentType
    :ivar parent: The parent annotation's ID.
    :vartype parent: int
    :ivar parsed:
    :vartype parsed: ~affinda.models.DateRangeAnnotationParsed
    """

    _validation = {
        "id": {"required": True, "minimum": 1},
        "rectangle": {"required": True},
        "rectangles": {"required": True},
        "document": {"required": True},
        "page_index": {"required": True, "minimum": 0},
        "raw": {"required": True},
        "confidence": {"required": True},
        "classification_confidence": {"required": True},
        "text_extraction_confidence": {"required": True},
        "is_verified": {"required": True},
        "is_client_verified": {"required": True},
        "is_auto_verified": {"required": True},
        "data_point": {"required": True},
        "content_type": {"required": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "int"},
        "rectangle": {"key": "rectangle", "type": "Rectangle"},
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "document": {"key": "document", "type": "str"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "confidence": {"key": "confidence", "type": "float"},
        "classification_confidence": {"key": "classificationConfidence", "type": "float"},
        "text_extraction_confidence": {"key": "textExtractionConfidence", "type": "float"},
        "is_verified": {"key": "isVerified", "type": "bool"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "is_auto_verified": {"key": "isAutoVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "content_type": {"key": "contentType", "type": "str"},
        "parent": {"key": "parent", "type": "int"},
        "parsed": {"key": "parsed", "type": "DateRangeAnnotationParsed"},
    }

    def __init__(self, **kwargs):
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword id: Required. Annotation's ID.
        :paramtype id: int
        :keyword rectangle: Required. x/y coordinates for the rectangular bounding box containing the
         data.
        :paramtype rectangle: ~affinda.models.Rectangle
        :keyword rectangles: Required. x/y coordinates for the rectangles containing the data. An
         annotation can be contained within multiple rectangles.
        :paramtype rectangles: list[~affinda.models.Rectangle]
        :keyword document: Required. Unique identifier for the document.
        :paramtype document: str
        :keyword page_index: Required. The page number within the document, starting from 0.
        :paramtype page_index: int
        :keyword raw: Required. Raw data extracted from the before any post-processing.
        :paramtype raw: str
        :keyword confidence: Required. The overall confidence that the model's prediction is correct.
        :paramtype confidence: float
        :keyword classification_confidence: Required. The model's confidence that the text has been
         classified correctly.
        :paramtype classification_confidence: float
        :keyword text_extraction_confidence: Required. If the document was submitted as an image, this
         is the confidence that the text in the image has been correctly read by the model.
        :paramtype text_extraction_confidence: float
        :keyword is_verified: Required. Indicates whether the data has been validated, either by a
         human using our validation tool or through auto-validation rules.
        :paramtype is_verified: bool
        :keyword is_client_verified: Required. Indicates whether the data has been validated by a
         human.
        :paramtype is_client_verified: bool
        :keyword is_auto_verified: Required. Indicates whether the data has been auto-validated.
        :paramtype is_auto_verified: bool
        :keyword data_point: Required. Data point's identifier.
        :paramtype data_point: str
        :keyword content_type: Required. The different data types of annotations. Known values are:
         "text", "integer", "float", "decimal", "date", "datetime", "daterange", "boolean", "enum",
         "location", "phonenumber", "json", "table", "expectedremuneration", "jobtitle", "language",
         "skill", "yearsexperience", "group", "table_deprecated", "url", "image".
        :paramtype content_type: str or ~affinda.models.AnnotationContentType
        :keyword parent: The parent annotation's ID.
        :paramtype parent: int
        :keyword parsed:
        :paramtype parsed: ~affinda.models.DateRangeAnnotationParsed
        """
        super(DateRangeAnnotation, self).__init__(**kwargs)
        self.parsed = kwargs.get("parsed", None)


class DateRangeAnnotationParsed(msrest.serialization.Model):
    """DateRangeAnnotationParsed.

    :ivar start:
    :vartype start: ~affinda.models.DateRangeValue
    :ivar end:
    :vartype end: ~affinda.models.DateRangeValue
    """

    _attribute_map = {
        "start": {"key": "start", "type": "DateRangeValue"},
        "end": {"key": "end", "type": "DateRangeValue"},
    }

    def __init__(self, **kwargs):
        """
        :keyword start:
        :paramtype start: ~affinda.models.DateRangeValue
        :keyword end:
        :paramtype end: ~affinda.models.DateRangeValue
        """
        super(DateRangeAnnotationParsed, self).__init__(**kwargs)
        self.start = kwargs.get("start", None)
        self.end = kwargs.get("end", None)


class DateRangeValue(msrest.serialization.Model):
    """DateRangeValue.

    :ivar date:
    :vartype date: ~datetime.date
    :ivar is_current:
    :vartype is_current: bool
    :ivar day:
    :vartype day: int
    :ivar month:
    :vartype month: int
    :ivar year:
    :vartype year: int
    """

    _attribute_map = {
        "date": {"key": "date", "type": "date"},
        "is_current": {"key": "isCurrent", "type": "bool"},
        "day": {"key": "day", "type": "int"},
        "month": {"key": "month", "type": "int"},
        "year": {"key": "year", "type": "int"},
    }

    def __init__(self, **kwargs):
        """
        :keyword date:
        :paramtype date: ~datetime.date
        :keyword is_current:
        :paramtype is_current: bool
        :keyword day:
        :paramtype day: int
        :keyword month:
        :paramtype month: int
        :keyword year:
        :paramtype year: int
        """
        super(DateRangeValue, self).__init__(**kwargs)
        self.date = kwargs.get("date", None)
        self.is_current = kwargs.get("is_current", None)
        self.day = kwargs.get("day", None)
        self.month = kwargs.get("month", None)
        self.year = kwargs.get("year", None)


class Document(msrest.serialization.Model):
    """Document.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: Invoice, JobDescription, Resume, ResumeRedact.

    All required parameters must be populated in order to send to Azure.

    :ivar data: Any object.
    :vartype data: any
    :ivar extractor: Required. Constant filled by server.
    :vartype extractor: str
    :ivar meta: Required.
    :vartype meta: ~affinda.models.DocumentMeta
    :ivar error:
    :vartype error: ~affinda.models.DocumentError
    :ivar warnings:
    :vartype warnings: list[~affinda.models.DocumentWarning]
    """

    _validation = {
        "extractor": {"required": True},
        "meta": {"required": True},
    }

    _attribute_map = {
        "data": {"key": "data", "type": "object"},
        "extractor": {"key": "extractor", "type": "str"},
        "meta": {"key": "meta", "type": "DocumentMeta"},
        "error": {"key": "error", "type": "DocumentError"},
        "warnings": {"key": "warnings", "type": "[DocumentWarning]"},
    }

    _subtype_map = {
        "extractor": {
            "invoice": "Invoice",
            "job-description": "JobDescription",
            "resume": "Resume",
            "resume-redact": "ResumeRedact",
        }
    }

    def __init__(self, **kwargs):
        """
        :keyword data: Any object.
        :paramtype data: any
        :keyword meta: Required.
        :paramtype meta: ~affinda.models.DocumentMeta
        :keyword error:
        :paramtype error: ~affinda.models.DocumentError
        :keyword warnings:
        :paramtype warnings: list[~affinda.models.DocumentWarning]
        """
        super(Document, self).__init__(**kwargs)
        self.data = kwargs.get("data", None)
        self.extractor = None  # type: Optional[str]
        self.meta = kwargs["meta"]
        self.error = kwargs.get("error", None)
        self.warnings = kwargs.get("warnings", None)


class DocumentCreate(msrest.serialization.Model):
    """DocumentCreate.

    :ivar file: File as binary data blob. Supported formats: PDF, DOC, DOCX, TXT, RTF, HTML, PNG,
     JPG, TIFF, ODT, XLS, XLSX, ZIP.
    :vartype file: IO
    :ivar url: URL to download the document.
    :vartype url: str
    :ivar data: Create resume or job description directly from data.
    :vartype data: any
    :ivar collection: Uniquely identify a collection.
    :vartype collection: str
    :ivar workspace: Uniquely identify a workspace.
    :vartype workspace: str
    :ivar wait: If "true" (default), will return a response only after processing has completed. If
     "false", will return an empty data object which can be polled at the GET endpoint until
     processing is complete.
    :vartype wait: bool
    :ivar identifier: Deprecated in favor of ``customIdentifier``.
    :vartype identifier: str
    :ivar custom_identifier: Specify a custom identifier for the document if you need one, not
     required to be unique.
    :vartype custom_identifier: str
    :ivar file_name: Optional filename of the file.
    :vartype file_name: str
    :ivar expiry_time: The date/time in ISO-8601 format when the document will be automatically
     deleted.  Defaults to no expiry.
    :vartype expiry_time: ~datetime.datetime
    :ivar language: Language code in ISO 639-1 format. Must specify zh-cn or zh-tw for Chinese.
    :vartype language: str
    :ivar reject_duplicates: If "true", parsing will fail when the uploaded document is duplicate
     of an existing document, no credits will be consumed. If "false", will parse the document
     normally whether its a duplicate or not. If not provided, will fallback to the workspace
     settings.
    :vartype reject_duplicates: bool
    :ivar region_bias: A JSON representation of the RegionBias object.
    :vartype region_bias: str
    :ivar low_priority: Explicitly mark this document as low priority.
    :vartype low_priority: bool
    :ivar compact: If true, the returned parse result (assuming ``wait`` is also true) will be a
     compact version of the full result.
    :vartype compact: bool
    :ivar delete_after_parse: If true, no data will be stored after parsing. Only compatible with
     requests where wait: True.
    :vartype delete_after_parse: bool
    :ivar enable_validation_tool: If true, the document will be viewable in the Affinda Validation
     Tool. Set to False to optimize parsing speed.
    :vartype enable_validation_tool: bool
    """

    _attribute_map = {
        "file": {"key": "file", "type": "IO"},
        "url": {"key": "url", "type": "str"},
        "data": {"key": "data", "type": "object"},
        "collection": {"key": "collection", "type": "str"},
        "workspace": {"key": "workspace", "type": "str"},
        "wait": {"key": "wait", "type": "bool"},
        "identifier": {"key": "identifier", "type": "str"},
        "custom_identifier": {"key": "customIdentifier", "type": "str"},
        "file_name": {"key": "fileName", "type": "str"},
        "expiry_time": {"key": "expiryTime", "type": "iso-8601"},
        "language": {"key": "language", "type": "str"},
        "reject_duplicates": {"key": "rejectDuplicates", "type": "bool"},
        "region_bias": {"key": "regionBias", "type": "str"},
        "low_priority": {"key": "lowPriority", "type": "bool"},
        "compact": {"key": "compact", "type": "bool"},
        "delete_after_parse": {"key": "deleteAfterParse", "type": "bool"},
        "enable_validation_tool": {"key": "enableValidationTool", "type": "bool"},
    }

    def __init__(self, **kwargs):
        """
        :keyword file: File as binary data blob. Supported formats: PDF, DOC, DOCX, TXT, RTF, HTML,
         PNG, JPG, TIFF, ODT, XLS, XLSX, ZIP.
        :paramtype file: IO
        :keyword url: URL to download the document.
        :paramtype url: str
        :keyword data: Create resume or job description directly from data.
        :paramtype data: any
        :keyword collection: Uniquely identify a collection.
        :paramtype collection: str
        :keyword workspace: Uniquely identify a workspace.
        :paramtype workspace: str
        :keyword wait: If "true" (default), will return a response only after processing has completed.
         If "false", will return an empty data object which can be polled at the GET endpoint until
         processing is complete.
        :paramtype wait: bool
        :keyword identifier: Deprecated in favor of ``customIdentifier``.
        :paramtype identifier: str
        :keyword custom_identifier: Specify a custom identifier for the document if you need one, not
         required to be unique.
        :paramtype custom_identifier: str
        :keyword file_name: Optional filename of the file.
        :paramtype file_name: str
        :keyword expiry_time: The date/time in ISO-8601 format when the document will be automatically
         deleted.  Defaults to no expiry.
        :paramtype expiry_time: ~datetime.datetime
        :keyword language: Language code in ISO 639-1 format. Must specify zh-cn or zh-tw for Chinese.
        :paramtype language: str
        :keyword reject_duplicates: If "true", parsing will fail when the uploaded document is
         duplicate of an existing document, no credits will be consumed. If "false", will parse the
         document normally whether its a duplicate or not. If not provided, will fallback to the
         workspace settings.
        :paramtype reject_duplicates: bool
        :keyword region_bias: A JSON representation of the RegionBias object.
        :paramtype region_bias: str
        :keyword low_priority: Explicitly mark this document as low priority.
        :paramtype low_priority: bool
        :keyword compact: If true, the returned parse result (assuming ``wait`` is also true) will be a
         compact version of the full result.
        :paramtype compact: bool
        :keyword delete_after_parse: If true, no data will be stored after parsing. Only compatible
         with requests where wait: True.
        :paramtype delete_after_parse: bool
        :keyword enable_validation_tool: If true, the document will be viewable in the Affinda
         Validation Tool. Set to False to optimize parsing speed.
        :paramtype enable_validation_tool: bool
        """
        super(DocumentCreate, self).__init__(**kwargs)
        self.file = kwargs.get("file", None)
        self.url = kwargs.get("url", None)
        self.data = kwargs.get("data", None)
        self.collection = kwargs.get("collection", None)
        self.workspace = kwargs.get("workspace", None)
        self.wait = kwargs.get("wait", True)
        self.identifier = kwargs.get("identifier", None)
        self.custom_identifier = kwargs.get("custom_identifier", None)
        self.file_name = kwargs.get("file_name", None)
        self.expiry_time = kwargs.get("expiry_time", None)
        self.language = kwargs.get("language", None)
        self.reject_duplicates = kwargs.get("reject_duplicates", None)
        self.region_bias = kwargs.get("region_bias", None)
        self.low_priority = kwargs.get("low_priority", None)
        self.compact = kwargs.get("compact", None)
        self.delete_after_parse = kwargs.get("delete_after_parse", None)
        self.enable_validation_tool = kwargs.get("enable_validation_tool", None)


class DocumentEditRequest(msrest.serialization.Model):
    """DocumentEditRequest.

    All required parameters must be populated in order to send to Azure.

    :ivar splits: Required.
    :vartype splits: list[~affinda.models.DocumentSplit]
    """

    _validation = {
        "splits": {"required": True},
    }

    _attribute_map = {
        "splits": {"key": "splits", "type": "[DocumentSplit]"},
    }

    def __init__(self, **kwargs):
        """
        :keyword splits: Required.
        :paramtype splits: list[~affinda.models.DocumentSplit]
        """
        super(DocumentEditRequest, self).__init__(**kwargs)
        self.splits = kwargs["splits"]


class DocumentError(msrest.serialization.Model):
    """DocumentError.

    :ivar error_code:
    :vartype error_code: str
    :ivar error_detail:
    :vartype error_detail: str
    """

    _attribute_map = {
        "error_code": {"key": "errorCode", "type": "str"},
        "error_detail": {"key": "errorDetail", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword error_code:
        :paramtype error_code: str
        :keyword error_detail:
        :paramtype error_detail: str
        """
        super(DocumentError, self).__init__(**kwargs)
        self.error_code = kwargs.get("error_code", None)
        self.error_detail = kwargs.get("error_detail", None)


class DocumentMeta(msrest.serialization.Model):
    """DocumentMeta.

    All required parameters must be populated in order to send to Azure.

    :ivar identifier: Required. Unique identifier for the document.
    :vartype identifier: str
    :ivar custom_identifier: Optional identifier for the document that you can set to track the
     document in the Affinda system.  Is not required to be unique.
    :vartype custom_identifier: str
    :ivar file_name: Optional filename of the file.
    :vartype file_name: str
    :ivar ready: If true, the document has finished processing. Particularly useful if an endpoint
     request specified wait=False, when polling use this variable to determine when to stop polling.
    :vartype ready: bool
    :ivar ready_dt: The datetime when the document was ready.
    :vartype ready_dt: ~datetime.datetime
    :ivar failed: If true, some exception was raised during processing. Check the 'error' field of
     the main return object.
    :vartype failed: bool
    :ivar expiry_time: The date/time in ISO-8601 format when the document will be automatically
     deleted.  Defaults to no expiry.
    :vartype expiry_time: ~datetime.datetime
    :ivar language: The document's language.
    :vartype language: str
    :ivar pdf: The URL to the document's pdf (if the uploaded document is not already pdf, it's
     converted to pdf as part of the parsing process).
    :vartype pdf: str
    :ivar parent_document: If this document is part of a splitted document, this attribute points
     to the original document that this document is splitted from.
    :vartype parent_document: ~affinda.models.DocumentMetaParentDocument
    :ivar child_documents: If this document has been splitted into a number of child documents,
     this attribute points to those child documents.
    :vartype child_documents: list[~affinda.models.DocumentMetaChildDocumentsItem]
    :ivar pages: Required. The document's pages.
    :vartype pages: list[~affinda.models.PageMeta]
    :ivar is_ocrd:
    :vartype is_ocrd: bool
    :ivar ocr_confidence:
    :vartype ocr_confidence: float
    :ivar review_url:
    :vartype review_url: str
    :ivar collection:
    :vartype collection: ~affinda.models.DocumentMetaCollection
    :ivar workspace: Required.
    :vartype workspace: ~affinda.models.DocumentMetaWorkspace
    :ivar archived_dt:
    :vartype archived_dt: ~datetime.datetime
    :ivar is_archived:
    :vartype is_archived: bool
    :ivar skip_parse:
    :vartype skip_parse: bool
    :ivar confirmed_dt:
    :vartype confirmed_dt: ~datetime.datetime
    :ivar confirmed_by:
    :vartype confirmed_by: ~affinda.models.UserNullable
    :ivar is_confirmed:
    :vartype is_confirmed: bool
    :ivar rejected_dt:
    :vartype rejected_dt: ~datetime.datetime
    :ivar rejected_by:
    :vartype rejected_by: ~affinda.models.UserNullable
    :ivar is_rejected:
    :vartype is_rejected: bool
    :ivar created_dt:
    :vartype created_dt: ~datetime.datetime
    :ivar error_code:
    :vartype error_code: str
    :ivar error_detail:
    :vartype error_detail: str
    :ivar file: URL to view the file.
    :vartype file: str
    :ivar html: URL to view the file converted to HTML.
    :vartype html: str
    :ivar tags: A set of tags.
    :vartype tags: list[~affinda.models.Tag]
    :ivar created_by:
    :vartype created_by: ~affinda.models.User
    :ivar source_email: If the document is created via email ingestion, this field stores the email
     file's URL.
    :vartype source_email: str
    :ivar source_email_address: If the document is created via email ingestion, this field stores
     the email's From address.
    :vartype source_email_address: str
    :ivar region_bias:
    :vartype region_bias: ~affinda.models.RegionBias
    """

    _validation = {
        "identifier": {"required": True},
        "pages": {"required": True},
        "workspace": {"required": True},
    }

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
        "custom_identifier": {"key": "customIdentifier", "type": "str"},
        "file_name": {"key": "fileName", "type": "str"},
        "ready": {"key": "ready", "type": "bool"},
        "ready_dt": {"key": "readyDt", "type": "iso-8601"},
        "failed": {"key": "failed", "type": "bool"},
        "expiry_time": {"key": "expiryTime", "type": "iso-8601"},
        "language": {"key": "language", "type": "str"},
        "pdf": {"key": "pdf", "type": "str"},
        "parent_document": {"key": "parentDocument", "type": "DocumentMetaParentDocument"},
        "child_documents": {"key": "childDocuments", "type": "[DocumentMetaChildDocumentsItem]"},
        "pages": {"key": "pages", "type": "[PageMeta]"},
        "is_ocrd": {"key": "isOcrd", "type": "bool"},
        "ocr_confidence": {"key": "ocrConfidence", "type": "float"},
        "review_url": {"key": "reviewUrl", "type": "str"},
        "collection": {"key": "collection", "type": "DocumentMetaCollection"},
        "workspace": {"key": "workspace", "type": "DocumentMetaWorkspace"},
        "archived_dt": {"key": "archivedDt", "type": "iso-8601"},
        "is_archived": {"key": "isArchived", "type": "bool"},
        "skip_parse": {"key": "skipParse", "type": "bool"},
        "confirmed_dt": {"key": "confirmedDt", "type": "iso-8601"},
        "confirmed_by": {"key": "confirmedBy", "type": "UserNullable"},
        "is_confirmed": {"key": "isConfirmed", "type": "bool"},
        "rejected_dt": {"key": "rejectedDt", "type": "iso-8601"},
        "rejected_by": {"key": "rejectedBy", "type": "UserNullable"},
        "is_rejected": {"key": "isRejected", "type": "bool"},
        "created_dt": {"key": "createdDt", "type": "iso-8601"},
        "error_code": {"key": "errorCode", "type": "str"},
        "error_detail": {"key": "errorDetail", "type": "str"},
        "file": {"key": "file", "type": "str"},
        "html": {"key": "html", "type": "str"},
        "tags": {"key": "tags", "type": "[Tag]"},
        "created_by": {"key": "createdBy", "type": "User"},
        "source_email": {"key": "sourceEmail", "type": "str"},
        "source_email_address": {"key": "sourceEmailAddress", "type": "str"},
        "region_bias": {"key": "regionBias", "type": "RegionBias"},
    }

    def __init__(self, **kwargs):
        """
        :keyword identifier: Required. Unique identifier for the document.
        :paramtype identifier: str
        :keyword custom_identifier: Optional identifier for the document that you can set to track the
         document in the Affinda system.  Is not required to be unique.
        :paramtype custom_identifier: str
        :keyword file_name: Optional filename of the file.
        :paramtype file_name: str
        :keyword ready: If true, the document has finished processing. Particularly useful if an
         endpoint request specified wait=False, when polling use this variable to determine when to stop
         polling.
        :paramtype ready: bool
        :keyword ready_dt: The datetime when the document was ready.
        :paramtype ready_dt: ~datetime.datetime
        :keyword failed: If true, some exception was raised during processing. Check the 'error' field
         of the main return object.
        :paramtype failed: bool
        :keyword expiry_time: The date/time in ISO-8601 format when the document will be automatically
         deleted.  Defaults to no expiry.
        :paramtype expiry_time: ~datetime.datetime
        :keyword language: The document's language.
        :paramtype language: str
        :keyword pdf: The URL to the document's pdf (if the uploaded document is not already pdf, it's
         converted to pdf as part of the parsing process).
        :paramtype pdf: str
        :keyword parent_document: If this document is part of a splitted document, this attribute
         points to the original document that this document is splitted from.
        :paramtype parent_document: ~affinda.models.DocumentMetaParentDocument
        :keyword child_documents: If this document has been splitted into a number of child documents,
         this attribute points to those child documents.
        :paramtype child_documents: list[~affinda.models.DocumentMetaChildDocumentsItem]
        :keyword pages: Required. The document's pages.
        :paramtype pages: list[~affinda.models.PageMeta]
        :keyword is_ocrd:
        :paramtype is_ocrd: bool
        :keyword ocr_confidence:
        :paramtype ocr_confidence: float
        :keyword review_url:
        :paramtype review_url: str
        :keyword collection:
        :paramtype collection: ~affinda.models.DocumentMetaCollection
        :keyword workspace: Required.
        :paramtype workspace: ~affinda.models.DocumentMetaWorkspace
        :keyword archived_dt:
        :paramtype archived_dt: ~datetime.datetime
        :keyword is_archived:
        :paramtype is_archived: bool
        :keyword skip_parse:
        :paramtype skip_parse: bool
        :keyword confirmed_dt:
        :paramtype confirmed_dt: ~datetime.datetime
        :keyword confirmed_by:
        :paramtype confirmed_by: ~affinda.models.UserNullable
        :keyword is_confirmed:
        :paramtype is_confirmed: bool
        :keyword rejected_dt:
        :paramtype rejected_dt: ~datetime.datetime
        :keyword rejected_by:
        :paramtype rejected_by: ~affinda.models.UserNullable
        :keyword is_rejected:
        :paramtype is_rejected: bool
        :keyword created_dt:
        :paramtype created_dt: ~datetime.datetime
        :keyword error_code:
        :paramtype error_code: str
        :keyword error_detail:
        :paramtype error_detail: str
        :keyword file: URL to view the file.
        :paramtype file: str
        :keyword html: URL to view the file converted to HTML.
        :paramtype html: str
        :keyword tags: A set of tags.
        :paramtype tags: list[~affinda.models.Tag]
        :keyword created_by:
        :paramtype created_by: ~affinda.models.User
        :keyword source_email: If the document is created via email ingestion, this field stores the
         email file's URL.
        :paramtype source_email: str
        :keyword source_email_address: If the document is created via email ingestion, this field
         stores the email's From address.
        :paramtype source_email_address: str
        :keyword region_bias:
        :paramtype region_bias: ~affinda.models.RegionBias
        """
        super(DocumentMeta, self).__init__(**kwargs)
        self.identifier = kwargs["identifier"]
        self.custom_identifier = kwargs.get("custom_identifier", None)
        self.file_name = kwargs.get("file_name", None)
        self.ready = kwargs.get("ready", None)
        self.ready_dt = kwargs.get("ready_dt", None)
        self.failed = kwargs.get("failed", None)
        self.expiry_time = kwargs.get("expiry_time", None)
        self.language = kwargs.get("language", None)
        self.pdf = kwargs.get("pdf", None)
        self.parent_document = kwargs.get("parent_document", None)
        self.child_documents = kwargs.get("child_documents", None)
        self.pages = kwargs["pages"]
        self.is_ocrd = kwargs.get("is_ocrd", None)
        self.ocr_confidence = kwargs.get("ocr_confidence", None)
        self.review_url = kwargs.get("review_url", None)
        self.collection = kwargs.get("collection", None)
        self.workspace = kwargs["workspace"]
        self.archived_dt = kwargs.get("archived_dt", None)
        self.is_archived = kwargs.get("is_archived", None)
        self.skip_parse = kwargs.get("skip_parse", None)
        self.confirmed_dt = kwargs.get("confirmed_dt", None)
        self.confirmed_by = kwargs.get("confirmed_by", None)
        self.is_confirmed = kwargs.get("is_confirmed", None)
        self.rejected_dt = kwargs.get("rejected_dt", None)
        self.rejected_by = kwargs.get("rejected_by", None)
        self.is_rejected = kwargs.get("is_rejected", None)
        self.created_dt = kwargs.get("created_dt", None)
        self.error_code = kwargs.get("error_code", None)
        self.error_detail = kwargs.get("error_detail", None)
        self.file = kwargs.get("file", None)
        self.html = kwargs.get("html", None)
        self.tags = kwargs.get("tags", None)
        self.created_by = kwargs.get("created_by", None)
        self.source_email = kwargs.get("source_email", None)
        self.source_email_address = kwargs.get("source_email_address", None)
        self.region_bias = kwargs.get("region_bias", None)


class DocumentMetaChildDocumentsItem(msrest.serialization.Model):
    """DocumentMetaChildDocumentsItem.

    :ivar identifier: Unique identifier for the document.
    :vartype identifier: str
    """

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword identifier: Unique identifier for the document.
        :paramtype identifier: str
        """
        super(DocumentMetaChildDocumentsItem, self).__init__(**kwargs)
        self.identifier = kwargs.get("identifier", None)


class DocumentMetaCollection(msrest.serialization.Model):
    """DocumentMetaCollection.

    All required parameters must be populated in order to send to Azure.

    :ivar identifier: Required. Uniquely identify a collection.
    :vartype identifier: str
    :ivar name:
    :vartype name: str
    :ivar extractor:
    :vartype extractor: ~affinda.models.DocumentMetaCollectionExtractor
    :ivar validation_rules:
    :vartype validation_rules: list[~affinda.models.ValidationRule]
    """

    _validation = {
        "identifier": {"required": True},
    }

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "extractor": {"key": "extractor", "type": "DocumentMetaCollectionExtractor"},
        "validation_rules": {"key": "validationRules", "type": "[ValidationRule]"},
    }

    def __init__(self, **kwargs):
        """
        :keyword identifier: Required. Uniquely identify a collection.
        :paramtype identifier: str
        :keyword name:
        :paramtype name: str
        :keyword extractor:
        :paramtype extractor: ~affinda.models.DocumentMetaCollectionExtractor
        :keyword validation_rules:
        :paramtype validation_rules: list[~affinda.models.ValidationRule]
        """
        super(DocumentMetaCollection, self).__init__(**kwargs)
        self.identifier = kwargs["identifier"]
        self.name = kwargs.get("name", None)
        self.extractor = kwargs.get("extractor", None)
        self.validation_rules = kwargs.get("validation_rules", None)


class DocumentMetaCollectionExtractor(msrest.serialization.Model):
    """DocumentMetaCollectionExtractor.

    :ivar identifier: Uniquely identify an extractor.
    :vartype identifier: str
    :ivar name:
    :vartype name: str
    :ivar base_extractor: Base extractor's identifier.
    :vartype base_extractor: str
    :ivar validatable:
    :vartype validatable: bool
    """

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "base_extractor": {"key": "baseExtractor", "type": "str"},
        "validatable": {"key": "validatable", "type": "bool"},
    }

    def __init__(self, **kwargs):
        """
        :keyword identifier: Uniquely identify an extractor.
        :paramtype identifier: str
        :keyword name:
        :paramtype name: str
        :keyword base_extractor: Base extractor's identifier.
        :paramtype base_extractor: str
        :keyword validatable:
        :paramtype validatable: bool
        """
        super(DocumentMetaCollectionExtractor, self).__init__(**kwargs)
        self.identifier = kwargs.get("identifier", None)
        self.name = kwargs.get("name", None)
        self.base_extractor = kwargs.get("base_extractor", None)
        self.validatable = kwargs.get("validatable", None)


class DocumentMetaParentDocument(msrest.serialization.Model):
    """If this document is part of a splitted document, this attribute points to the original document that this document is splitted from.

    :ivar identifier: Unique identifier for the document.
    :vartype identifier: str
    """

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword identifier: Unique identifier for the document.
        :paramtype identifier: str
        """
        super(DocumentMetaParentDocument, self).__init__(**kwargs)
        self.identifier = kwargs.get("identifier", None)


class DocumentMetaWorkspace(msrest.serialization.Model):
    """DocumentMetaWorkspace.

    All required parameters must be populated in order to send to Azure.

    :ivar identifier: Required. Uniquely identify a workspace.
    :vartype identifier: str
    :ivar name:
    :vartype name: str
    """

    _validation = {
        "identifier": {"required": True},
    }

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
        "name": {"key": "name", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword identifier: Required. Uniquely identify a workspace.
        :paramtype identifier: str
        :keyword name:
        :paramtype name: str
        """
        super(DocumentMetaWorkspace, self).__init__(**kwargs)
        self.identifier = kwargs["identifier"]
        self.name = kwargs.get("name", None)


class DocumentSplit(msrest.serialization.Model):
    """Describe a split of a document.

    All required parameters must be populated in order to send to Azure.

    :ivar identifier: Anything.
    :vartype identifier: any
    :ivar pages: Required.
    :vartype pages: list[~affinda.models.DocumentSplitPage]
    """

    _validation = {
        "pages": {"required": True},
    }

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "object"},
        "pages": {"key": "pages", "type": "[DocumentSplitPage]"},
    }

    def __init__(self, **kwargs):
        """
        :keyword identifier: Anything.
        :paramtype identifier: any
        :keyword pages: Required.
        :paramtype pages: list[~affinda.models.DocumentSplitPage]
        """
        super(DocumentSplit, self).__init__(**kwargs)
        self.identifier = kwargs.get("identifier", None)
        self.pages = kwargs["pages"]


class DocumentSplitPage(msrest.serialization.Model):
    """List the pages within this split. Not including a page here will signal that the page should be deleted.

    All required parameters must be populated in order to send to Azure.

    :ivar id: Required. Page's ID.
    :vartype id: int
    :ivar rotation: Specify a degree of rotation if you want to rotate a page. Possitive number for
     clockwise rotation, and negative number for counter-clockwise rotation.
    :vartype rotation: int
    """

    _validation = {
        "id": {"required": True, "minimum": 1},
        "rotation": {"maximum": 360, "minimum": -360},
    }

    _attribute_map = {
        "id": {"key": "id", "type": "int"},
        "rotation": {"key": "rotation", "type": "int"},
    }

    def __init__(self, **kwargs):
        """
        :keyword id: Required. Page's ID.
        :paramtype id: int
        :keyword rotation: Specify a degree of rotation if you want to rotate a page. Possitive number
         for clockwise rotation, and negative number for counter-clockwise rotation.
        :paramtype rotation: int
        """
        super(DocumentSplitPage, self).__init__(**kwargs)
        self.id = kwargs["id"]
        self.rotation = kwargs.get("rotation", None)


class DocumentUpdate(msrest.serialization.Model):
    """DocumentUpdate.

    :ivar collection: Uniquely identify a collection.
    :vartype collection: str
    :ivar file_name: Optional filename of the file.
    :vartype file_name: str
    :ivar expiry_time: The date/time in ISO-8601 format when the document will be automatically
     deleted.  Defaults to no expiry.
    :vartype expiry_time: ~datetime.datetime
    :ivar is_confirmed:
    :vartype is_confirmed: bool
    :ivar is_rejected:
    :vartype is_rejected: bool
    :ivar is_archived:
    :vartype is_archived: bool
    :ivar skip_parse:
    :vartype skip_parse: bool
    :ivar language: Language code in ISO 639-1 format. Must specify zh-cn or zh-tw for Chinese.
    :vartype language: str
    :ivar identifier: Deprecated in favor of ``customIdentifier``.
    :vartype identifier: str
    :ivar custom_identifier: Specify a custom identifier for the document if you need one, not
     required to be unique.
    :vartype custom_identifier: str
    """

    _attribute_map = {
        "collection": {"key": "collection", "type": "str"},
        "file_name": {"key": "fileName", "type": "str"},
        "expiry_time": {"key": "expiryTime", "type": "iso-8601"},
        "is_confirmed": {"key": "isConfirmed", "type": "bool"},
        "is_rejected": {"key": "isRejected", "type": "bool"},
        "is_archived": {"key": "isArchived", "type": "bool"},
        "skip_parse": {"key": "skipParse", "type": "bool"},
        "language": {"key": "language", "type": "str"},
        "identifier": {"key": "identifier", "type": "str"},
        "custom_identifier": {"key": "customIdentifier", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword collection: Uniquely identify a collection.
        :paramtype collection: str
        :keyword file_name: Optional filename of the file.
        :paramtype file_name: str
        :keyword expiry_time: The date/time in ISO-8601 format when the document will be automatically
         deleted.  Defaults to no expiry.
        :paramtype expiry_time: ~datetime.datetime
        :keyword is_confirmed:
        :paramtype is_confirmed: bool
        :keyword is_rejected:
        :paramtype is_rejected: bool
        :keyword is_archived:
        :paramtype is_archived: bool
        :keyword skip_parse:
        :paramtype skip_parse: bool
        :keyword language: Language code in ISO 639-1 format. Must specify zh-cn or zh-tw for Chinese.
        :paramtype language: str
        :keyword identifier: Deprecated in favor of ``customIdentifier``.
        :paramtype identifier: str
        :keyword custom_identifier: Specify a custom identifier for the document if you need one, not
         required to be unique.
        :paramtype custom_identifier: str
        """
        super(DocumentUpdate, self).__init__(**kwargs)
        self.collection = kwargs.get("collection", None)
        self.file_name = kwargs.get("file_name", None)
        self.expiry_time = kwargs.get("expiry_time", None)
        self.is_confirmed = kwargs.get("is_confirmed", None)
        self.is_rejected = kwargs.get("is_rejected", None)
        self.is_archived = kwargs.get("is_archived", None)
        self.skip_parse = kwargs.get("skip_parse", None)
        self.language = kwargs.get("language", None)
        self.identifier = kwargs.get("identifier", None)
        self.custom_identifier = kwargs.get("custom_identifier", None)


class DocumentWarning(msrest.serialization.Model):
    """DocumentWarning.

    :ivar warning_code:
    :vartype warning_code: str
    :ivar warning_detail:
    :vartype warning_detail: str
    """

    _attribute_map = {
        "warning_code": {"key": "warningCode", "type": "str"},
        "warning_detail": {"key": "warningDetail", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword warning_code:
        :paramtype warning_code: str
        :keyword warning_detail:
        :paramtype warning_detail: str
        """
        super(DocumentWarning, self).__init__(**kwargs)
        self.warning_code = kwargs.get("warning_code", None)
        self.warning_detail = kwargs.get("warning_detail", None)


class Education(msrest.serialization.Model):
    """Education.

    :ivar id:
    :vartype id: int
    :ivar organization:
    :vartype organization: str
    :ivar accreditation:
    :vartype accreditation: ~affinda.models.Accreditation
    :ivar grade:
    :vartype grade: ~affinda.models.EducationGrade
    :ivar location:
    :vartype location: ~affinda.models.Location
    :ivar dates:
    :vartype dates: ~affinda.models.EducationDates
    """

    _validation = {
        "id": {"minimum": 1},
    }

    _attribute_map = {
        "id": {"key": "id", "type": "int"},
        "organization": {"key": "organization", "type": "str"},
        "accreditation": {"key": "accreditation", "type": "Accreditation"},
        "grade": {"key": "grade", "type": "EducationGrade"},
        "location": {"key": "location", "type": "Location"},
        "dates": {"key": "dates", "type": "EducationDates"},
    }

    def __init__(self, **kwargs):
        """
        :keyword id:
        :paramtype id: int
        :keyword organization:
        :paramtype organization: str
        :keyword accreditation:
        :paramtype accreditation: ~affinda.models.Accreditation
        :keyword grade:
        :paramtype grade: ~affinda.models.EducationGrade
        :keyword location:
        :paramtype location: ~affinda.models.Location
        :keyword dates:
        :paramtype dates: ~affinda.models.EducationDates
        """
        super(Education, self).__init__(**kwargs)
        self.id = kwargs.get("id", None)
        self.organization = kwargs.get("organization", None)
        self.accreditation = kwargs.get("accreditation", None)
        self.grade = kwargs.get("grade", None)
        self.location = kwargs.get("location", None)
        self.dates = kwargs.get("dates", None)


class EducationDates(msrest.serialization.Model):
    """EducationDates.

    :ivar completion_date:
    :vartype completion_date: ~datetime.date
    :ivar is_current:
    :vartype is_current: bool
    :ivar start_date:
    :vartype start_date: ~datetime.date
    :ivar raw_text:
    :vartype raw_text: str
    """

    _attribute_map = {
        "completion_date": {"key": "completionDate", "type": "date"},
        "is_current": {"key": "isCurrent", "type": "bool"},
        "start_date": {"key": "startDate", "type": "date"},
        "raw_text": {"key": "rawText", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword completion_date:
        :paramtype completion_date: ~datetime.date
        :keyword is_current:
        :paramtype is_current: bool
        :keyword start_date:
        :paramtype start_date: ~datetime.date
        :keyword raw_text:
        :paramtype raw_text: str
        """
        super(EducationDates, self).__init__(**kwargs)
        self.completion_date = kwargs.get("completion_date", None)
        self.is_current = kwargs.get("is_current", None)
        self.start_date = kwargs.get("start_date", None)
        self.raw_text = kwargs.get("raw_text", None)


class EducationGrade(msrest.serialization.Model):
    """EducationGrade.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar raw:
    :vartype raw: str
    :ivar metric:
    :vartype metric: str
    :ivar value:
    :vartype value: str
    """

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "raw": {"key": "raw", "type": "str"},
        "metric": {"key": "metric", "type": "str"},
        "value": {"key": "value", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword raw:
        :paramtype raw: str
        :keyword metric:
        :paramtype metric: str
        :keyword value:
        :paramtype value: str
        """
        super(EducationGrade, self).__init__(**kwargs)
        self.additional_properties = kwargs.get("additional_properties", None)
        self.raw = kwargs.get("raw", None)
        self.metric = kwargs.get("metric", None)
        self.value = kwargs.get("value", None)


class EducationSearchScoreComponent(msrest.serialization.Model):
    """EducationSearchScoreComponent.

    All required parameters must be populated in order to send to Azure.

    :ivar value:
    :vartype value: str
    :ivar label: Required.
    :vartype label: str
    :ivar score:
    :vartype score: float
    """

    _validation = {
        "label": {"required": True},
    }

    _attribute_map = {
        "value": {"key": "value", "type": "str"},
        "label": {"key": "label", "type": "str"},
        "score": {"key": "score", "type": "float"},
    }

    def __init__(self, **kwargs):
        """
        :keyword value:
        :paramtype value: str
        :keyword label: Required.
        :paramtype label: str
        :keyword score:
        :paramtype score: float
        """
        super(EducationSearchScoreComponent, self).__init__(**kwargs)
        self.value = kwargs.get("value", None)
        self.label = kwargs["label"]
        self.score = kwargs.get("score", None)


class ExpectedRemunerationAnnotation(Annotation):
    """ExpectedRemunerationAnnotation.

    All required parameters must be populated in order to send to Azure.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id: Required. Annotation's ID.
    :vartype id: int
    :ivar rectangle: Required. x/y coordinates for the rectangular bounding box containing the
     data.
    :vartype rectangle: ~affinda.models.Rectangle
    :ivar rectangles: Required. x/y coordinates for the rectangles containing the data. An
     annotation can be contained within multiple rectangles.
    :vartype rectangles: list[~affinda.models.Rectangle]
    :ivar document: Required. Unique identifier for the document.
    :vartype document: str
    :ivar page_index: Required. The page number within the document, starting from 0.
    :vartype page_index: int
    :ivar raw: Required. Raw data extracted from the before any post-processing.
    :vartype raw: str
    :ivar confidence: Required. The overall confidence that the model's prediction is correct.
    :vartype confidence: float
    :ivar classification_confidence: Required. The model's confidence that the text has been
     classified correctly.
    :vartype classification_confidence: float
    :ivar text_extraction_confidence: Required. If the document was submitted as an image, this is
     the confidence that the text in the image has been correctly read by the model.
    :vartype text_extraction_confidence: float
    :ivar is_verified: Required. Indicates whether the data has been validated, either by a human
     using our validation tool or through auto-validation rules.
    :vartype is_verified: bool
    :ivar is_client_verified: Required. Indicates whether the data has been validated by a human.
    :vartype is_client_verified: bool
    :ivar is_auto_verified: Required. Indicates whether the data has been auto-validated.
    :vartype is_auto_verified: bool
    :ivar data_point: Required. Data point's identifier.
    :vartype data_point: str
    :ivar content_type: Required. The different data types of annotations. Known values are:
     "text", "integer", "float", "decimal", "date", "datetime", "daterange", "boolean", "enum",
     "location", "phonenumber", "json", "table", "expectedremuneration", "jobtitle", "language",
     "skill", "yearsexperience", "group", "table_deprecated", "url", "image".
    :vartype content_type: str or ~affinda.models.AnnotationContentType
    :ivar parent: The parent annotation's ID.
    :vartype parent: int
    :ivar parsed:
    :vartype parsed: ~affinda.models.ExpectedRemunerationAnnotationParsed
    """

    _validation = {
        "id": {"required": True, "minimum": 1},
        "rectangle": {"required": True},
        "rectangles": {"required": True},
        "document": {"required": True},
        "page_index": {"required": True, "minimum": 0},
        "raw": {"required": True},
        "confidence": {"required": True},
        "classification_confidence": {"required": True},
        "text_extraction_confidence": {"required": True},
        "is_verified": {"required": True},
        "is_client_verified": {"required": True},
        "is_auto_verified": {"required": True},
        "data_point": {"required": True},
        "content_type": {"required": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "int"},
        "rectangle": {"key": "rectangle", "type": "Rectangle"},
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "document": {"key": "document", "type": "str"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "confidence": {"key": "confidence", "type": "float"},
        "classification_confidence": {"key": "classificationConfidence", "type": "float"},
        "text_extraction_confidence": {"key": "textExtractionConfidence", "type": "float"},
        "is_verified": {"key": "isVerified", "type": "bool"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "is_auto_verified": {"key": "isAutoVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "content_type": {"key": "contentType", "type": "str"},
        "parent": {"key": "parent", "type": "int"},
        "parsed": {"key": "parsed", "type": "ExpectedRemunerationAnnotationParsed"},
    }

    def __init__(self, **kwargs):
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword id: Required. Annotation's ID.
        :paramtype id: int
        :keyword rectangle: Required. x/y coordinates for the rectangular bounding box containing the
         data.
        :paramtype rectangle: ~affinda.models.Rectangle
        :keyword rectangles: Required. x/y coordinates for the rectangles containing the data. An
         annotation can be contained within multiple rectangles.
        :paramtype rectangles: list[~affinda.models.Rectangle]
        :keyword document: Required. Unique identifier for the document.
        :paramtype document: str
        :keyword page_index: Required. The page number within the document, starting from 0.
        :paramtype page_index: int
        :keyword raw: Required. Raw data extracted from the before any post-processing.
        :paramtype raw: str
        :keyword confidence: Required. The overall confidence that the model's prediction is correct.
        :paramtype confidence: float
        :keyword classification_confidence: Required. The model's confidence that the text has been
         classified correctly.
        :paramtype classification_confidence: float
        :keyword text_extraction_confidence: Required. If the document was submitted as an image, this
         is the confidence that the text in the image has been correctly read by the model.
        :paramtype text_extraction_confidence: float
        :keyword is_verified: Required. Indicates whether the data has been validated, either by a
         human using our validation tool or through auto-validation rules.
        :paramtype is_verified: bool
        :keyword is_client_verified: Required. Indicates whether the data has been validated by a
         human.
        :paramtype is_client_verified: bool
        :keyword is_auto_verified: Required. Indicates whether the data has been auto-validated.
        :paramtype is_auto_verified: bool
        :keyword data_point: Required. Data point's identifier.
        :paramtype data_point: str
        :keyword content_type: Required. The different data types of annotations. Known values are:
         "text", "integer", "float", "decimal", "date", "datetime", "daterange", "boolean", "enum",
         "location", "phonenumber", "json", "table", "expectedremuneration", "jobtitle", "language",
         "skill", "yearsexperience", "group", "table_deprecated", "url", "image".
        :paramtype content_type: str or ~affinda.models.AnnotationContentType
        :keyword parent: The parent annotation's ID.
        :paramtype parent: int
        :keyword parsed:
        :paramtype parsed: ~affinda.models.ExpectedRemunerationAnnotationParsed
        """
        super(ExpectedRemunerationAnnotation, self).__init__(**kwargs)
        self.parsed = kwargs.get("parsed", None)


class ExpectedRemunerationAnnotationParsed(msrest.serialization.Model):
    """ExpectedRemunerationAnnotationParsed.

    :ivar minimum:
    :vartype minimum: float
    :ivar maximum:
    :vartype maximum: float
    :ivar currency:
    :vartype currency: str
    :ivar unit:
    :vartype unit: str
    """

    _attribute_map = {
        "minimum": {"key": "minimum", "type": "float"},
        "maximum": {"key": "maximum", "type": "float"},
        "currency": {"key": "currency", "type": "str"},
        "unit": {"key": "unit", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword minimum:
        :paramtype minimum: float
        :keyword maximum:
        :paramtype maximum: float
        :keyword currency:
        :paramtype currency: str
        :keyword unit:
        :paramtype unit: str
        """
        super(ExpectedRemunerationAnnotationParsed, self).__init__(**kwargs)
        self.minimum = kwargs.get("minimum", None)
        self.maximum = kwargs.get("maximum", None)
        self.currency = kwargs.get("currency", None)
        self.unit = kwargs.get("unit", None)


class ExpectedRemunerationAnnotationUpdate(AnnotationBase):
    """ExpectedRemunerationAnnotationUpdate.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id:
    :vartype id: int
    :ivar rectangle:
    :vartype rectangle: ~affinda.models.Rectangle
    :ivar rectangles:
    :vartype rectangles: list[~affinda.models.Rectangle]
    :ivar page_index:
    :vartype page_index: int
    :ivar raw:
    :vartype raw: str
    :ivar confidence: The overall confidence that the model's prediction is correct.
    :vartype confidence: float
    :ivar classification_confidence: The model's confidence that the text has been classified
     correctly.
    :vartype classification_confidence: float
    :ivar text_extraction_confidence: If the document was submitted as an image, this is the
     confidence that the text in the image has been correctly read by the model.
    :vartype text_extraction_confidence: float
    :ivar is_verified:
    :vartype is_verified: bool
    :ivar is_client_verified:
    :vartype is_client_verified: bool
    :ivar is_auto_verified:
    :vartype is_auto_verified: bool
    :ivar data_point:
    :vartype data_point: str
    :ivar content_type:
    :vartype content_type: str
    :ivar parsed:
    :vartype parsed: ~affinda.models.ExpectedRemunerationAnnotationUpdateParsed
    """

    _validation = {
        "rectangles": {"readonly": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "int"},
        "rectangle": {"key": "rectangle", "type": "Rectangle"},
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "confidence": {"key": "confidence", "type": "float"},
        "classification_confidence": {"key": "classificationConfidence", "type": "float"},
        "text_extraction_confidence": {"key": "textExtractionConfidence", "type": "float"},
        "is_verified": {"key": "isVerified", "type": "bool"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "is_auto_verified": {"key": "isAutoVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "content_type": {"key": "contentType", "type": "str"},
        "parsed": {"key": "parsed", "type": "ExpectedRemunerationAnnotationUpdateParsed"},
    }

    def __init__(self, **kwargs):
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword id:
        :paramtype id: int
        :keyword rectangle:
        :paramtype rectangle: ~affinda.models.Rectangle
        :keyword page_index:
        :paramtype page_index: int
        :keyword raw:
        :paramtype raw: str
        :keyword confidence: The overall confidence that the model's prediction is correct.
        :paramtype confidence: float
        :keyword classification_confidence: The model's confidence that the text has been classified
         correctly.
        :paramtype classification_confidence: float
        :keyword text_extraction_confidence: If the document was submitted as an image, this is the
         confidence that the text in the image has been correctly read by the model.
        :paramtype text_extraction_confidence: float
        :keyword is_verified:
        :paramtype is_verified: bool
        :keyword is_client_verified:
        :paramtype is_client_verified: bool
        :keyword is_auto_verified:
        :paramtype is_auto_verified: bool
        :keyword data_point:
        :paramtype data_point: str
        :keyword content_type:
        :paramtype content_type: str
        :keyword parsed:
        :paramtype parsed: ~affinda.models.ExpectedRemunerationAnnotationUpdateParsed
        """
        super(ExpectedRemunerationAnnotationUpdate, self).__init__(**kwargs)
        self.parsed = kwargs.get("parsed", None)


class ExpectedRemunerationAnnotationUpdateParsed(msrest.serialization.Model):
    """ExpectedRemunerationAnnotationUpdateParsed.

    :ivar minimum:
    :vartype minimum: float
    :ivar maximum:
    :vartype maximum: float
    :ivar currency:
    :vartype currency: str
    :ivar unit:
    :vartype unit: str
    """

    _attribute_map = {
        "minimum": {"key": "minimum", "type": "float"},
        "maximum": {"key": "maximum", "type": "float"},
        "currency": {"key": "currency", "type": "str"},
        "unit": {"key": "unit", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword minimum:
        :paramtype minimum: float
        :keyword maximum:
        :paramtype maximum: float
        :keyword currency:
        :paramtype currency: str
        :keyword unit:
        :paramtype unit: str
        """
        super(ExpectedRemunerationAnnotationUpdateParsed, self).__init__(**kwargs)
        self.minimum = kwargs.get("minimum", None)
        self.maximum = kwargs.get("maximum", None)
        self.currency = kwargs.get("currency", None)
        self.unit = kwargs.get("unit", None)


class ExperienceSearchScoreComponent(msrest.serialization.Model):
    """ExperienceSearchScoreComponent.

    All required parameters must be populated in order to send to Azure.

    :ivar value:
    :vartype value: str
    :ivar label: Required.
    :vartype label: str
    :ivar score:
    :vartype score: float
    """

    _validation = {
        "label": {"required": True},
    }

    _attribute_map = {
        "value": {"key": "value", "type": "str"},
        "label": {"key": "label", "type": "str"},
        "score": {"key": "score", "type": "float"},
    }

    def __init__(self, **kwargs):
        """
        :keyword value:
        :paramtype value: str
        :keyword label: Required.
        :paramtype label: str
        :keyword score:
        :paramtype score: float
        """
        super(ExperienceSearchScoreComponent, self).__init__(**kwargs)
        self.value = kwargs.get("value", None)
        self.label = kwargs["label"]
        self.score = kwargs.get("score", None)


class Extractor(msrest.serialization.Model):
    """Extractor.

    All required parameters must be populated in order to send to Azure.

    :ivar identifier: Required. Uniquely identify an extractor.
    :vartype identifier: str
    :ivar name: Required.
    :vartype name: str
    :ivar name_plural: Required.
    :vartype name_plural: str
    :ivar base_extractor:
    :vartype base_extractor: ~affinda.models.ExtractorBaseExtractor
    :ivar organization:
    :vartype organization: ~affinda.models.Organization
    :ivar category:
    :vartype category: str
    :ivar validatable: Required.
    :vartype validatable: bool
    :ivar is_custom:
    :vartype is_custom: bool
    :ivar field_groups:
    :vartype field_groups: list[~affinda.models.FieldGroup]
    :ivar created_dt:
    :vartype created_dt: ~datetime.datetime
    :ivar last_trained_dt:
    :vartype last_trained_dt: ~datetime.datetime
    """

    _validation = {
        "identifier": {"required": True},
        "name": {"required": True},
        "name_plural": {"required": True},
        "validatable": {"required": True},
    }

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "name_plural": {"key": "namePlural", "type": "str"},
        "base_extractor": {"key": "baseExtractor", "type": "ExtractorBaseExtractor"},
        "organization": {"key": "organization", "type": "Organization"},
        "category": {"key": "category", "type": "str"},
        "validatable": {"key": "validatable", "type": "bool"},
        "is_custom": {"key": "isCustom", "type": "bool"},
        "field_groups": {"key": "fieldGroups", "type": "[FieldGroup]"},
        "created_dt": {"key": "createdDt", "type": "iso-8601"},
        "last_trained_dt": {"key": "lastTrainedDt", "type": "iso-8601"},
    }

    def __init__(self, **kwargs):
        """
        :keyword identifier: Required. Uniquely identify an extractor.
        :paramtype identifier: str
        :keyword name: Required.
        :paramtype name: str
        :keyword name_plural: Required.
        :paramtype name_plural: str
        :keyword base_extractor:
        :paramtype base_extractor: ~affinda.models.ExtractorBaseExtractor
        :keyword organization:
        :paramtype organization: ~affinda.models.Organization
        :keyword category:
        :paramtype category: str
        :keyword validatable: Required.
        :paramtype validatable: bool
        :keyword is_custom:
        :paramtype is_custom: bool
        :keyword field_groups:
        :paramtype field_groups: list[~affinda.models.FieldGroup]
        :keyword created_dt:
        :paramtype created_dt: ~datetime.datetime
        :keyword last_trained_dt:
        :paramtype last_trained_dt: ~datetime.datetime
        """
        super(Extractor, self).__init__(**kwargs)
        self.identifier = kwargs["identifier"]
        self.name = kwargs["name"]
        self.name_plural = kwargs["name_plural"]
        self.base_extractor = kwargs.get("base_extractor", None)
        self.organization = kwargs.get("organization", None)
        self.category = kwargs.get("category", None)
        self.validatable = kwargs["validatable"]
        self.is_custom = kwargs.get("is_custom", None)
        self.field_groups = kwargs.get("field_groups", None)
        self.created_dt = kwargs.get("created_dt", None)
        self.last_trained_dt = kwargs.get("last_trained_dt", None)


class ExtractorBaseExtractor(msrest.serialization.Model):
    """ExtractorBaseExtractor.

    All required parameters must be populated in order to send to Azure.

    :ivar identifier: Required. Uniquely identify an extractor.
    :vartype identifier: str
    :ivar name: Required.
    :vartype name: str
    :ivar name_plural: Required.
    :vartype name_plural: str
    :ivar validatable: Required.
    :vartype validatable: bool
    :ivar is_custom:
    :vartype is_custom: bool
    :ivar created_dt:
    :vartype created_dt: ~datetime.datetime
    """

    _validation = {
        "identifier": {"required": True},
        "name": {"required": True},
        "name_plural": {"required": True},
        "validatable": {"required": True},
    }

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "name_plural": {"key": "namePlural", "type": "str"},
        "validatable": {"key": "validatable", "type": "bool"},
        "is_custom": {"key": "isCustom", "type": "bool"},
        "created_dt": {"key": "createdDt", "type": "iso-8601"},
    }

    def __init__(self, **kwargs):
        """
        :keyword identifier: Required. Uniquely identify an extractor.
        :paramtype identifier: str
        :keyword name: Required.
        :paramtype name: str
        :keyword name_plural: Required.
        :paramtype name_plural: str
        :keyword validatable: Required.
        :paramtype validatable: bool
        :keyword is_custom:
        :paramtype is_custom: bool
        :keyword created_dt:
        :paramtype created_dt: ~datetime.datetime
        """
        super(ExtractorBaseExtractor, self).__init__(**kwargs)
        self.identifier = kwargs["identifier"]
        self.name = kwargs["name"]
        self.name_plural = kwargs["name_plural"]
        self.validatable = kwargs["validatable"]
        self.is_custom = kwargs.get("is_custom", None)
        self.created_dt = kwargs.get("created_dt", None)


class ExtractorConfig(msrest.serialization.Model):
    """Extra configurations specific to an extractor.

    :ivar resume_redact:
    :vartype resume_redact: ~affinda.models.RedactConfig
    """

    _attribute_map = {
        "resume_redact": {"key": "resumeRedact", "type": "RedactConfig"},
    }

    def __init__(self, **kwargs):
        """
        :keyword resume_redact:
        :paramtype resume_redact: ~affinda.models.RedactConfig
        """
        super(ExtractorConfig, self).__init__(**kwargs)
        self.resume_redact = kwargs.get("resume_redact", None)


class ExtractorCreate(msrest.serialization.Model):
    """ExtractorCreate.

    All required parameters must be populated in order to send to Azure.

    :ivar name: Required.
    :vartype name: str
    :ivar name_plural:
    :vartype name_plural: str
    :ivar base_extractor: Uniquely identify an extractor.
    :vartype base_extractor: str
    :ivar organization: Required. Uniquely identify an organization.
    :vartype organization: str
    :ivar category:
    :vartype category: str
    :ivar validatable:
    :vartype validatable: bool
    :ivar field_groups:
    :vartype field_groups: list[~affinda.models.FieldGroup]
    """

    _validation = {
        "name": {"required": True},
        "organization": {"required": True},
    }

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "name_plural": {"key": "namePlural", "type": "str"},
        "base_extractor": {"key": "baseExtractor", "type": "str"},
        "organization": {"key": "organization", "type": "str"},
        "category": {"key": "category", "type": "str"},
        "validatable": {"key": "validatable", "type": "bool"},
        "field_groups": {"key": "fieldGroups", "type": "[FieldGroup]"},
    }

    def __init__(self, **kwargs):
        """
        :keyword name: Required.
        :paramtype name: str
        :keyword name_plural:
        :paramtype name_plural: str
        :keyword base_extractor: Uniquely identify an extractor.
        :paramtype base_extractor: str
        :keyword organization: Required. Uniquely identify an organization.
        :paramtype organization: str
        :keyword category:
        :paramtype category: str
        :keyword validatable:
        :paramtype validatable: bool
        :keyword field_groups:
        :paramtype field_groups: list[~affinda.models.FieldGroup]
        """
        super(ExtractorCreate, self).__init__(**kwargs)
        self.name = kwargs["name"]
        self.name_plural = kwargs.get("name_plural", None)
        self.base_extractor = kwargs.get("base_extractor", None)
        self.organization = kwargs["organization"]
        self.category = kwargs.get("category", None)
        self.validatable = kwargs.get("validatable", None)
        self.field_groups = kwargs.get("field_groups", None)


class ExtractorUpdate(msrest.serialization.Model):
    """ExtractorUpdate.

    :ivar name:
    :vartype name: str
    :ivar name_plural:
    :vartype name_plural: str
    :ivar base_extractor: Uniquely identify an extractor.
    :vartype base_extractor: str
    :ivar category:
    :vartype category: str
    :ivar validatable:
    :vartype validatable: bool
    :ivar field_groups:
    :vartype field_groups: list[~affinda.models.FieldGroup]
    """

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "name_plural": {"key": "namePlural", "type": "str"},
        "base_extractor": {"key": "baseExtractor", "type": "str"},
        "category": {"key": "category", "type": "str"},
        "validatable": {"key": "validatable", "type": "bool"},
        "field_groups": {"key": "fieldGroups", "type": "[FieldGroup]"},
    }

    def __init__(self, **kwargs):
        """
        :keyword name:
        :paramtype name: str
        :keyword name_plural:
        :paramtype name_plural: str
        :keyword base_extractor: Uniquely identify an extractor.
        :paramtype base_extractor: str
        :keyword category:
        :paramtype category: str
        :keyword validatable:
        :paramtype validatable: bool
        :keyword field_groups:
        :paramtype field_groups: list[~affinda.models.FieldGroup]
        """
        super(ExtractorUpdate, self).__init__(**kwargs)
        self.name = kwargs.get("name", None)
        self.name_plural = kwargs.get("name_plural", None)
        self.base_extractor = kwargs.get("base_extractor", None)
        self.category = kwargs.get("category", None)
        self.validatable = kwargs.get("validatable", None)
        self.field_groups = kwargs.get("field_groups", None)


class Field(msrest.serialization.Model):
    """Field.

    All required parameters must be populated in order to send to Azure.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar label: Required.
    :vartype label: str
    :ivar data_point: Required. Data point identifier.
    :vartype data_point: str
    :ivar field_type: Required. The different data types of annotations. Known values are: "text",
     "integer", "float", "decimal", "date", "datetime", "daterange", "boolean", "enum", "location",
     "phonenumber", "json", "table", "expectedremuneration", "jobtitle", "language", "skill",
     "yearsexperience", "group", "table_deprecated", "url", "image".
    :vartype field_type: str or ~affinda.models.AnnotationContentType
    :ivar data_source: Data source mapping identifier.
    :vartype data_source: str
    :ivar mapping: Defines how the data point is mapped to the data source.
    :vartype mapping: str
    :ivar mandatory:
    :vartype mandatory: bool
    :ivar auto_validation_threshold:
    :vartype auto_validation_threshold: float
    :ivar show_dropdown:
    :vartype show_dropdown: bool
    :ivar display_enum_value: If true, both the value and the label for the enums will appear in
     the dropdown in the validation tool.
    :vartype display_enum_value: bool
    :ivar hide_enum_detail: If true, the hoverable enum value detail icon will be hidden.
    :vartype hide_enum_detail: bool
    :ivar drop_null: If True, any dropdown annotations that fail to parse to a value will be
     discarded.
    :vartype drop_null: bool
    :ivar enabled_child_fields:
    :vartype enabled_child_fields: list[~affinda.models.Field]
    :ivar disabled_child_fields:
    :vartype disabled_child_fields: list[~affinda.models.Field]
    :ivar slug:
    :vartype slug: str
    :ivar display_raw_text: If true, then the validation tool will show the user the raw text found
     on the page, not the value that has been parsed to a specific type.
    :vartype display_raw_text: bool
    :ivar fields:
    :vartype fields: list[any]
    """

    _validation = {
        "label": {"required": True},
        "data_point": {"required": True},
        "field_type": {"required": True},
        "auto_validation_threshold": {"maximum": 1, "minimum": 0},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "label": {"key": "label", "type": "str"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "field_type": {"key": "fieldType", "type": "str"},
        "data_source": {"key": "dataSource", "type": "str"},
        "mapping": {"key": "mapping", "type": "str"},
        "mandatory": {"key": "mandatory", "type": "bool"},
        "auto_validation_threshold": {"key": "autoValidationThreshold", "type": "float"},
        "show_dropdown": {"key": "showDropdown", "type": "bool"},
        "display_enum_value": {"key": "displayEnumValue", "type": "bool"},
        "hide_enum_detail": {"key": "hideEnumDetail", "type": "bool"},
        "drop_null": {"key": "dropNull", "type": "bool"},
        "enabled_child_fields": {"key": "enabledChildFields", "type": "[Field]"},
        "disabled_child_fields": {"key": "disabledChildFields", "type": "[Field]"},
        "slug": {"key": "slug", "type": "str"},
        "display_raw_text": {"key": "displayRawText", "type": "bool"},
        "fields": {"key": "fields", "type": "[object]"},
    }

    def __init__(self, **kwargs):
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword label: Required.
        :paramtype label: str
        :keyword data_point: Required. Data point identifier.
        :paramtype data_point: str
        :keyword field_type: Required. The different data types of annotations. Known values are:
         "text", "integer", "float", "decimal", "date", "datetime", "daterange", "boolean", "enum",
         "location", "phonenumber", "json", "table", "expectedremuneration", "jobtitle", "language",
         "skill", "yearsexperience", "group", "table_deprecated", "url", "image".
        :paramtype field_type: str or ~affinda.models.AnnotationContentType
        :keyword data_source: Data source mapping identifier.
        :paramtype data_source: str
        :keyword mapping: Defines how the data point is mapped to the data source.
        :paramtype mapping: str
        :keyword mandatory:
        :paramtype mandatory: bool
        :keyword auto_validation_threshold:
        :paramtype auto_validation_threshold: float
        :keyword show_dropdown:
        :paramtype show_dropdown: bool
        :keyword display_enum_value: If true, both the value and the label for the enums will appear in
         the dropdown in the validation tool.
        :paramtype display_enum_value: bool
        :keyword hide_enum_detail: If true, the hoverable enum value detail icon will be hidden.
        :paramtype hide_enum_detail: bool
        :keyword drop_null: If True, any dropdown annotations that fail to parse to a value will be
         discarded.
        :paramtype drop_null: bool
        :keyword enabled_child_fields:
        :paramtype enabled_child_fields: list[~affinda.models.Field]
        :keyword disabled_child_fields:
        :paramtype disabled_child_fields: list[~affinda.models.Field]
        :keyword slug:
        :paramtype slug: str
        :keyword display_raw_text: If true, then the validation tool will show the user the raw text
         found on the page, not the value that has been parsed to a specific type.
        :paramtype display_raw_text: bool
        :keyword fields:
        :paramtype fields: list[any]
        """
        super(Field, self).__init__(**kwargs)
        self.additional_properties = kwargs.get("additional_properties", None)
        self.label = kwargs["label"]
        self.data_point = kwargs["data_point"]
        self.field_type = kwargs["field_type"]
        self.data_source = kwargs.get("data_source", None)
        self.mapping = kwargs.get("mapping", None)
        self.mandatory = kwargs.get("mandatory", None)
        self.auto_validation_threshold = kwargs.get("auto_validation_threshold", None)
        self.show_dropdown = kwargs.get("show_dropdown", None)
        self.display_enum_value = kwargs.get("display_enum_value", None)
        self.hide_enum_detail = kwargs.get("hide_enum_detail", None)
        self.drop_null = kwargs.get("drop_null", None)
        self.enabled_child_fields = kwargs.get("enabled_child_fields", None)
        self.disabled_child_fields = kwargs.get("disabled_child_fields", None)
        self.slug = kwargs.get("slug", None)
        self.display_raw_text = kwargs.get("display_raw_text", None)
        self.fields = kwargs.get("fields", None)


class FieldCategory(msrest.serialization.Model):
    """FieldCategory.

    All required parameters must be populated in order to send to Azure.

    :ivar label: Required.
    :vartype label: str
    :ivar enabled_fields: Required.
    :vartype enabled_fields: list[~affinda.models.Field]
    :ivar disabled_fields: Required.
    :vartype disabled_fields: list[~affinda.models.Field]
    """

    _validation = {
        "label": {"required": True},
        "enabled_fields": {"required": True},
        "disabled_fields": {"required": True},
    }

    _attribute_map = {
        "label": {"key": "label", "type": "str"},
        "enabled_fields": {"key": "enabledFields", "type": "[Field]"},
        "disabled_fields": {"key": "disabledFields", "type": "[Field]"},
    }

    def __init__(self, **kwargs):
        """
        :keyword label: Required.
        :paramtype label: str
        :keyword enabled_fields: Required.
        :paramtype enabled_fields: list[~affinda.models.Field]
        :keyword disabled_fields: Required.
        :paramtype disabled_fields: list[~affinda.models.Field]
        """
        super(FieldCategory, self).__init__(**kwargs)
        self.label = kwargs["label"]
        self.enabled_fields = kwargs["enabled_fields"]
        self.disabled_fields = kwargs["disabled_fields"]


class FieldDeprecated(msrest.serialization.Model):
    """FieldDeprecated.

    All required parameters must be populated in order to send to Azure.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar label: Required.
    :vartype label: str
    :ivar slug:
    :vartype slug: str
    :ivar field_type: Required. The different data types of annotations. Known values are: "text",
     "integer", "float", "decimal", "date", "datetime", "daterange", "boolean", "enum", "location",
     "phonenumber", "json", "table", "expectedremuneration", "jobtitle", "language", "skill",
     "yearsexperience", "group", "table_deprecated", "url", "image".
    :vartype field_type: str or ~affinda.models.AnnotationContentType
    :ivar data_source: Data source mapping identifier.
    :vartype data_source: str
    :ivar mapping: Defines how the data point is mapped to the data source.
    :vartype mapping: str
    :ivar data_point: Required.
    :vartype data_point: str
    :ivar mandatory:
    :vartype mandatory: bool
    :ivar disabled:
    :vartype disabled: bool
    :ivar auto_validation_threshold:
    :vartype auto_validation_threshold: float
    :ivar show_dropdown:
    :vartype show_dropdown: bool
    :ivar display_raw_text:
    :vartype display_raw_text: bool
    :ivar drop_null: If True, any dropdown annotations that fail to parse to a value will be
     discarded.
    :vartype drop_null: bool
    :ivar display_enum_value:
    :vartype display_enum_value: bool
    :ivar fields:
    :vartype fields: list[~affinda.models.FieldDeprecated]
    """

    _validation = {
        "label": {"required": True},
        "field_type": {"required": True},
        "data_point": {"required": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "label": {"key": "label", "type": "str"},
        "slug": {"key": "slug", "type": "str"},
        "field_type": {"key": "fieldType", "type": "str"},
        "data_source": {"key": "dataSource", "type": "str"},
        "mapping": {"key": "mapping", "type": "str"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "mandatory": {"key": "mandatory", "type": "bool"},
        "disabled": {"key": "disabled", "type": "bool"},
        "auto_validation_threshold": {"key": "autoValidationThreshold", "type": "float"},
        "show_dropdown": {"key": "showDropdown", "type": "bool"},
        "display_raw_text": {"key": "displayRawText", "type": "bool"},
        "drop_null": {"key": "dropNull", "type": "bool"},
        "display_enum_value": {"key": "displayEnumValue", "type": "bool"},
        "fields": {"key": "fields", "type": "[FieldDeprecated]"},
    }

    def __init__(self, **kwargs):
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword label: Required.
        :paramtype label: str
        :keyword slug:
        :paramtype slug: str
        :keyword field_type: Required. The different data types of annotations. Known values are:
         "text", "integer", "float", "decimal", "date", "datetime", "daterange", "boolean", "enum",
         "location", "phonenumber", "json", "table", "expectedremuneration", "jobtitle", "language",
         "skill", "yearsexperience", "group", "table_deprecated", "url", "image".
        :paramtype field_type: str or ~affinda.models.AnnotationContentType
        :keyword data_source: Data source mapping identifier.
        :paramtype data_source: str
        :keyword mapping: Defines how the data point is mapped to the data source.
        :paramtype mapping: str
        :keyword data_point: Required.
        :paramtype data_point: str
        :keyword mandatory:
        :paramtype mandatory: bool
        :keyword disabled:
        :paramtype disabled: bool
        :keyword auto_validation_threshold:
        :paramtype auto_validation_threshold: float
        :keyword show_dropdown:
        :paramtype show_dropdown: bool
        :keyword display_raw_text:
        :paramtype display_raw_text: bool
        :keyword drop_null: If True, any dropdown annotations that fail to parse to a value will be
         discarded.
        :paramtype drop_null: bool
        :keyword display_enum_value:
        :paramtype display_enum_value: bool
        :keyword fields:
        :paramtype fields: list[~affinda.models.FieldDeprecated]
        """
        super(FieldDeprecated, self).__init__(**kwargs)
        self.additional_properties = kwargs.get("additional_properties", None)
        self.label = kwargs["label"]
        self.slug = kwargs.get("slug", None)
        self.field_type = kwargs["field_type"]
        self.data_source = kwargs.get("data_source", None)
        self.mapping = kwargs.get("mapping", None)
        self.data_point = kwargs["data_point"]
        self.mandatory = kwargs.get("mandatory", None)
        self.disabled = kwargs.get("disabled", None)
        self.auto_validation_threshold = kwargs.get("auto_validation_threshold", None)
        self.show_dropdown = kwargs.get("show_dropdown", None)
        self.display_raw_text = kwargs.get("display_raw_text", None)
        self.drop_null = kwargs.get("drop_null", None)
        self.display_enum_value = kwargs.get("display_enum_value", None)
        self.fields = kwargs.get("fields", None)


class FieldGroup(msrest.serialization.Model):
    """FieldGroup.

    All required parameters must be populated in order to send to Azure.

    :ivar label: Required.
    :vartype label: str
    :ivar fields: Required.
    :vartype fields: list[~affinda.models.FieldDeprecated]
    """

    _validation = {
        "label": {"required": True},
        "fields": {"required": True},
    }

    _attribute_map = {
        "label": {"key": "label", "type": "str"},
        "fields": {"key": "fields", "type": "[FieldDeprecated]"},
    }

    def __init__(self, **kwargs):
        """
        :keyword label: Required.
        :paramtype label: str
        :keyword fields: Required.
        :paramtype fields: list[~affinda.models.FieldDeprecated]
        """
        super(FieldGroup, self).__init__(**kwargs)
        self.label = kwargs["label"]
        self.fields = kwargs["fields"]


class FieldsLayout(msrest.serialization.Model):
    """FieldsLayout.

    All required parameters must be populated in order to send to Azure.

    :ivar default_category: Required.
    :vartype default_category: ~affinda.models.FieldCategory
    :ivar categories: Required.
    :vartype categories: list[~affinda.models.FieldCategory]
    """

    _validation = {
        "default_category": {"required": True},
        "categories": {"required": True},
    }

    _attribute_map = {
        "default_category": {"key": "defaultCategory", "type": "FieldCategory"},
        "categories": {"key": "categories", "type": "[FieldCategory]"},
    }

    def __init__(self, **kwargs):
        """
        :keyword default_category: Required.
        :paramtype default_category: ~affinda.models.FieldCategory
        :keyword categories: Required.
        :paramtype categories: list[~affinda.models.FieldCategory]
        """
        super(FieldsLayout, self).__init__(**kwargs)
        self.default_category = kwargs["default_category"]
        self.categories = kwargs["categories"]


class FloatAnnotation(Annotation):
    """FloatAnnotation.

    All required parameters must be populated in order to send to Azure.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id: Required. Annotation's ID.
    :vartype id: int
    :ivar rectangle: Required. x/y coordinates for the rectangular bounding box containing the
     data.
    :vartype rectangle: ~affinda.models.Rectangle
    :ivar rectangles: Required. x/y coordinates for the rectangles containing the data. An
     annotation can be contained within multiple rectangles.
    :vartype rectangles: list[~affinda.models.Rectangle]
    :ivar document: Required. Unique identifier for the document.
    :vartype document: str
    :ivar page_index: Required. The page number within the document, starting from 0.
    :vartype page_index: int
    :ivar raw: Required. Raw data extracted from the before any post-processing.
    :vartype raw: str
    :ivar confidence: Required. The overall confidence that the model's prediction is correct.
    :vartype confidence: float
    :ivar classification_confidence: Required. The model's confidence that the text has been
     classified correctly.
    :vartype classification_confidence: float
    :ivar text_extraction_confidence: Required. If the document was submitted as an image, this is
     the confidence that the text in the image has been correctly read by the model.
    :vartype text_extraction_confidence: float
    :ivar is_verified: Required. Indicates whether the data has been validated, either by a human
     using our validation tool or through auto-validation rules.
    :vartype is_verified: bool
    :ivar is_client_verified: Required. Indicates whether the data has been validated by a human.
    :vartype is_client_verified: bool
    :ivar is_auto_verified: Required. Indicates whether the data has been auto-validated.
    :vartype is_auto_verified: bool
    :ivar data_point: Required. Data point's identifier.
    :vartype data_point: str
    :ivar content_type: Required. The different data types of annotations. Known values are:
     "text", "integer", "float", "decimal", "date", "datetime", "daterange", "boolean", "enum",
     "location", "phonenumber", "json", "table", "expectedremuneration", "jobtitle", "language",
     "skill", "yearsexperience", "group", "table_deprecated", "url", "image".
    :vartype content_type: str or ~affinda.models.AnnotationContentType
    :ivar parent: The parent annotation's ID.
    :vartype parent: int
    :ivar parsed:
    :vartype parsed: float
    """

    _validation = {
        "id": {"required": True, "minimum": 1},
        "rectangle": {"required": True},
        "rectangles": {"required": True},
        "document": {"required": True},
        "page_index": {"required": True, "minimum": 0},
        "raw": {"required": True},
        "confidence": {"required": True},
        "classification_confidence": {"required": True},
        "text_extraction_confidence": {"required": True},
        "is_verified": {"required": True},
        "is_client_verified": {"required": True},
        "is_auto_verified": {"required": True},
        "data_point": {"required": True},
        "content_type": {"required": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "int"},
        "rectangle": {"key": "rectangle", "type": "Rectangle"},
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "document": {"key": "document", "type": "str"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "confidence": {"key": "confidence", "type": "float"},
        "classification_confidence": {"key": "classificationConfidence", "type": "float"},
        "text_extraction_confidence": {"key": "textExtractionConfidence", "type": "float"},
        "is_verified": {"key": "isVerified", "type": "bool"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "is_auto_verified": {"key": "isAutoVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "content_type": {"key": "contentType", "type": "str"},
        "parent": {"key": "parent", "type": "int"},
        "parsed": {"key": "parsed", "type": "float"},
    }

    def __init__(self, **kwargs):
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword id: Required. Annotation's ID.
        :paramtype id: int
        :keyword rectangle: Required. x/y coordinates for the rectangular bounding box containing the
         data.
        :paramtype rectangle: ~affinda.models.Rectangle
        :keyword rectangles: Required. x/y coordinates for the rectangles containing the data. An
         annotation can be contained within multiple rectangles.
        :paramtype rectangles: list[~affinda.models.Rectangle]
        :keyword document: Required. Unique identifier for the document.
        :paramtype document: str
        :keyword page_index: Required. The page number within the document, starting from 0.
        :paramtype page_index: int
        :keyword raw: Required. Raw data extracted from the before any post-processing.
        :paramtype raw: str
        :keyword confidence: Required. The overall confidence that the model's prediction is correct.
        :paramtype confidence: float
        :keyword classification_confidence: Required. The model's confidence that the text has been
         classified correctly.
        :paramtype classification_confidence: float
        :keyword text_extraction_confidence: Required. If the document was submitted as an image, this
         is the confidence that the text in the image has been correctly read by the model.
        :paramtype text_extraction_confidence: float
        :keyword is_verified: Required. Indicates whether the data has been validated, either by a
         human using our validation tool or through auto-validation rules.
        :paramtype is_verified: bool
        :keyword is_client_verified: Required. Indicates whether the data has been validated by a
         human.
        :paramtype is_client_verified: bool
        :keyword is_auto_verified: Required. Indicates whether the data has been auto-validated.
        :paramtype is_auto_verified: bool
        :keyword data_point: Required. Data point's identifier.
        :paramtype data_point: str
        :keyword content_type: Required. The different data types of annotations. Known values are:
         "text", "integer", "float", "decimal", "date", "datetime", "daterange", "boolean", "enum",
         "location", "phonenumber", "json", "table", "expectedremuneration", "jobtitle", "language",
         "skill", "yearsexperience", "group", "table_deprecated", "url", "image".
        :paramtype content_type: str or ~affinda.models.AnnotationContentType
        :keyword parent: The parent annotation's ID.
        :paramtype parent: int
        :keyword parsed:
        :paramtype parsed: float
        """
        super(FloatAnnotation, self).__init__(**kwargs)
        self.parsed = kwargs.get("parsed", None)


class Get200ApplicationJsonPropertiesItemsItem(msrest.serialization.Model):
    """Get200ApplicationJsonPropertiesItemsItem.

    :ivar document:
    :vartype document: str
    """

    _attribute_map = {
        "document": {"key": "document", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword document:
        :paramtype document: str
        """
        super(Get200ApplicationJsonPropertiesItemsItem, self).__init__(**kwargs)
        self.document = kwargs.get("document", None)


class Index(msrest.serialization.Model):
    """Index.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar name: Required. Unique index name.
    :vartype name: str
    :ivar document_type: Required. Known values are: "resumes", "job_descriptions".
    :vartype document_type: str or ~affinda.models.IndexDocumentType
    :ivar user: Required. The user who created this index.
    :vartype user: ~affinda.models.IndexUser
    """

    _validation = {
        "name": {"required": True},
        "document_type": {"required": True},
        "user": {"required": True, "readonly": True},
    }

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "document_type": {"key": "documentType", "type": "str"},
        "user": {"key": "user", "type": "IndexUser"},
    }

    def __init__(self, **kwargs):
        """
        :keyword name: Required. Unique index name.
        :paramtype name: str
        :keyword document_type: Required. Known values are: "resumes", "job_descriptions".
        :paramtype document_type: str or ~affinda.models.IndexDocumentType
        """
        super(Index, self).__init__(**kwargs)
        self.name = kwargs["name"]
        self.document_type = kwargs["document_type"]
        self.user = None


class IndexCreate(msrest.serialization.Model):
    """IndexRequestBody.

    All required parameters must be populated in order to send to Azure.

    :ivar name: Required. Unique index name.
    :vartype name: str
    :ivar document_type: Known values are: "resumes", "job_descriptions".
    :vartype document_type: str or ~affinda.models.DocumentType
    """

    _validation = {
        "name": {"required": True},
    }

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "document_type": {"key": "documentType", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword name: Required. Unique index name.
        :paramtype name: str
        :keyword document_type: Known values are: "resumes", "job_descriptions".
        :paramtype document_type: str or ~affinda.models.DocumentType
        """
        super(IndexCreate, self).__init__(**kwargs)
        self.name = kwargs["name"]
        self.document_type = kwargs.get("document_type", None)


class IndexUpdate(msrest.serialization.Model):
    """IndexUpdate.

    :ivar name: Unique index name.
    :vartype name: str
    """

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword name: Unique index name.
        :paramtype name: str
        """
        super(IndexUpdate, self).__init__(**kwargs)
        self.name = kwargs.get("name", None)


class IndexUser(msrest.serialization.Model):
    """The user who created this index.

    All required parameters must be populated in order to send to Azure.

    :ivar id: Required. Uniquely identify a user.
    :vartype id: int
    :ivar name: Required.
    :vartype name: str
    :ivar email: Required.
    :vartype email: str
    :ivar avatar: Required. URL of the user's avatar.
    :vartype avatar: str
    """

    _validation = {
        "id": {"required": True, "minimum": 1},
        "name": {"required": True},
        "email": {"required": True},
        "avatar": {"required": True},
    }

    _attribute_map = {
        "id": {"key": "id", "type": "int"},
        "name": {"key": "name", "type": "str"},
        "email": {"key": "email", "type": "str"},
        "avatar": {"key": "avatar", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword id: Required. Uniquely identify a user.
        :paramtype id: int
        :keyword name: Required.
        :paramtype name: str
        :keyword email: Required.
        :paramtype email: str
        :keyword avatar: Required. URL of the user's avatar.
        :paramtype avatar: str
        """
        super(IndexUser, self).__init__(**kwargs)
        self.id = kwargs["id"]
        self.name = kwargs["name"]
        self.email = kwargs["email"]
        self.avatar = kwargs["avatar"]


class Invitation(msrest.serialization.Model):
    """Invitation.

    :ivar identifier: Uniquely identify an invitation.
    :vartype identifier: str
    :ivar organization:
    :vartype organization: ~affinda.models.Organization
    :ivar email: The email which the invitation is sent to.
    :vartype email: str
    :ivar role: Known values are: "admin", "member".
    :vartype role: str or ~affinda.models.OrganizationRole
    :ivar status: Known values are: "pending", "accepted", "declined".
    :vartype status: str or ~affinda.models.InvitationStatus
    :ivar expiry_date: The date after which the invitation expires. Default is 10 days from now.
    :vartype expiry_date: ~datetime.date
    :ivar invited_by:
    :vartype invited_by: ~affinda.models.User
    :ivar responded_by:
    :vartype responded_by: ~affinda.models.InvitationRespondedBy
    :ivar created_dt:
    :vartype created_dt: ~datetime.datetime
    """

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
        "organization": {"key": "organization", "type": "Organization"},
        "email": {"key": "email", "type": "str"},
        "role": {"key": "role", "type": "str"},
        "status": {"key": "status", "type": "str"},
        "expiry_date": {"key": "expiryDate", "type": "date"},
        "invited_by": {"key": "invitedBy", "type": "User"},
        "responded_by": {"key": "respondedBy", "type": "InvitationRespondedBy"},
        "created_dt": {"key": "createdDt", "type": "iso-8601"},
    }

    def __init__(self, **kwargs):
        """
        :keyword identifier: Uniquely identify an invitation.
        :paramtype identifier: str
        :keyword organization:
        :paramtype organization: ~affinda.models.Organization
        :keyword email: The email which the invitation is sent to.
        :paramtype email: str
        :keyword role: Known values are: "admin", "member".
        :paramtype role: str or ~affinda.models.OrganizationRole
        :keyword status: Known values are: "pending", "accepted", "declined".
        :paramtype status: str or ~affinda.models.InvitationStatus
        :keyword expiry_date: The date after which the invitation expires. Default is 10 days from now.
        :paramtype expiry_date: ~datetime.date
        :keyword invited_by:
        :paramtype invited_by: ~affinda.models.User
        :keyword responded_by:
        :paramtype responded_by: ~affinda.models.InvitationRespondedBy
        :keyword created_dt:
        :paramtype created_dt: ~datetime.datetime
        """
        super(Invitation, self).__init__(**kwargs)
        self.identifier = kwargs.get("identifier", None)
        self.organization = kwargs.get("organization", None)
        self.email = kwargs.get("email", None)
        self.role = kwargs.get("role", None)
        self.status = kwargs.get("status", None)
        self.expiry_date = kwargs.get("expiry_date", None)
        self.invited_by = kwargs.get("invited_by", None)
        self.responded_by = kwargs.get("responded_by", None)
        self.created_dt = kwargs.get("created_dt", None)


class InvitationCreate(msrest.serialization.Model):
    """InvitationCreate.

    All required parameters must be populated in order to send to Azure.

    :ivar organization: Required. Uniquely identify an organization.
    :vartype organization: str
    :ivar email: Required. The email which the invitation is sent to.
    :vartype email: str
    :ivar role: Required. Known values are: "admin", "member".
    :vartype role: str or ~affinda.models.OrganizationRole
    """

    _validation = {
        "organization": {"required": True},
        "email": {"required": True},
        "role": {"required": True},
    }

    _attribute_map = {
        "organization": {"key": "organization", "type": "str"},
        "email": {"key": "email", "type": "str"},
        "role": {"key": "role", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword organization: Required. Uniquely identify an organization.
        :paramtype organization: str
        :keyword email: Required. The email which the invitation is sent to.
        :paramtype email: str
        :keyword role: Required. Known values are: "admin", "member".
        :paramtype role: str or ~affinda.models.OrganizationRole
        """
        super(InvitationCreate, self).__init__(**kwargs)
        self.organization = kwargs["organization"]
        self.email = kwargs["email"]
        self.role = kwargs["role"]


class User(msrest.serialization.Model):
    """User.

    :ivar id: Uniquely identify a user.
    :vartype id: int
    :ivar name:
    :vartype name: str
    :ivar username:
    :vartype username: str
    :ivar email:
    :vartype email: str
    :ivar avatar: URL of the user's avatar.
    :vartype avatar: str
    """

    _validation = {
        "id": {"minimum": 1},
    }

    _attribute_map = {
        "id": {"key": "id", "type": "int"},
        "name": {"key": "name", "type": "str"},
        "username": {"key": "username", "type": "str"},
        "email": {"key": "email", "type": "str"},
        "avatar": {"key": "avatar", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword id: Uniquely identify a user.
        :paramtype id: int
        :keyword name:
        :paramtype name: str
        :keyword username:
        :paramtype username: str
        :keyword email:
        :paramtype email: str
        :keyword avatar: URL of the user's avatar.
        :paramtype avatar: str
        """
        super(User, self).__init__(**kwargs)
        self.id = kwargs.get("id", None)
        self.name = kwargs.get("name", None)
        self.username = kwargs.get("username", None)
        self.email = kwargs.get("email", None)
        self.avatar = kwargs.get("avatar", None)


class InvitationRespondedBy(User):
    """InvitationRespondedBy.

    :ivar id: Uniquely identify a user.
    :vartype id: int
    :ivar name:
    :vartype name: str
    :ivar username:
    :vartype username: str
    :ivar email:
    :vartype email: str
    :ivar avatar: URL of the user's avatar.
    :vartype avatar: str
    """

    _validation = {
        "id": {"minimum": 1},
    }

    _attribute_map = {
        "id": {"key": "id", "type": "int"},
        "name": {"key": "name", "type": "str"},
        "username": {"key": "username", "type": "str"},
        "email": {"key": "email", "type": "str"},
        "avatar": {"key": "avatar", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword id: Uniquely identify a user.
        :paramtype id: int
        :keyword name:
        :paramtype name: str
        :keyword username:
        :paramtype username: str
        :keyword email:
        :paramtype email: str
        :keyword avatar: URL of the user's avatar.
        :paramtype avatar: str
        """
        super(InvitationRespondedBy, self).__init__(**kwargs)


class InvitationResponse(msrest.serialization.Model):
    """InvitationResponse.

    :ivar status: Known values are: "accepted", "declined".
    :vartype status: str or ~affinda.models.InvitationResponseStatus
    """

    _attribute_map = {
        "status": {"key": "status", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword status: Known values are: "accepted", "declined".
        :paramtype status: str or ~affinda.models.InvitationResponseStatus
        """
        super(InvitationResponse, self).__init__(**kwargs)
        self.status = kwargs.get("status", None)


class InvitationUpdate(msrest.serialization.Model):
    """InvitationUpdate.

    :ivar role: Known values are: "admin", "member".
    :vartype role: str or ~affinda.models.OrganizationRole
    """

    _attribute_map = {
        "role": {"key": "role", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword role: Known values are: "admin", "member".
        :paramtype role: str or ~affinda.models.OrganizationRole
        """
        super(InvitationUpdate, self).__init__(**kwargs)
        self.role = kwargs.get("role", None)


class Invoice(Document):
    """Invoice.

    All required parameters must be populated in order to send to Azure.

    :ivar extractor: Required. Constant filled by server.
    :vartype extractor: str
    :ivar meta: Required.
    :vartype meta: ~affinda.models.DocumentMeta
    :ivar error:
    :vartype error: ~affinda.models.DocumentError
    :ivar warnings:
    :vartype warnings: list[~affinda.models.DocumentWarning]
    :ivar data:
    :vartype data: ~affinda.models.InvoiceData
    """

    _validation = {
        "extractor": {"required": True},
        "meta": {"required": True},
    }

    _attribute_map = {
        "extractor": {"key": "extractor", "type": "str"},
        "meta": {"key": "meta", "type": "DocumentMeta"},
        "error": {"key": "error", "type": "DocumentError"},
        "warnings": {"key": "warnings", "type": "[DocumentWarning]"},
        "data": {"key": "data", "type": "InvoiceData"},
    }

    def __init__(self, **kwargs):
        """
        :keyword meta: Required.
        :paramtype meta: ~affinda.models.DocumentMeta
        :keyword error:
        :paramtype error: ~affinda.models.DocumentError
        :keyword warnings:
        :paramtype warnings: list[~affinda.models.DocumentWarning]
        :keyword data:
        :paramtype data: ~affinda.models.InvoiceData
        """
        super(Invoice, self).__init__(**kwargs)
        self.extractor = "invoice"  # type: str
        self.data = kwargs.get("data", None)


class InvoiceData(msrest.serialization.Model):
    """InvoiceData.

    :ivar tables:
    :vartype tables: list[~affinda.models.TableAnnotation]
    :ivar tables_beta:
    :vartype tables_beta: list[~affinda.models.TableBetaAnnotation]
    :ivar invoice_date:
    :vartype invoice_date: ~affinda.models.DateAnnotation
    :ivar invoice_order_date:
    :vartype invoice_order_date: ~affinda.models.DateAnnotation
    :ivar payment_date_due:
    :vartype payment_date_due: ~affinda.models.DateAnnotation
    :ivar payment_amount_base:
    :vartype payment_amount_base: ~affinda.models.TextAnnotation
    :ivar payment_amount_tax:
    :vartype payment_amount_tax: ~affinda.models.TextAnnotation
    :ivar payment_amount_total:
    :vartype payment_amount_total: ~affinda.models.TextAnnotation
    :ivar payment_amount_paid:
    :vartype payment_amount_paid: ~affinda.models.TextAnnotation
    :ivar payment_amount_due:
    :vartype payment_amount_due: ~affinda.models.TextAnnotation
    :ivar invoice_number:
    :vartype invoice_number: ~affinda.models.TextAnnotation
    :ivar invoice_purchase_order_number:
    :vartype invoice_purchase_order_number: ~affinda.models.TextAnnotation
    :ivar supplier_business_number:
    :vartype supplier_business_number: ~affinda.models.TextAnnotation
    :ivar customer_number:
    :vartype customer_number: ~affinda.models.TextAnnotation
    :ivar customer_business_number:
    :vartype customer_business_number: ~affinda.models.TextAnnotation
    :ivar payment_reference:
    :vartype payment_reference: ~affinda.models.TextAnnotation
    :ivar bank_account_number:
    :vartype bank_account_number: ~affinda.models.TextAnnotation
    :ivar supplier_vat:
    :vartype supplier_vat: ~affinda.models.TextAnnotation
    :ivar customer_vat:
    :vartype customer_vat: ~affinda.models.TextAnnotation
    :ivar bpay_biller_code:
    :vartype bpay_biller_code: ~affinda.models.TextAnnotation
    :ivar bpay_reference:
    :vartype bpay_reference: ~affinda.models.TextAnnotation
    :ivar bank_sort_code:
    :vartype bank_sort_code: ~affinda.models.TextAnnotation
    :ivar bank_iban:
    :vartype bank_iban: ~affinda.models.TextAnnotation
    :ivar bank_swift:
    :vartype bank_swift: ~affinda.models.TextAnnotation
    :ivar bank_bsb:
    :vartype bank_bsb: ~affinda.models.TextAnnotation
    :ivar customer_contact_name:
    :vartype customer_contact_name: ~affinda.models.TextAnnotation
    :ivar customer_company_name:
    :vartype customer_company_name: ~affinda.models.TextAnnotation
    :ivar supplier_company_name:
    :vartype supplier_company_name: ~affinda.models.TextAnnotation
    :ivar customer_billing_address:
    :vartype customer_billing_address: ~affinda.models.LocationAnnotation
    :ivar customer_delivery_address:
    :vartype customer_delivery_address: ~affinda.models.LocationAnnotation
    :ivar supplier_address:
    :vartype supplier_address: ~affinda.models.LocationAnnotation
    :ivar customer_phone_number:
    :vartype customer_phone_number: ~affinda.models.TextAnnotation
    :ivar supplier_phone_number:
    :vartype supplier_phone_number: ~affinda.models.TextAnnotation
    :ivar supplier_fax:
    :vartype supplier_fax: ~affinda.models.TextAnnotation
    :ivar customer_email:
    :vartype customer_email: ~affinda.models.TextAnnotation
    :ivar supplier_email:
    :vartype supplier_email: ~affinda.models.TextAnnotation
    :ivar supplier_website:
    :vartype supplier_website: ~affinda.models.TextAnnotation
    :ivar currency_code:
    :vartype currency_code: ~affinda.models.CurrencyCodeAnnotation
    :ivar custom_fields: Dictionary of :code:`<any>`.
    :vartype custom_fields: dict[str, any]
    :ivar raw_text: All of the raw text of the parsed invoice.
    :vartype raw_text: str
    """

    _attribute_map = {
        "tables": {"key": "tables", "type": "[TableAnnotation]"},
        "tables_beta": {"key": "tablesBeta", "type": "[TableBetaAnnotation]"},
        "invoice_date": {"key": "invoiceDate", "type": "DateAnnotation"},
        "invoice_order_date": {"key": "invoiceOrderDate", "type": "DateAnnotation"},
        "payment_date_due": {"key": "paymentDateDue", "type": "DateAnnotation"},
        "payment_amount_base": {"key": "paymentAmountBase", "type": "TextAnnotation"},
        "payment_amount_tax": {"key": "paymentAmountTax", "type": "TextAnnotation"},
        "payment_amount_total": {"key": "paymentAmountTotal", "type": "TextAnnotation"},
        "payment_amount_paid": {"key": "paymentAmountPaid", "type": "TextAnnotation"},
        "payment_amount_due": {"key": "paymentAmountDue", "type": "TextAnnotation"},
        "invoice_number": {"key": "invoiceNumber", "type": "TextAnnotation"},
        "invoice_purchase_order_number": {
            "key": "invoicePurchaseOrderNumber",
            "type": "TextAnnotation",
        },
        "supplier_business_number": {"key": "supplierBusinessNumber", "type": "TextAnnotation"},
        "customer_number": {"key": "customerNumber", "type": "TextAnnotation"},
        "customer_business_number": {"key": "customerBusinessNumber", "type": "TextAnnotation"},
        "payment_reference": {"key": "paymentReference", "type": "TextAnnotation"},
        "bank_account_number": {"key": "bankAccountNumber", "type": "TextAnnotation"},
        "supplier_vat": {"key": "supplierVat", "type": "TextAnnotation"},
        "customer_vat": {"key": "customerVat", "type": "TextAnnotation"},
        "bpay_biller_code": {"key": "bpayBillerCode", "type": "TextAnnotation"},
        "bpay_reference": {"key": "bpayReference", "type": "TextAnnotation"},
        "bank_sort_code": {"key": "bankSortCode", "type": "TextAnnotation"},
        "bank_iban": {"key": "bankIban", "type": "TextAnnotation"},
        "bank_swift": {"key": "bankSwift", "type": "TextAnnotation"},
        "bank_bsb": {"key": "bankBsb", "type": "TextAnnotation"},
        "customer_contact_name": {"key": "customerContactName", "type": "TextAnnotation"},
        "customer_company_name": {"key": "customerCompanyName", "type": "TextAnnotation"},
        "supplier_company_name": {"key": "supplierCompanyName", "type": "TextAnnotation"},
        "customer_billing_address": {
            "key": "customerBillingAddress",
            "type": "LocationAnnotation",
        },
        "customer_delivery_address": {
            "key": "customerDeliveryAddress",
            "type": "LocationAnnotation",
        },
        "supplier_address": {"key": "supplierAddress", "type": "LocationAnnotation"},
        "customer_phone_number": {"key": "customerPhoneNumber", "type": "TextAnnotation"},
        "supplier_phone_number": {"key": "supplierPhoneNumber", "type": "TextAnnotation"},
        "supplier_fax": {"key": "supplierFax", "type": "TextAnnotation"},
        "customer_email": {"key": "customerEmail", "type": "TextAnnotation"},
        "supplier_email": {"key": "supplierEmail", "type": "TextAnnotation"},
        "supplier_website": {"key": "supplierWebsite", "type": "TextAnnotation"},
        "currency_code": {"key": "currencyCode", "type": "CurrencyCodeAnnotation"},
        "custom_fields": {"key": "customFields", "type": "{object}"},
        "raw_text": {"key": "rawText", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword tables:
        :paramtype tables: list[~affinda.models.TableAnnotation]
        :keyword tables_beta:
        :paramtype tables_beta: list[~affinda.models.TableBetaAnnotation]
        :keyword invoice_date:
        :paramtype invoice_date: ~affinda.models.DateAnnotation
        :keyword invoice_order_date:
        :paramtype invoice_order_date: ~affinda.models.DateAnnotation
        :keyword payment_date_due:
        :paramtype payment_date_due: ~affinda.models.DateAnnotation
        :keyword payment_amount_base:
        :paramtype payment_amount_base: ~affinda.models.TextAnnotation
        :keyword payment_amount_tax:
        :paramtype payment_amount_tax: ~affinda.models.TextAnnotation
        :keyword payment_amount_total:
        :paramtype payment_amount_total: ~affinda.models.TextAnnotation
        :keyword payment_amount_paid:
        :paramtype payment_amount_paid: ~affinda.models.TextAnnotation
        :keyword payment_amount_due:
        :paramtype payment_amount_due: ~affinda.models.TextAnnotation
        :keyword invoice_number:
        :paramtype invoice_number: ~affinda.models.TextAnnotation
        :keyword invoice_purchase_order_number:
        :paramtype invoice_purchase_order_number: ~affinda.models.TextAnnotation
        :keyword supplier_business_number:
        :paramtype supplier_business_number: ~affinda.models.TextAnnotation
        :keyword customer_number:
        :paramtype customer_number: ~affinda.models.TextAnnotation
        :keyword customer_business_number:
        :paramtype customer_business_number: ~affinda.models.TextAnnotation
        :keyword payment_reference:
        :paramtype payment_reference: ~affinda.models.TextAnnotation
        :keyword bank_account_number:
        :paramtype bank_account_number: ~affinda.models.TextAnnotation
        :keyword supplier_vat:
        :paramtype supplier_vat: ~affinda.models.TextAnnotation
        :keyword customer_vat:
        :paramtype customer_vat: ~affinda.models.TextAnnotation
        :keyword bpay_biller_code:
        :paramtype bpay_biller_code: ~affinda.models.TextAnnotation
        :keyword bpay_reference:
        :paramtype bpay_reference: ~affinda.models.TextAnnotation
        :keyword bank_sort_code:
        :paramtype bank_sort_code: ~affinda.models.TextAnnotation
        :keyword bank_iban:
        :paramtype bank_iban: ~affinda.models.TextAnnotation
        :keyword bank_swift:
        :paramtype bank_swift: ~affinda.models.TextAnnotation
        :keyword bank_bsb:
        :paramtype bank_bsb: ~affinda.models.TextAnnotation
        :keyword customer_contact_name:
        :paramtype customer_contact_name: ~affinda.models.TextAnnotation
        :keyword customer_company_name:
        :paramtype customer_company_name: ~affinda.models.TextAnnotation
        :keyword supplier_company_name:
        :paramtype supplier_company_name: ~affinda.models.TextAnnotation
        :keyword customer_billing_address:
        :paramtype customer_billing_address: ~affinda.models.LocationAnnotation
        :keyword customer_delivery_address:
        :paramtype customer_delivery_address: ~affinda.models.LocationAnnotation
        :keyword supplier_address:
        :paramtype supplier_address: ~affinda.models.LocationAnnotation
        :keyword customer_phone_number:
        :paramtype customer_phone_number: ~affinda.models.TextAnnotation
        :keyword supplier_phone_number:
        :paramtype supplier_phone_number: ~affinda.models.TextAnnotation
        :keyword supplier_fax:
        :paramtype supplier_fax: ~affinda.models.TextAnnotation
        :keyword customer_email:
        :paramtype customer_email: ~affinda.models.TextAnnotation
        :keyword supplier_email:
        :paramtype supplier_email: ~affinda.models.TextAnnotation
        :keyword supplier_website:
        :paramtype supplier_website: ~affinda.models.TextAnnotation
        :keyword currency_code:
        :paramtype currency_code: ~affinda.models.CurrencyCodeAnnotation
        :keyword custom_fields: Dictionary of :code:`<any>`.
        :paramtype custom_fields: dict[str, any]
        :keyword raw_text: All of the raw text of the parsed invoice.
        :paramtype raw_text: str
        """
        super(InvoiceData, self).__init__(**kwargs)
        self.tables = kwargs.get("tables", None)
        self.tables_beta = kwargs.get("tables_beta", None)
        self.invoice_date = kwargs.get("invoice_date", None)
        self.invoice_order_date = kwargs.get("invoice_order_date", None)
        self.payment_date_due = kwargs.get("payment_date_due", None)
        self.payment_amount_base = kwargs.get("payment_amount_base", None)
        self.payment_amount_tax = kwargs.get("payment_amount_tax", None)
        self.payment_amount_total = kwargs.get("payment_amount_total", None)
        self.payment_amount_paid = kwargs.get("payment_amount_paid", None)
        self.payment_amount_due = kwargs.get("payment_amount_due", None)
        self.invoice_number = kwargs.get("invoice_number", None)
        self.invoice_purchase_order_number = kwargs.get("invoice_purchase_order_number", None)
        self.supplier_business_number = kwargs.get("supplier_business_number", None)
        self.customer_number = kwargs.get("customer_number", None)
        self.customer_business_number = kwargs.get("customer_business_number", None)
        self.payment_reference = kwargs.get("payment_reference", None)
        self.bank_account_number = kwargs.get("bank_account_number", None)
        self.supplier_vat = kwargs.get("supplier_vat", None)
        self.customer_vat = kwargs.get("customer_vat", None)
        self.bpay_biller_code = kwargs.get("bpay_biller_code", None)
        self.bpay_reference = kwargs.get("bpay_reference", None)
        self.bank_sort_code = kwargs.get("bank_sort_code", None)
        self.bank_iban = kwargs.get("bank_iban", None)
        self.bank_swift = kwargs.get("bank_swift", None)
        self.bank_bsb = kwargs.get("bank_bsb", None)
        self.customer_contact_name = kwargs.get("customer_contact_name", None)
        self.customer_company_name = kwargs.get("customer_company_name", None)
        self.supplier_company_name = kwargs.get("supplier_company_name", None)
        self.customer_billing_address = kwargs.get("customer_billing_address", None)
        self.customer_delivery_address = kwargs.get("customer_delivery_address", None)
        self.supplier_address = kwargs.get("supplier_address", None)
        self.customer_phone_number = kwargs.get("customer_phone_number", None)
        self.supplier_phone_number = kwargs.get("supplier_phone_number", None)
        self.supplier_fax = kwargs.get("supplier_fax", None)
        self.customer_email = kwargs.get("customer_email", None)
        self.supplier_email = kwargs.get("supplier_email", None)
        self.supplier_website = kwargs.get("supplier_website", None)
        self.currency_code = kwargs.get("currency_code", None)
        self.custom_fields = kwargs.get("custom_fields", None)
        self.raw_text = kwargs.get("raw_text", None)


class JobDescription(Document):
    """JobDescription.

    All required parameters must be populated in order to send to Azure.

    :ivar extractor: Required. Constant filled by server.
    :vartype extractor: str
    :ivar meta: Required.
    :vartype meta: ~affinda.models.DocumentMeta
    :ivar error:
    :vartype error: ~affinda.models.DocumentError
    :ivar warnings:
    :vartype warnings: list[~affinda.models.DocumentWarning]
    :ivar data:
    :vartype data: ~affinda.models.JobDescriptionData
    """

    _validation = {
        "extractor": {"required": True},
        "meta": {"required": True},
    }

    _attribute_map = {
        "extractor": {"key": "extractor", "type": "str"},
        "meta": {"key": "meta", "type": "DocumentMeta"},
        "error": {"key": "error", "type": "DocumentError"},
        "warnings": {"key": "warnings", "type": "[DocumentWarning]"},
        "data": {"key": "data", "type": "JobDescriptionData"},
    }

    def __init__(self, **kwargs):
        """
        :keyword meta: Required.
        :paramtype meta: ~affinda.models.DocumentMeta
        :keyword error:
        :paramtype error: ~affinda.models.DocumentError
        :keyword warnings:
        :paramtype warnings: list[~affinda.models.DocumentWarning]
        :keyword data:
        :paramtype data: ~affinda.models.JobDescriptionData
        """
        super(JobDescription, self).__init__(**kwargs)
        self.extractor = "job-description"  # type: str
        self.data = kwargs.get("data", None)


class JobDescriptionData(msrest.serialization.Model):
    """JobDescriptionData.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar job_title:
    :vartype job_title: ~affinda.models.JobTitleAnnotation
    :ivar contact_email:
    :vartype contact_email: ~affinda.models.TextAnnotation
    :ivar contact_name:
    :vartype contact_name: ~affinda.models.TextAnnotation
    :ivar contact_phone:
    :vartype contact_phone: ~affinda.models.TextAnnotation
    :ivar start_date:
    :vartype start_date: ~affinda.models.DateAnnotation
    :ivar end_date:
    :vartype end_date: ~affinda.models.DateAnnotation
    :ivar job_type:
    :vartype job_type: ~affinda.models.TextAnnotation
    :ivar languages:
    :vartype languages: list[~affinda.models.LanguageAnnotation]
    :ivar skills:
    :vartype skills: list[~affinda.models.SkillAnnotation]
    :ivar organization_name:
    :vartype organization_name: ~affinda.models.TextAnnotation
    :ivar organization_website:
    :vartype organization_website: ~affinda.models.TextAnnotation
    :ivar education_level:
    :vartype education_level: ~affinda.models.TextAnnotation
    :ivar education_accreditation:
    :vartype education_accreditation: ~affinda.models.TextAnnotation
    :ivar expected_remuneration:
    :vartype expected_remuneration: ~affinda.models.ExpectedRemunerationAnnotation
    :ivar location:
    :vartype location: ~affinda.models.LocationAnnotation
    :ivar certifications:
    :vartype certifications: list[~affinda.models.TextAnnotation]
    :ivar years_experience:
    :vartype years_experience: ~affinda.models.YearsExperienceAnnotation
    :ivar raw_text: All of the raw text of the parsed job description, example is shortened for
     readability.
    :vartype raw_text: str
    """

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "job_title": {"key": "jobTitle", "type": "JobTitleAnnotation"},
        "contact_email": {"key": "contactEmail", "type": "TextAnnotation"},
        "contact_name": {"key": "contactName", "type": "TextAnnotation"},
        "contact_phone": {"key": "contactPhone", "type": "TextAnnotation"},
        "start_date": {"key": "startDate", "type": "DateAnnotation"},
        "end_date": {"key": "endDate", "type": "DateAnnotation"},
        "job_type": {"key": "jobType", "type": "TextAnnotation"},
        "languages": {"key": "languages", "type": "[LanguageAnnotation]"},
        "skills": {"key": "skills", "type": "[SkillAnnotation]"},
        "organization_name": {"key": "organizationName", "type": "TextAnnotation"},
        "organization_website": {"key": "organizationWebsite", "type": "TextAnnotation"},
        "education_level": {"key": "educationLevel", "type": "TextAnnotation"},
        "education_accreditation": {"key": "educationAccreditation", "type": "TextAnnotation"},
        "expected_remuneration": {
            "key": "expectedRemuneration",
            "type": "ExpectedRemunerationAnnotation",
        },
        "location": {"key": "location", "type": "LocationAnnotation"},
        "certifications": {"key": "certifications", "type": "[TextAnnotation]"},
        "years_experience": {"key": "yearsExperience", "type": "YearsExperienceAnnotation"},
        "raw_text": {"key": "rawText", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword job_title:
        :paramtype job_title: ~affinda.models.JobTitleAnnotation
        :keyword contact_email:
        :paramtype contact_email: ~affinda.models.TextAnnotation
        :keyword contact_name:
        :paramtype contact_name: ~affinda.models.TextAnnotation
        :keyword contact_phone:
        :paramtype contact_phone: ~affinda.models.TextAnnotation
        :keyword start_date:
        :paramtype start_date: ~affinda.models.DateAnnotation
        :keyword end_date:
        :paramtype end_date: ~affinda.models.DateAnnotation
        :keyword job_type:
        :paramtype job_type: ~affinda.models.TextAnnotation
        :keyword languages:
        :paramtype languages: list[~affinda.models.LanguageAnnotation]
        :keyword skills:
        :paramtype skills: list[~affinda.models.SkillAnnotation]
        :keyword organization_name:
        :paramtype organization_name: ~affinda.models.TextAnnotation
        :keyword organization_website:
        :paramtype organization_website: ~affinda.models.TextAnnotation
        :keyword education_level:
        :paramtype education_level: ~affinda.models.TextAnnotation
        :keyword education_accreditation:
        :paramtype education_accreditation: ~affinda.models.TextAnnotation
        :keyword expected_remuneration:
        :paramtype expected_remuneration: ~affinda.models.ExpectedRemunerationAnnotation
        :keyword location:
        :paramtype location: ~affinda.models.LocationAnnotation
        :keyword certifications:
        :paramtype certifications: list[~affinda.models.TextAnnotation]
        :keyword years_experience:
        :paramtype years_experience: ~affinda.models.YearsExperienceAnnotation
        :keyword raw_text: All of the raw text of the parsed job description, example is shortened for
         readability.
        :paramtype raw_text: str
        """
        super(JobDescriptionData, self).__init__(**kwargs)
        self.additional_properties = kwargs.get("additional_properties", None)
        self.job_title = kwargs.get("job_title", None)
        self.contact_email = kwargs.get("contact_email", None)
        self.contact_name = kwargs.get("contact_name", None)
        self.contact_phone = kwargs.get("contact_phone", None)
        self.start_date = kwargs.get("start_date", None)
        self.end_date = kwargs.get("end_date", None)
        self.job_type = kwargs.get("job_type", None)
        self.languages = kwargs.get("languages", None)
        self.skills = kwargs.get("skills", None)
        self.organization_name = kwargs.get("organization_name", None)
        self.organization_website = kwargs.get("organization_website", None)
        self.education_level = kwargs.get("education_level", None)
        self.education_accreditation = kwargs.get("education_accreditation", None)
        self.expected_remuneration = kwargs.get("expected_remuneration", None)
        self.location = kwargs.get("location", None)
        self.certifications = kwargs.get("certifications", None)
        self.years_experience = kwargs.get("years_experience", None)
        self.raw_text = kwargs.get("raw_text", None)


class JobDescriptionDataUpdate(msrest.serialization.Model):
    """A JSON-encoded string of the ``JobDescriptionData`` object.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar job_title:
    :vartype job_title: ~affinda.models.JobTitleAnnotationUpdate
    :ivar contact_email:
    :vartype contact_email: ~affinda.models.TextAnnotationUpdate
    :ivar contact_name:
    :vartype contact_name: ~affinda.models.TextAnnotationUpdate
    :ivar contact_phone:
    :vartype contact_phone: ~affinda.models.TextAnnotationUpdate
    :ivar start_date:
    :vartype start_date: ~affinda.models.DateAnnotationUpdate
    :ivar end_date:
    :vartype end_date: ~affinda.models.DateAnnotationUpdate
    :ivar job_type:
    :vartype job_type: ~affinda.models.TextAnnotationUpdate
    :ivar languages:
    :vartype languages: list[~affinda.models.LanguageAnnotationUpdate]
    :ivar skills:
    :vartype skills: list[~affinda.models.SkillAnnotationUpdate]
    :ivar organization_name:
    :vartype organization_name: ~affinda.models.TextAnnotationUpdate
    :ivar organization_website:
    :vartype organization_website: ~affinda.models.TextAnnotationUpdate
    :ivar education_level:
    :vartype education_level: ~affinda.models.TextAnnotationUpdate
    :ivar education_accreditation:
    :vartype education_accreditation: ~affinda.models.TextAnnotationUpdate
    :ivar expected_remuneration:
    :vartype expected_remuneration: ~affinda.models.ExpectedRemunerationAnnotationUpdate
    :ivar location:
    :vartype location: ~affinda.models.LocationAnnotationUpdate
    :ivar certifications:
    :vartype certifications: list[~affinda.models.TextAnnotationUpdate]
    :ivar years_experience:
    :vartype years_experience: ~affinda.models.YearsExperienceAnnotationUpdate
    """

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "job_title": {"key": "jobTitle", "type": "JobTitleAnnotationUpdate"},
        "contact_email": {"key": "contactEmail", "type": "TextAnnotationUpdate"},
        "contact_name": {"key": "contactName", "type": "TextAnnotationUpdate"},
        "contact_phone": {"key": "contactPhone", "type": "TextAnnotationUpdate"},
        "start_date": {"key": "startDate", "type": "DateAnnotationUpdate"},
        "end_date": {"key": "endDate", "type": "DateAnnotationUpdate"},
        "job_type": {"key": "jobType", "type": "TextAnnotationUpdate"},
        "languages": {"key": "languages", "type": "[LanguageAnnotationUpdate]"},
        "skills": {"key": "skills", "type": "[SkillAnnotationUpdate]"},
        "organization_name": {"key": "organizationName", "type": "TextAnnotationUpdate"},
        "organization_website": {"key": "organizationWebsite", "type": "TextAnnotationUpdate"},
        "education_level": {"key": "educationLevel", "type": "TextAnnotationUpdate"},
        "education_accreditation": {
            "key": "educationAccreditation",
            "type": "TextAnnotationUpdate",
        },
        "expected_remuneration": {
            "key": "expectedRemuneration",
            "type": "ExpectedRemunerationAnnotationUpdate",
        },
        "location": {"key": "location", "type": "LocationAnnotationUpdate"},
        "certifications": {"key": "certifications", "type": "[TextAnnotationUpdate]"},
        "years_experience": {"key": "yearsExperience", "type": "YearsExperienceAnnotationUpdate"},
    }

    def __init__(self, **kwargs):
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword job_title:
        :paramtype job_title: ~affinda.models.JobTitleAnnotationUpdate
        :keyword contact_email:
        :paramtype contact_email: ~affinda.models.TextAnnotationUpdate
        :keyword contact_name:
        :paramtype contact_name: ~affinda.models.TextAnnotationUpdate
        :keyword contact_phone:
        :paramtype contact_phone: ~affinda.models.TextAnnotationUpdate
        :keyword start_date:
        :paramtype start_date: ~affinda.models.DateAnnotationUpdate
        :keyword end_date:
        :paramtype end_date: ~affinda.models.DateAnnotationUpdate
        :keyword job_type:
        :paramtype job_type: ~affinda.models.TextAnnotationUpdate
        :keyword languages:
        :paramtype languages: list[~affinda.models.LanguageAnnotationUpdate]
        :keyword skills:
        :paramtype skills: list[~affinda.models.SkillAnnotationUpdate]
        :keyword organization_name:
        :paramtype organization_name: ~affinda.models.TextAnnotationUpdate
        :keyword organization_website:
        :paramtype organization_website: ~affinda.models.TextAnnotationUpdate
        :keyword education_level:
        :paramtype education_level: ~affinda.models.TextAnnotationUpdate
        :keyword education_accreditation:
        :paramtype education_accreditation: ~affinda.models.TextAnnotationUpdate
        :keyword expected_remuneration:
        :paramtype expected_remuneration: ~affinda.models.ExpectedRemunerationAnnotationUpdate
        :keyword location:
        :paramtype location: ~affinda.models.LocationAnnotationUpdate
        :keyword certifications:
        :paramtype certifications: list[~affinda.models.TextAnnotationUpdate]
        :keyword years_experience:
        :paramtype years_experience: ~affinda.models.YearsExperienceAnnotationUpdate
        """
        super(JobDescriptionDataUpdate, self).__init__(**kwargs)
        self.additional_properties = kwargs.get("additional_properties", None)
        self.job_title = kwargs.get("job_title", None)
        self.contact_email = kwargs.get("contact_email", None)
        self.contact_name = kwargs.get("contact_name", None)
        self.contact_phone = kwargs.get("contact_phone", None)
        self.start_date = kwargs.get("start_date", None)
        self.end_date = kwargs.get("end_date", None)
        self.job_type = kwargs.get("job_type", None)
        self.languages = kwargs.get("languages", None)
        self.skills = kwargs.get("skills", None)
        self.organization_name = kwargs.get("organization_name", None)
        self.organization_website = kwargs.get("organization_website", None)
        self.education_level = kwargs.get("education_level", None)
        self.education_accreditation = kwargs.get("education_accreditation", None)
        self.expected_remuneration = kwargs.get("expected_remuneration", None)
        self.location = kwargs.get("location", None)
        self.certifications = kwargs.get("certifications", None)
        self.years_experience = kwargs.get("years_experience", None)


class JobDescriptionSearch(msrest.serialization.Model):
    """JobDescriptionSearch.

    :ivar count: Total number of results.
    :vartype count: int
    :ivar next: URL to request next page of results.
    :vartype next: str
    :ivar previous: URL to request previous page of results.
    :vartype previous: str
    :ivar parameters:
    :vartype parameters: ~affinda.models.JobDescriptionSearchParameters
    :ivar results:
    :vartype results: list[~affinda.models.JobDescriptionSearchResult]
    """

    _validation = {
        "count": {"minimum": 0},
    }

    _attribute_map = {
        "count": {"key": "count", "type": "int"},
        "next": {"key": "next", "type": "str"},
        "previous": {"key": "previous", "type": "str"},
        "parameters": {"key": "parameters", "type": "JobDescriptionSearchParameters"},
        "results": {"key": "results", "type": "[JobDescriptionSearchResult]"},
    }

    def __init__(self, **kwargs):
        """
        :keyword count: Total number of results.
        :paramtype count: int
        :keyword next: URL to request next page of results.
        :paramtype next: str
        :keyword previous: URL to request previous page of results.
        :paramtype previous: str
        :keyword parameters:
        :paramtype parameters: ~affinda.models.JobDescriptionSearchParameters
        :keyword results:
        :paramtype results: list[~affinda.models.JobDescriptionSearchResult]
        """
        super(JobDescriptionSearch, self).__init__(**kwargs)
        self.count = kwargs.get("count", None)
        self.next = kwargs.get("next", None)
        self.previous = kwargs.get("previous", None)
        self.parameters = kwargs.get("parameters", None)
        self.results = kwargs.get("results", None)


class JobDescriptionSearchConfig(msrest.serialization.Model):
    """JobDescriptionSearchConfig.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar allow_pdf_download:
    :vartype allow_pdf_download: bool
    :ivar max_results: Maximum number of results that can be returned. Setting to "null" means no
     limitation.
    :vartype max_results: int
    :ivar display_job_title:
    :vartype display_job_title: bool
    :ivar display_location:
    :vartype display_location: bool
    :ivar display_years_experience:
    :vartype display_years_experience: bool
    :ivar display_occupation_group:
    :vartype display_occupation_group: bool
    :ivar display_education:
    :vartype display_education: bool
    :ivar display_skills:
    :vartype display_skills: bool
    :ivar display_languages:
    :vartype display_languages: bool
    :ivar display_management_level:
    :vartype display_management_level: bool
    :ivar display_keywords:
    :vartype display_keywords: bool
    :ivar weight_job_title:
    :vartype weight_job_title: float
    :ivar weight_location:
    :vartype weight_location: float
    :ivar weight_years_experience:
    :vartype weight_years_experience: float
    :ivar weight_occupation_group:
    :vartype weight_occupation_group: float
    :ivar weight_education:
    :vartype weight_education: float
    :ivar weight_skills:
    :vartype weight_skills: float
    :ivar weight_languages:
    :vartype weight_languages: float
    :ivar weight_management_level:
    :vartype weight_management_level: float
    :ivar weight_keywords:
    :vartype weight_keywords: float
    :ivar indices: List of index names.
    :vartype indices: list[str]
    :ivar show_index_dropdown: Controls whether or not the index dropdown is displayed to the user.
    :vartype show_index_dropdown: bool
    :ivar search_tool_theme: Customize the theme of the embeded search tool.
    :vartype search_tool_theme: ~affinda.models.JobDescriptionSearchConfigSearchToolTheme
    :ivar user_id: ID of the logged in user.
    :vartype user_id: int
    :ivar username: Username of the logged in user.
    :vartype username: str
    :ivar actions: A list of actions to show in the dropdown in the embedded search tool.
    :vartype actions: list[~affinda.models.SearchConfigAction]
    :ivar hide_toolbar: Hide the reset/import toolbar.
    :vartype hide_toolbar: bool
    :ivar hide_side_panel: Hide the entire side panel.
    :vartype hide_side_panel: bool
    :ivar custom_fields_config:
    :vartype custom_fields_config: list[~affinda.models.CustomFieldConfig]
    :ivar distance_unit: The unit of distance to use for location based searches. Known values are:
     "mi", "km".
    :vartype distance_unit: str or ~affinda.models.JobDescriptionSearchConfigDistanceUnit
    """

    _validation = {
        "max_results": {"minimum": 1},
        "user_id": {"readonly": True, "minimum": 1},
        "username": {"readonly": True},
    }

    _attribute_map = {
        "allow_pdf_download": {"key": "allowPdfDownload", "type": "bool"},
        "max_results": {"key": "maxResults", "type": "int"},
        "display_job_title": {"key": "displayJobTitle", "type": "bool"},
        "display_location": {"key": "displayLocation", "type": "bool"},
        "display_years_experience": {"key": "displayYearsExperience", "type": "bool"},
        "display_occupation_group": {"key": "displayOccupationGroup", "type": "bool"},
        "display_education": {"key": "displayEducation", "type": "bool"},
        "display_skills": {"key": "displaySkills", "type": "bool"},
        "display_languages": {"key": "displayLanguages", "type": "bool"},
        "display_management_level": {"key": "displayManagementLevel", "type": "bool"},
        "display_keywords": {"key": "displayKeywords", "type": "bool"},
        "weight_job_title": {"key": "weightJobTitle", "type": "float"},
        "weight_location": {"key": "weightLocation", "type": "float"},
        "weight_years_experience": {"key": "weightYearsExperience", "type": "float"},
        "weight_occupation_group": {"key": "weightOccupationGroup", "type": "float"},
        "weight_education": {"key": "weightEducation", "type": "float"},
        "weight_skills": {"key": "weightSkills", "type": "float"},
        "weight_languages": {"key": "weightLanguages", "type": "float"},
        "weight_management_level": {"key": "weightManagementLevel", "type": "float"},
        "weight_keywords": {"key": "weightKeywords", "type": "float"},
        "indices": {"key": "indices", "type": "[str]"},
        "show_index_dropdown": {"key": "showIndexDropdown", "type": "bool"},
        "search_tool_theme": {
            "key": "searchToolTheme",
            "type": "JobDescriptionSearchConfigSearchToolTheme",
        },
        "user_id": {"key": "userId", "type": "int"},
        "username": {"key": "username", "type": "str"},
        "actions": {"key": "actions", "type": "[SearchConfigAction]"},
        "hide_toolbar": {"key": "hideToolbar", "type": "bool"},
        "hide_side_panel": {"key": "hideSidePanel", "type": "bool"},
        "custom_fields_config": {"key": "customFieldsConfig", "type": "[CustomFieldConfig]"},
        "distance_unit": {"key": "distanceUnit", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword allow_pdf_download:
        :paramtype allow_pdf_download: bool
        :keyword max_results: Maximum number of results that can be returned. Setting to "null" means
         no limitation.
        :paramtype max_results: int
        :keyword display_job_title:
        :paramtype display_job_title: bool
        :keyword display_location:
        :paramtype display_location: bool
        :keyword display_years_experience:
        :paramtype display_years_experience: bool
        :keyword display_occupation_group:
        :paramtype display_occupation_group: bool
        :keyword display_education:
        :paramtype display_education: bool
        :keyword display_skills:
        :paramtype display_skills: bool
        :keyword display_languages:
        :paramtype display_languages: bool
        :keyword display_management_level:
        :paramtype display_management_level: bool
        :keyword display_keywords:
        :paramtype display_keywords: bool
        :keyword weight_job_title:
        :paramtype weight_job_title: float
        :keyword weight_location:
        :paramtype weight_location: float
        :keyword weight_years_experience:
        :paramtype weight_years_experience: float
        :keyword weight_occupation_group:
        :paramtype weight_occupation_group: float
        :keyword weight_education:
        :paramtype weight_education: float
        :keyword weight_skills:
        :paramtype weight_skills: float
        :keyword weight_languages:
        :paramtype weight_languages: float
        :keyword weight_management_level:
        :paramtype weight_management_level: float
        :keyword weight_keywords:
        :paramtype weight_keywords: float
        :keyword indices: List of index names.
        :paramtype indices: list[str]
        :keyword show_index_dropdown: Controls whether or not the index dropdown is displayed to the
         user.
        :paramtype show_index_dropdown: bool
        :keyword search_tool_theme: Customize the theme of the embeded search tool.
        :paramtype search_tool_theme: ~affinda.models.JobDescriptionSearchConfigSearchToolTheme
        :keyword actions: A list of actions to show in the dropdown in the embedded search tool.
        :paramtype actions: list[~affinda.models.SearchConfigAction]
        :keyword hide_toolbar: Hide the reset/import toolbar.
        :paramtype hide_toolbar: bool
        :keyword hide_side_panel: Hide the entire side panel.
        :paramtype hide_side_panel: bool
        :keyword custom_fields_config:
        :paramtype custom_fields_config: list[~affinda.models.CustomFieldConfig]
        :keyword distance_unit: The unit of distance to use for location based searches. Known values
         are: "mi", "km".
        :paramtype distance_unit: str or ~affinda.models.JobDescriptionSearchConfigDistanceUnit
        """
        super(JobDescriptionSearchConfig, self).__init__(**kwargs)
        self.allow_pdf_download = kwargs.get("allow_pdf_download", None)
        self.max_results = kwargs.get("max_results", None)
        self.display_job_title = kwargs.get("display_job_title", None)
        self.display_location = kwargs.get("display_location", None)
        self.display_years_experience = kwargs.get("display_years_experience", None)
        self.display_occupation_group = kwargs.get("display_occupation_group", None)
        self.display_education = kwargs.get("display_education", None)
        self.display_skills = kwargs.get("display_skills", None)
        self.display_languages = kwargs.get("display_languages", None)
        self.display_management_level = kwargs.get("display_management_level", None)
        self.display_keywords = kwargs.get("display_keywords", None)
        self.weight_job_title = kwargs.get("weight_job_title", None)
        self.weight_location = kwargs.get("weight_location", None)
        self.weight_years_experience = kwargs.get("weight_years_experience", None)
        self.weight_occupation_group = kwargs.get("weight_occupation_group", None)
        self.weight_education = kwargs.get("weight_education", None)
        self.weight_skills = kwargs.get("weight_skills", None)
        self.weight_languages = kwargs.get("weight_languages", None)
        self.weight_management_level = kwargs.get("weight_management_level", None)
        self.weight_keywords = kwargs.get("weight_keywords", None)
        self.indices = kwargs.get("indices", None)
        self.show_index_dropdown = kwargs.get("show_index_dropdown", None)
        self.search_tool_theme = kwargs.get("search_tool_theme", None)
        self.user_id = None
        self.username = None
        self.actions = kwargs.get("actions", None)
        self.hide_toolbar = kwargs.get("hide_toolbar", None)
        self.hide_side_panel = kwargs.get("hide_side_panel", None)
        self.custom_fields_config = kwargs.get("custom_fields_config", None)
        self.distance_unit = kwargs.get("distance_unit", None)


class ThemeConfig(msrest.serialization.Model):
    """ThemeConfig.

    :ivar palette:
    :vartype palette: ~affinda.models.ThemeConfigPalette
    :ivar typography:
    :vartype typography: ~affinda.models.ThemeConfigTypography
    :ivar border_radius:
    :vartype border_radius: float
    :ivar font_url:
    :vartype font_url: str
    """

    _attribute_map = {
        "palette": {"key": "palette", "type": "ThemeConfigPalette"},
        "typography": {"key": "typography", "type": "ThemeConfigTypography"},
        "border_radius": {"key": "borderRadius", "type": "float"},
        "font_url": {"key": "fontUrl", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword palette:
        :paramtype palette: ~affinda.models.ThemeConfigPalette
        :keyword typography:
        :paramtype typography: ~affinda.models.ThemeConfigTypography
        :keyword border_radius:
        :paramtype border_radius: float
        :keyword font_url:
        :paramtype font_url: str
        """
        super(ThemeConfig, self).__init__(**kwargs)
        self.palette = kwargs.get("palette", None)
        self.typography = kwargs.get("typography", None)
        self.border_radius = kwargs.get("border_radius", None)
        self.font_url = kwargs.get("font_url", None)


class JobDescriptionSearchConfigSearchToolTheme(ThemeConfig):
    """Customize the theme of the embeded search tool.

    :ivar palette:
    :vartype palette: ~affinda.models.ThemeConfigPalette
    :ivar typography:
    :vartype typography: ~affinda.models.ThemeConfigTypography
    :ivar border_radius:
    :vartype border_radius: float
    :ivar font_url:
    :vartype font_url: str
    """

    _attribute_map = {
        "palette": {"key": "palette", "type": "ThemeConfigPalette"},
        "typography": {"key": "typography", "type": "ThemeConfigTypography"},
        "border_radius": {"key": "borderRadius", "type": "float"},
        "font_url": {"key": "fontUrl", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword palette:
        :paramtype palette: ~affinda.models.ThemeConfigPalette
        :keyword typography:
        :paramtype typography: ~affinda.models.ThemeConfigTypography
        :keyword border_radius:
        :paramtype border_radius: float
        :keyword font_url:
        :paramtype font_url: str
        """
        super(JobDescriptionSearchConfigSearchToolTheme, self).__init__(**kwargs)


class JobDescriptionSearchDetail(msrest.serialization.Model):
    """JobDescriptionSearchDetail.

    :ivar job_title:
    :vartype job_title: ~affinda.models.JobDescriptionSearchDetailJobTitle
    :ivar location:
    :vartype location: ~affinda.models.JobDescriptionSearchDetailLocation
    :ivar education:
    :vartype education: ~affinda.models.JobDescriptionSearchDetailEducation
    :ivar skills:
    :vartype skills: ~affinda.models.JobDescriptionSearchDetailSkills
    :ivar experience:
    :vartype experience: ~affinda.models.JobDescriptionSearchDetailExperience
    :ivar occupation_group:
    :vartype occupation_group: ~affinda.models.JobDescriptionSearchDetailOccupationGroup
    :ivar languages:
    :vartype languages: ~affinda.models.JobDescriptionSearchDetailLanguages
    :ivar management_level:
    :vartype management_level: ~affinda.models.JobDescriptionSearchDetailManagementLevel
    :ivar search_expression:
    :vartype search_expression: ~affinda.models.JobDescriptionSearchDetailSearchExpression
    """

    _attribute_map = {
        "job_title": {"key": "jobTitle", "type": "JobDescriptionSearchDetailJobTitle"},
        "location": {"key": "location", "type": "JobDescriptionSearchDetailLocation"},
        "education": {"key": "education", "type": "JobDescriptionSearchDetailEducation"},
        "skills": {"key": "skills", "type": "JobDescriptionSearchDetailSkills"},
        "experience": {"key": "experience", "type": "JobDescriptionSearchDetailExperience"},
        "occupation_group": {
            "key": "occupationGroup",
            "type": "JobDescriptionSearchDetailOccupationGroup",
        },
        "languages": {"key": "languages", "type": "JobDescriptionSearchDetailLanguages"},
        "management_level": {
            "key": "managementLevel",
            "type": "JobDescriptionSearchDetailManagementLevel",
        },
        "search_expression": {
            "key": "searchExpression",
            "type": "JobDescriptionSearchDetailSearchExpression",
        },
    }

    def __init__(self, **kwargs):
        """
        :keyword job_title:
        :paramtype job_title: ~affinda.models.JobDescriptionSearchDetailJobTitle
        :keyword location:
        :paramtype location: ~affinda.models.JobDescriptionSearchDetailLocation
        :keyword education:
        :paramtype education: ~affinda.models.JobDescriptionSearchDetailEducation
        :keyword skills:
        :paramtype skills: ~affinda.models.JobDescriptionSearchDetailSkills
        :keyword experience:
        :paramtype experience: ~affinda.models.JobDescriptionSearchDetailExperience
        :keyword occupation_group:
        :paramtype occupation_group: ~affinda.models.JobDescriptionSearchDetailOccupationGroup
        :keyword languages:
        :paramtype languages: ~affinda.models.JobDescriptionSearchDetailLanguages
        :keyword management_level:
        :paramtype management_level: ~affinda.models.JobDescriptionSearchDetailManagementLevel
        :keyword search_expression:
        :paramtype search_expression: ~affinda.models.JobDescriptionSearchDetailSearchExpression
        """
        super(JobDescriptionSearchDetail, self).__init__(**kwargs)
        self.job_title = kwargs.get("job_title", None)
        self.location = kwargs.get("location", None)
        self.education = kwargs.get("education", None)
        self.skills = kwargs.get("skills", None)
        self.experience = kwargs.get("experience", None)
        self.occupation_group = kwargs.get("occupation_group", None)
        self.languages = kwargs.get("languages", None)
        self.management_level = kwargs.get("management_level", None)
        self.search_expression = kwargs.get("search_expression", None)


class JobDescriptionSearchDetailEducation(msrest.serialization.Model):
    """JobDescriptionSearchDetailEducation.

    :ivar missing:
    :vartype missing: ~affinda.models.JobDescriptionSearchDetailEducationMissing
    :ivar value:
    :vartype value: ~affinda.models.JobDescriptionSearchDetailEducationValue
    """

    _attribute_map = {
        "missing": {"key": "missing", "type": "JobDescriptionSearchDetailEducationMissing"},
        "value": {"key": "value", "type": "JobDescriptionSearchDetailEducationValue"},
    }

    def __init__(self, **kwargs):
        """
        :keyword missing:
        :paramtype missing: ~affinda.models.JobDescriptionSearchDetailEducationMissing
        :keyword value:
        :paramtype value: ~affinda.models.JobDescriptionSearchDetailEducationValue
        """
        super(JobDescriptionSearchDetailEducation, self).__init__(**kwargs)
        self.missing = kwargs.get("missing", None)
        self.value = kwargs.get("value", None)


class JobDescriptionSearchDetailEducationMissing(msrest.serialization.Model):
    """JobDescriptionSearchDetailEducationMissing.

    :ivar degrees:
    :vartype degrees: list[str]
    :ivar degree_types:
    :vartype degree_types: list[str]
    """

    _attribute_map = {
        "degrees": {"key": "degrees", "type": "[str]"},
        "degree_types": {"key": "degreeTypes", "type": "[str]"},
    }

    def __init__(self, **kwargs):
        """
        :keyword degrees:
        :paramtype degrees: list[str]
        :keyword degree_types:
        :paramtype degree_types: list[str]
        """
        super(JobDescriptionSearchDetailEducationMissing, self).__init__(**kwargs)
        self.degrees = kwargs.get("degrees", None)
        self.degree_types = kwargs.get("degree_types", None)


class JobDescriptionSearchDetailEducationValue(msrest.serialization.Model):
    """JobDescriptionSearchDetailEducationValue.

    :ivar degrees:
    :vartype degrees: list[str]
    :ivar degree_types:
    :vartype degree_types: list[str]
    :ivar match:
    :vartype match: bool
    """

    _attribute_map = {
        "degrees": {"key": "degrees", "type": "[str]"},
        "degree_types": {"key": "degreeTypes", "type": "[str]"},
        "match": {"key": "match", "type": "bool"},
    }

    def __init__(self, **kwargs):
        """
        :keyword degrees:
        :paramtype degrees: list[str]
        :keyword degree_types:
        :paramtype degree_types: list[str]
        :keyword match:
        :paramtype match: bool
        """
        super(JobDescriptionSearchDetailEducationValue, self).__init__(**kwargs)
        self.degrees = kwargs.get("degrees", None)
        self.degree_types = kwargs.get("degree_types", None)
        self.match = kwargs.get("match", None)


class JobDescriptionSearchDetailExperience(msrest.serialization.Model):
    """JobDescriptionSearchDetailExperience.

    :ivar minimum_experience:
    :vartype minimum_experience: int
    :ivar maximum_experience:
    :vartype maximum_experience: int
    :ivar match:
    :vartype match: bool
    """

    _validation = {
        "minimum_experience": {"minimum": 0},
        "maximum_experience": {"minimum": 0},
    }

    _attribute_map = {
        "minimum_experience": {"key": "minimumExperience", "type": "int"},
        "maximum_experience": {"key": "maximumExperience", "type": "int"},
        "match": {"key": "match", "type": "bool"},
    }

    def __init__(self, **kwargs):
        """
        :keyword minimum_experience:
        :paramtype minimum_experience: int
        :keyword maximum_experience:
        :paramtype maximum_experience: int
        :keyword match:
        :paramtype match: bool
        """
        super(JobDescriptionSearchDetailExperience, self).__init__(**kwargs)
        self.minimum_experience = kwargs.get("minimum_experience", None)
        self.maximum_experience = kwargs.get("maximum_experience", None)
        self.match = kwargs.get("match", None)


class JobDescriptionSearchDetailJobTitle(msrest.serialization.Model):
    """JobDescriptionSearchDetailJobTitle.

    :ivar missing:
    :vartype missing: list[str]
    :ivar value:
    :vartype value: ~affinda.models.JobDescriptionSearchDetailJobTitleValue
    """

    _attribute_map = {
        "missing": {"key": "missing", "type": "[str]"},
        "value": {"key": "value", "type": "JobDescriptionSearchDetailJobTitleValue"},
    }

    def __init__(self, **kwargs):
        """
        :keyword missing:
        :paramtype missing: list[str]
        :keyword value:
        :paramtype value: ~affinda.models.JobDescriptionSearchDetailJobTitleValue
        """
        super(JobDescriptionSearchDetailJobTitle, self).__init__(**kwargs)
        self.missing = kwargs.get("missing", None)
        self.value = kwargs.get("value", None)


class JobDescriptionSearchDetailJobTitleValue(msrest.serialization.Model):
    """JobDescriptionSearchDetailJobTitleValue.

    :ivar name:
    :vartype name: str
    :ivar company_name:
    :vartype company_name: str
    :ivar match:
    :vartype match: bool
    """

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "company_name": {"key": "companyName", "type": "str"},
        "match": {"key": "match", "type": "bool"},
    }

    def __init__(self, **kwargs):
        """
        :keyword name:
        :paramtype name: str
        :keyword company_name:
        :paramtype company_name: str
        :keyword match:
        :paramtype match: bool
        """
        super(JobDescriptionSearchDetailJobTitleValue, self).__init__(**kwargs)
        self.name = kwargs.get("name", None)
        self.company_name = kwargs.get("company_name", None)
        self.match = kwargs.get("match", None)


class JobDescriptionSearchDetailLanguages(msrest.serialization.Model):
    """JobDescriptionSearchDetailLanguages.

    :ivar missing:
    :vartype missing: list[~affinda.models.ResumeSearchParametersSkill]
    :ivar value:
    :vartype value: list[~affinda.models.JobDescriptionSearchDetailLanguagesValueItem]
    """

    _attribute_map = {
        "missing": {"key": "missing", "type": "[ResumeSearchParametersSkill]"},
        "value": {"key": "value", "type": "[JobDescriptionSearchDetailLanguagesValueItem]"},
    }

    def __init__(self, **kwargs):
        """
        :keyword missing:
        :paramtype missing: list[~affinda.models.ResumeSearchParametersSkill]
        :keyword value:
        :paramtype value: list[~affinda.models.JobDescriptionSearchDetailLanguagesValueItem]
        """
        super(JobDescriptionSearchDetailLanguages, self).__init__(**kwargs)
        self.missing = kwargs.get("missing", None)
        self.value = kwargs.get("value", None)


class JobDescriptionSearchDetailLanguagesValueItem(msrest.serialization.Model):
    """JobDescriptionSearchDetailLanguagesValueItem.

    :ivar name:
    :vartype name: str
    :ivar match:
    :vartype match: bool
    """

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "match": {"key": "match", "type": "bool"},
    }

    def __init__(self, **kwargs):
        """
        :keyword name:
        :paramtype name: str
        :keyword match:
        :paramtype match: bool
        """
        super(JobDescriptionSearchDetailLanguagesValueItem, self).__init__(**kwargs)
        self.name = kwargs.get("name", None)
        self.match = kwargs.get("match", None)


class JobDescriptionSearchDetailLocation(msrest.serialization.Model):
    """JobDescriptionSearchDetailLocation.

    :ivar missing:
    :vartype missing: list[~affinda.models.ResumeSearchParametersLocation]
    :ivar value:
    :vartype value: ~affinda.models.JobDescriptionSearchDetailLocationValue
    """

    _attribute_map = {
        "missing": {"key": "missing", "type": "[ResumeSearchParametersLocation]"},
        "value": {"key": "value", "type": "JobDescriptionSearchDetailLocationValue"},
    }

    def __init__(self, **kwargs):
        """
        :keyword missing:
        :paramtype missing: list[~affinda.models.ResumeSearchParametersLocation]
        :keyword value:
        :paramtype value: ~affinda.models.JobDescriptionSearchDetailLocationValue
        """
        super(JobDescriptionSearchDetailLocation, self).__init__(**kwargs)
        self.missing = kwargs.get("missing", None)
        self.value = kwargs.get("value", None)


class Location(msrest.serialization.Model):
    """Location.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar formatted:
    :vartype formatted: str
    :ivar postal_code:
    :vartype postal_code: str
    :ivar state:
    :vartype state: str
    :ivar state_code:
    :vartype state_code: str
    :ivar country:
    :vartype country: str
    :ivar country_code: Two letter country code (ISO 3166-1 alpha-2).
    :vartype country_code: str
    :ivar raw_input: Required.
    :vartype raw_input: str
    :ivar street_number:
    :vartype street_number: str
    :ivar street:
    :vartype street: str
    :ivar apartment_number:
    :vartype apartment_number: str
    :ivar city:
    :vartype city: str
    :ivar latitude:
    :vartype latitude: float
    :ivar longitude:
    :vartype longitude: float
    :ivar po_box:
    :vartype po_box: str
    """

    _validation = {
        "formatted": {"readonly": True},
        "postal_code": {"readonly": True},
        "state": {"readonly": True},
        "state_code": {"readonly": True},
        "country": {"readonly": True},
        "country_code": {"readonly": True},
        "raw_input": {"required": True},
        "street_number": {"readonly": True},
        "street": {"readonly": True},
        "apartment_number": {"readonly": True},
        "city": {"readonly": True},
        "latitude": {"readonly": True},
        "longitude": {"readonly": True},
        "po_box": {"readonly": True},
    }

    _attribute_map = {
        "formatted": {"key": "formatted", "type": "str"},
        "postal_code": {"key": "postalCode", "type": "str"},
        "state": {"key": "state", "type": "str"},
        "state_code": {"key": "stateCode", "type": "str"},
        "country": {"key": "country", "type": "str"},
        "country_code": {"key": "countryCode", "type": "str"},
        "raw_input": {"key": "rawInput", "type": "str"},
        "street_number": {"key": "streetNumber", "type": "str"},
        "street": {"key": "street", "type": "str"},
        "apartment_number": {"key": "apartmentNumber", "type": "str"},
        "city": {"key": "city", "type": "str"},
        "latitude": {"key": "latitude", "type": "float"},
        "longitude": {"key": "longitude", "type": "float"},
        "po_box": {"key": "poBox", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword raw_input: Required.
        :paramtype raw_input: str
        """
        super(Location, self).__init__(**kwargs)
        self.formatted = None
        self.postal_code = None
        self.state = None
        self.state_code = None
        self.country = None
        self.country_code = None
        self.raw_input = kwargs["raw_input"]
        self.street_number = None
        self.street = None
        self.apartment_number = None
        self.city = None
        self.latitude = None
        self.longitude = None
        self.po_box = None


class JobDescriptionSearchDetailLocationValue(
    Location,
    Components1TlnsonSchemasJobdescriptionsearchdetailPropertiesLocationPropertiesValueAllof1,
):
    """JobDescriptionSearchDetailLocationValue.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar match:
    :vartype match: bool
    :ivar formatted:
    :vartype formatted: str
    :ivar postal_code:
    :vartype postal_code: str
    :ivar state:
    :vartype state: str
    :ivar state_code:
    :vartype state_code: str
    :ivar country:
    :vartype country: str
    :ivar country_code: Two letter country code (ISO 3166-1 alpha-2).
    :vartype country_code: str
    :ivar raw_input: Required.
    :vartype raw_input: str
    :ivar street_number:
    :vartype street_number: str
    :ivar street:
    :vartype street: str
    :ivar apartment_number:
    :vartype apartment_number: str
    :ivar city:
    :vartype city: str
    :ivar latitude:
    :vartype latitude: float
    :ivar longitude:
    :vartype longitude: float
    :ivar po_box:
    :vartype po_box: str
    """

    _validation = {
        "formatted": {"readonly": True},
        "postal_code": {"readonly": True},
        "state": {"readonly": True},
        "state_code": {"readonly": True},
        "country": {"readonly": True},
        "country_code": {"readonly": True},
        "raw_input": {"required": True},
        "street_number": {"readonly": True},
        "street": {"readonly": True},
        "apartment_number": {"readonly": True},
        "city": {"readonly": True},
        "latitude": {"readonly": True},
        "longitude": {"readonly": True},
        "po_box": {"readonly": True},
    }

    _attribute_map = {
        "match": {"key": "match", "type": "bool"},
        "formatted": {"key": "formatted", "type": "str"},
        "postal_code": {"key": "postalCode", "type": "str"},
        "state": {"key": "state", "type": "str"},
        "state_code": {"key": "stateCode", "type": "str"},
        "country": {"key": "country", "type": "str"},
        "country_code": {"key": "countryCode", "type": "str"},
        "raw_input": {"key": "rawInput", "type": "str"},
        "street_number": {"key": "streetNumber", "type": "str"},
        "street": {"key": "street", "type": "str"},
        "apartment_number": {"key": "apartmentNumber", "type": "str"},
        "city": {"key": "city", "type": "str"},
        "latitude": {"key": "latitude", "type": "float"},
        "longitude": {"key": "longitude", "type": "float"},
        "po_box": {"key": "poBox", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword match:
        :paramtype match: bool
        :keyword raw_input: Required.
        :paramtype raw_input: str
        """
        super(JobDescriptionSearchDetailLocationValue, self).__init__(**kwargs)
        self.match = kwargs.get("match", None)
        self.formatted = None
        self.postal_code = None
        self.state = None
        self.state_code = None
        self.country = None
        self.country_code = None
        self.raw_input = kwargs["raw_input"]
        self.street_number = None
        self.street = None
        self.apartment_number = None
        self.city = None
        self.latitude = None
        self.longitude = None
        self.po_box = None


class JobDescriptionSearchDetailManagementLevel(msrest.serialization.Model):
    """JobDescriptionSearchDetailManagementLevel.

    :ivar level: Known values are: "None", "Low", "Mid", "Upper".
    :vartype level: str or ~affinda.models.ManagementLevel
    :ivar match:
    :vartype match: bool
    """

    _attribute_map = {
        "level": {"key": "level", "type": "str"},
        "match": {"key": "match", "type": "bool"},
    }

    def __init__(self, **kwargs):
        """
        :keyword level: Known values are: "None", "Low", "Mid", "Upper".
        :paramtype level: str or ~affinda.models.ManagementLevel
        :keyword match:
        :paramtype match: bool
        """
        super(JobDescriptionSearchDetailManagementLevel, self).__init__(**kwargs)
        self.level = kwargs.get("level", None)
        self.match = kwargs.get("match", None)


class JobDescriptionSearchDetailOccupationGroup(msrest.serialization.Model):
    """JobDescriptionSearchDetailOccupationGroup.

    :ivar missing:
    :vartype missing: list[int]
    :ivar value:
    :vartype value: ~affinda.models.JobDescriptionSearchDetailOccupationGroupValue
    """

    _attribute_map = {
        "missing": {"key": "missing", "type": "[int]"},
        "value": {"key": "value", "type": "JobDescriptionSearchDetailOccupationGroupValue"},
    }

    def __init__(self, **kwargs):
        """
        :keyword missing:
        :paramtype missing: list[int]
        :keyword value:
        :paramtype value: ~affinda.models.JobDescriptionSearchDetailOccupationGroupValue
        """
        super(JobDescriptionSearchDetailOccupationGroup, self).__init__(**kwargs)
        self.missing = kwargs.get("missing", None)
        self.value = kwargs.get("value", None)


class OccupationGroupSearchResult(msrest.serialization.Model):
    """OccupationGroupSearchResult.

    All required parameters must be populated in order to send to Azure.

    :ivar match:
    :vartype match: bool
    :ivar code: Required.
    :vartype code: int
    :ivar name: Required.
    :vartype name: str
    :ivar children:
    :vartype children: list[~affinda.models.OccupationGroup]
    :ivar parents:
    :vartype parents: list[~affinda.models.OccupationGroup]
    """

    _validation = {
        "code": {"required": True},
        "name": {"required": True},
    }

    _attribute_map = {
        "match": {"key": "match", "type": "bool"},
        "code": {"key": "code", "type": "int"},
        "name": {"key": "name", "type": "str"},
        "children": {"key": "children", "type": "[OccupationGroup]"},
        "parents": {"key": "parents", "type": "[OccupationGroup]"},
    }

    def __init__(self, **kwargs):
        """
        :keyword match:
        :paramtype match: bool
        :keyword code: Required.
        :paramtype code: int
        :keyword name: Required.
        :paramtype name: str
        :keyword children:
        :paramtype children: list[~affinda.models.OccupationGroup]
        :keyword parents:
        :paramtype parents: list[~affinda.models.OccupationGroup]
        """
        super(OccupationGroupSearchResult, self).__init__(**kwargs)
        self.match = kwargs.get("match", None)
        self.code = kwargs["code"]
        self.name = kwargs["name"]
        self.children = kwargs.get("children", None)
        self.parents = kwargs.get("parents", None)


class JobDescriptionSearchDetailOccupationGroupValue(OccupationGroupSearchResult):
    """JobDescriptionSearchDetailOccupationGroupValue.

    All required parameters must be populated in order to send to Azure.

    :ivar match:
    :vartype match: bool
    :ivar code: Required.
    :vartype code: int
    :ivar name: Required.
    :vartype name: str
    :ivar children:
    :vartype children: list[~affinda.models.OccupationGroup]
    :ivar parents:
    :vartype parents: list[~affinda.models.OccupationGroup]
    """

    _validation = {
        "code": {"required": True},
        "name": {"required": True},
    }

    _attribute_map = {
        "match": {"key": "match", "type": "bool"},
        "code": {"key": "code", "type": "int"},
        "name": {"key": "name", "type": "str"},
        "children": {"key": "children", "type": "[OccupationGroup]"},
        "parents": {"key": "parents", "type": "[OccupationGroup]"},
    }

    def __init__(self, **kwargs):
        """
        :keyword match:
        :paramtype match: bool
        :keyword code: Required.
        :paramtype code: int
        :keyword name: Required.
        :paramtype name: str
        :keyword children:
        :paramtype children: list[~affinda.models.OccupationGroup]
        :keyword parents:
        :paramtype parents: list[~affinda.models.OccupationGroup]
        """
        super(JobDescriptionSearchDetailOccupationGroupValue, self).__init__(**kwargs)


class JobDescriptionSearchDetailSearchExpression(msrest.serialization.Model):
    """JobDescriptionSearchDetailSearchExpression.

    :ivar missing:
    :vartype missing: list[str]
    :ivar value:
    :vartype value: list[str]
    """

    _attribute_map = {
        "missing": {"key": "missing", "type": "[str]"},
        "value": {"key": "value", "type": "[str]"},
    }

    def __init__(self, **kwargs):
        """
        :keyword missing:
        :paramtype missing: list[str]
        :keyword value:
        :paramtype value: list[str]
        """
        super(JobDescriptionSearchDetailSearchExpression, self).__init__(**kwargs)
        self.missing = kwargs.get("missing", None)
        self.value = kwargs.get("value", None)


class JobDescriptionSearchDetailSkills(msrest.serialization.Model):
    """JobDescriptionSearchDetailSkills.

    :ivar missing:
    :vartype missing: list[~affinda.models.ResumeSearchParametersSkill]
    :ivar value:
    :vartype value: list[~affinda.models.JobDescriptionSearchDetailSkillsValueItem]
    """

    _attribute_map = {
        "missing": {"key": "missing", "type": "[ResumeSearchParametersSkill]"},
        "value": {"key": "value", "type": "[JobDescriptionSearchDetailSkillsValueItem]"},
    }

    def __init__(self, **kwargs):
        """
        :keyword missing:
        :paramtype missing: list[~affinda.models.ResumeSearchParametersSkill]
        :keyword value:
        :paramtype value: list[~affinda.models.JobDescriptionSearchDetailSkillsValueItem]
        """
        super(JobDescriptionSearchDetailSkills, self).__init__(**kwargs)
        self.missing = kwargs.get("missing", None)
        self.value = kwargs.get("value", None)


class JobDescriptionSearchDetailSkillsValueItem(msrest.serialization.Model):
    """JobDescriptionSearchDetailSkillsValueItem.

    :ivar name:
    :vartype name: str
    :ivar match:
    :vartype match: bool
    """

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "match": {"key": "match", "type": "bool"},
    }

    def __init__(self, **kwargs):
        """
        :keyword name:
        :paramtype name: str
        :keyword match:
        :paramtype match: bool
        """
        super(JobDescriptionSearchDetailSkillsValueItem, self).__init__(**kwargs)
        self.name = kwargs.get("name", None)
        self.match = kwargs.get("match", None)


class JobDescriptionSearchEmbed(msrest.serialization.Model):
    """JobDescriptionSearchEmbed.

    :ivar url: The signed URL for the embedable search tool.
    :vartype url: str
    """

    _attribute_map = {
        "url": {"key": "url", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword url: The signed URL for the embedable search tool.
        :paramtype url: str
        """
        super(JobDescriptionSearchEmbed, self).__init__(**kwargs)
        self.url = kwargs.get("url", None)


class JobDescriptionSearchParameters(msrest.serialization.Model):
    """JobDescriptionSearchParameters.

    All required parameters must be populated in order to send to Azure.

    :ivar indices: Required.
    :vartype indices: list[str]
    :ivar resume: A random string that uniquely identify the resource.
    :vartype resume: str
    :ivar job_titles:
    :vartype job_titles: list[str]
    :ivar job_titles_required:
    :vartype job_titles_required: bool
    :ivar job_titles_weight:
    :vartype job_titles_weight: float
    :ivar total_years_experience:
    :vartype total_years_experience: float
    :ivar years_experience_required:
    :vartype years_experience_required: bool
    :ivar years_experience_weight:
    :vartype years_experience_weight: float
    :ivar locations:
    :vartype locations: list[~affinda.models.ResumeSearchParametersLocation]
    :ivar locations_weight:
    :vartype locations_weight: float
    :ivar locations_required:
    :vartype locations_required: bool
    :ivar skills:
    :vartype skills: list[~affinda.models.ResumeSearchParametersSkill]
    :ivar skills_weight:
    :vartype skills_weight: float
    :ivar languages:
    :vartype languages: list[~affinda.models.ResumeSearchParametersSkill]
    :ivar languages_weight:
    :vartype languages_weight: float
    :ivar degrees:
    :vartype degrees: list[str]
    :ivar degrees_required:
    :vartype degrees_required: bool
    :ivar degree_types:
    :vartype degree_types: list[str or ~affinda.models.EducationLevel]
    :ivar degree_types_required:
    :vartype degree_types_required: bool
    :ivar education_weight:
    :vartype education_weight: float
    :ivar search_expression:
    :vartype search_expression: str
    :ivar search_expression_required:
    :vartype search_expression_required: bool
    :ivar search_expression_weight:
    :vartype search_expression_weight: float
    :ivar soc_codes:
    :vartype soc_codes: list[int]
    :ivar soc_codes_weight:
    :vartype soc_codes_weight: float
    :ivar soc_codes_required:
    :vartype soc_codes_required: bool
    :ivar management_level: Known values are: "None", "Low", "Mid", "Upper".
    :vartype management_level: str or ~affinda.models.ManagementLevel
    :ivar management_level_required:
    :vartype management_level_required: bool
    :ivar management_level_weight:
    :vartype management_level_weight: float
    :ivar custom_data:
    :vartype custom_data: list[~affinda.models.SearchParametersCustomData]
    """

    _validation = {
        "indices": {"required": True},
        "job_titles_weight": {"maximum": 1, "minimum": 0},
        "years_experience_weight": {"maximum": 1, "minimum": 0},
        "locations_weight": {"maximum": 1, "minimum": 0},
        "skills_weight": {"maximum": 1, "minimum": 0},
        "languages_weight": {"maximum": 1, "minimum": 0},
        "degree_types": {"unique": True},
        "education_weight": {"maximum": 1, "minimum": 0},
        "search_expression_weight": {"maximum": 1, "minimum": 0},
        "soc_codes_weight": {"maximum": 1, "minimum": 0},
        "management_level_weight": {"maximum": 1, "minimum": 0},
    }

    _attribute_map = {
        "indices": {"key": "indices", "type": "[str]"},
        "resume": {"key": "resume", "type": "str"},
        "job_titles": {"key": "jobTitles", "type": "[str]"},
        "job_titles_required": {"key": "jobTitlesRequired", "type": "bool"},
        "job_titles_weight": {"key": "jobTitlesWeight", "type": "float"},
        "total_years_experience": {"key": "totalYearsExperience", "type": "float"},
        "years_experience_required": {"key": "yearsExperienceRequired", "type": "bool"},
        "years_experience_weight": {"key": "yearsExperienceWeight", "type": "float"},
        "locations": {"key": "locations", "type": "[ResumeSearchParametersLocation]"},
        "locations_weight": {"key": "locationsWeight", "type": "float"},
        "locations_required": {"key": "locationsRequired", "type": "bool"},
        "skills": {"key": "skills", "type": "[ResumeSearchParametersSkill]"},
        "skills_weight": {"key": "skillsWeight", "type": "float"},
        "languages": {"key": "languages", "type": "[ResumeSearchParametersSkill]"},
        "languages_weight": {"key": "languagesWeight", "type": "float"},
        "degrees": {"key": "degrees", "type": "[str]"},
        "degrees_required": {"key": "degreesRequired", "type": "bool"},
        "degree_types": {"key": "degreeTypes", "type": "[str]"},
        "degree_types_required": {"key": "degreeTypesRequired", "type": "bool"},
        "education_weight": {"key": "educationWeight", "type": "float"},
        "search_expression": {"key": "searchExpression", "type": "str"},
        "search_expression_required": {"key": "searchExpressionRequired", "type": "bool"},
        "search_expression_weight": {"key": "searchExpressionWeight", "type": "float"},
        "soc_codes": {"key": "socCodes", "type": "[int]"},
        "soc_codes_weight": {"key": "socCodesWeight", "type": "float"},
        "soc_codes_required": {"key": "socCodesRequired", "type": "bool"},
        "management_level": {"key": "managementLevel", "type": "str"},
        "management_level_required": {"key": "managementLevelRequired", "type": "bool"},
        "management_level_weight": {"key": "managementLevelWeight", "type": "float"},
        "custom_data": {"key": "customData", "type": "[SearchParametersCustomData]"},
    }

    def __init__(self, **kwargs):
        """
        :keyword indices: Required.
        :paramtype indices: list[str]
        :keyword resume: A random string that uniquely identify the resource.
        :paramtype resume: str
        :keyword job_titles:
        :paramtype job_titles: list[str]
        :keyword job_titles_required:
        :paramtype job_titles_required: bool
        :keyword job_titles_weight:
        :paramtype job_titles_weight: float
        :keyword total_years_experience:
        :paramtype total_years_experience: float
        :keyword years_experience_required:
        :paramtype years_experience_required: bool
        :keyword years_experience_weight:
        :paramtype years_experience_weight: float
        :keyword locations:
        :paramtype locations: list[~affinda.models.ResumeSearchParametersLocation]
        :keyword locations_weight:
        :paramtype locations_weight: float
        :keyword locations_required:
        :paramtype locations_required: bool
        :keyword skills:
        :paramtype skills: list[~affinda.models.ResumeSearchParametersSkill]
        :keyword skills_weight:
        :paramtype skills_weight: float
        :keyword languages:
        :paramtype languages: list[~affinda.models.ResumeSearchParametersSkill]
        :keyword languages_weight:
        :paramtype languages_weight: float
        :keyword degrees:
        :paramtype degrees: list[str]
        :keyword degrees_required:
        :paramtype degrees_required: bool
        :keyword degree_types:
        :paramtype degree_types: list[str or ~affinda.models.EducationLevel]
        :keyword degree_types_required:
        :paramtype degree_types_required: bool
        :keyword education_weight:
        :paramtype education_weight: float
        :keyword search_expression:
        :paramtype search_expression: str
        :keyword search_expression_required:
        :paramtype search_expression_required: bool
        :keyword search_expression_weight:
        :paramtype search_expression_weight: float
        :keyword soc_codes:
        :paramtype soc_codes: list[int]
        :keyword soc_codes_weight:
        :paramtype soc_codes_weight: float
        :keyword soc_codes_required:
        :paramtype soc_codes_required: bool
        :keyword management_level: Known values are: "None", "Low", "Mid", "Upper".
        :paramtype management_level: str or ~affinda.models.ManagementLevel
        :keyword management_level_required:
        :paramtype management_level_required: bool
        :keyword management_level_weight:
        :paramtype management_level_weight: float
        :keyword custom_data:
        :paramtype custom_data: list[~affinda.models.SearchParametersCustomData]
        """
        super(JobDescriptionSearchParameters, self).__init__(**kwargs)
        self.indices = kwargs["indices"]
        self.resume = kwargs.get("resume", None)
        self.job_titles = kwargs.get("job_titles", None)
        self.job_titles_required = kwargs.get("job_titles_required", None)
        self.job_titles_weight = kwargs.get("job_titles_weight", None)
        self.total_years_experience = kwargs.get("total_years_experience", None)
        self.years_experience_required = kwargs.get("years_experience_required", None)
        self.years_experience_weight = kwargs.get("years_experience_weight", None)
        self.locations = kwargs.get("locations", None)
        self.locations_weight = kwargs.get("locations_weight", None)
        self.locations_required = kwargs.get("locations_required", None)
        self.skills = kwargs.get("skills", None)
        self.skills_weight = kwargs.get("skills_weight", None)
        self.languages = kwargs.get("languages", None)
        self.languages_weight = kwargs.get("languages_weight", None)
        self.degrees = kwargs.get("degrees", None)
        self.degrees_required = kwargs.get("degrees_required", None)
        self.degree_types = kwargs.get("degree_types", None)
        self.degree_types_required = kwargs.get("degree_types_required", None)
        self.education_weight = kwargs.get("education_weight", None)
        self.search_expression = kwargs.get("search_expression", None)
        self.search_expression_required = kwargs.get("search_expression_required", None)
        self.search_expression_weight = kwargs.get("search_expression_weight", None)
        self.soc_codes = kwargs.get("soc_codes", None)
        self.soc_codes_weight = kwargs.get("soc_codes_weight", None)
        self.soc_codes_required = kwargs.get("soc_codes_required", None)
        self.management_level = kwargs.get("management_level", None)
        self.management_level_required = kwargs.get("management_level_required", None)
        self.management_level_weight = kwargs.get("management_level_weight", None)
        self.custom_data = kwargs.get("custom_data", None)


class JobDescriptionSearchResult(msrest.serialization.Model):
    """JobDescriptionSearchResult.

    All required parameters must be populated in order to send to Azure.

    :ivar identifier: Required. A random string that uniquely identify the resource.
    :vartype identifier: str
    :ivar score: Required.
    :vartype score: float
    :ivar pdf: Required.
    :vartype pdf: str
    :ivar job_title: Required.
    :vartype job_title: ~affinda.models.JobTitleSearchScoreComponent
    :ivar management_level: Required.
    :vartype management_level: ~affinda.models.ManagementLevelSearchScoreComponent
    :ivar experience: Required.
    :vartype experience: ~affinda.models.ExperienceSearchScoreComponent
    :ivar skills: Required.
    :vartype skills: ~affinda.models.SkillsSearchScoreComponent
    :ivar languages: Required.
    :vartype languages: ~affinda.models.LanguagesSearchScoreComponent
    :ivar location: Required.
    :vartype location: ~affinda.models.LocationSearchScoreComponent
    :ivar education: Required.
    :vartype education: ~affinda.models.EducationSearchScoreComponent
    :ivar occupation_group:
    :vartype occupation_group: ~affinda.models.OccupationGroupSearchScoreComponent
    :ivar search_expression: Required.
    :vartype search_expression: ~affinda.models.SearchExpressionSearchScoreComponent
    :ivar organization_name: Required.
    :vartype organization_name: str
    :ivar custom_data: Required. Dictionary of
     <componentsnqbw24schemascustomdatasearchscorecomponentadditionalproperties>.
    :vartype custom_data: dict[str,
     ~affinda.models.ComponentsNqbw24SchemasCustomdatasearchscorecomponentAdditionalproperties]
    """

    _validation = {
        "identifier": {"required": True},
        "score": {"required": True},
        "pdf": {"required": True},
        "job_title": {"required": True},
        "management_level": {"required": True},
        "experience": {"required": True},
        "skills": {"required": True},
        "languages": {"required": True},
        "location": {"required": True},
        "education": {"required": True},
        "search_expression": {"required": True},
        "organization_name": {"required": True},
        "custom_data": {"required": True},
    }

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
        "score": {"key": "score", "type": "float"},
        "pdf": {"key": "pdf", "type": "str"},
        "job_title": {"key": "jobTitle", "type": "JobTitleSearchScoreComponent"},
        "management_level": {
            "key": "managementLevel",
            "type": "ManagementLevelSearchScoreComponent",
        },
        "experience": {"key": "experience", "type": "ExperienceSearchScoreComponent"},
        "skills": {"key": "skills", "type": "SkillsSearchScoreComponent"},
        "languages": {"key": "languages", "type": "LanguagesSearchScoreComponent"},
        "location": {"key": "location", "type": "LocationSearchScoreComponent"},
        "education": {"key": "education", "type": "EducationSearchScoreComponent"},
        "occupation_group": {
            "key": "occupationGroup",
            "type": "OccupationGroupSearchScoreComponent",
        },
        "search_expression": {
            "key": "searchExpression",
            "type": "SearchExpressionSearchScoreComponent",
        },
        "organization_name": {"key": "organizationName", "type": "str"},
        "custom_data": {
            "key": "customData",
            "type": "{ComponentsNqbw24SchemasCustomdatasearchscorecomponentAdditionalproperties}",
        },
    }

    def __init__(self, **kwargs):
        """
        :keyword identifier: Required. A random string that uniquely identify the resource.
        :paramtype identifier: str
        :keyword score: Required.
        :paramtype score: float
        :keyword pdf: Required.
        :paramtype pdf: str
        :keyword job_title: Required.
        :paramtype job_title: ~affinda.models.JobTitleSearchScoreComponent
        :keyword management_level: Required.
        :paramtype management_level: ~affinda.models.ManagementLevelSearchScoreComponent
        :keyword experience: Required.
        :paramtype experience: ~affinda.models.ExperienceSearchScoreComponent
        :keyword skills: Required.
        :paramtype skills: ~affinda.models.SkillsSearchScoreComponent
        :keyword languages: Required.
        :paramtype languages: ~affinda.models.LanguagesSearchScoreComponent
        :keyword location: Required.
        :paramtype location: ~affinda.models.LocationSearchScoreComponent
        :keyword education: Required.
        :paramtype education: ~affinda.models.EducationSearchScoreComponent
        :keyword occupation_group:
        :paramtype occupation_group: ~affinda.models.OccupationGroupSearchScoreComponent
        :keyword search_expression: Required.
        :paramtype search_expression: ~affinda.models.SearchExpressionSearchScoreComponent
        :keyword organization_name: Required.
        :paramtype organization_name: str
        :keyword custom_data: Required. Dictionary of
         <componentsnqbw24schemascustomdatasearchscorecomponentadditionalproperties>.
        :paramtype custom_data: dict[str,
         ~affinda.models.ComponentsNqbw24SchemasCustomdatasearchscorecomponentAdditionalproperties]
        """
        super(JobDescriptionSearchResult, self).__init__(**kwargs)
        self.identifier = kwargs["identifier"]
        self.score = kwargs["score"]
        self.pdf = kwargs["pdf"]
        self.job_title = kwargs["job_title"]
        self.management_level = kwargs["management_level"]
        self.experience = kwargs["experience"]
        self.skills = kwargs["skills"]
        self.languages = kwargs["languages"]
        self.location = kwargs["location"]
        self.education = kwargs["education"]
        self.occupation_group = kwargs.get("occupation_group", None)
        self.search_expression = kwargs["search_expression"]
        self.organization_name = kwargs["organization_name"]
        self.custom_data = kwargs["custom_data"]


class JobTitleAnnotation(Annotation):
    """JobTitleAnnotation.

    All required parameters must be populated in order to send to Azure.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id: Required. Annotation's ID.
    :vartype id: int
    :ivar rectangle: Required. x/y coordinates for the rectangular bounding box containing the
     data.
    :vartype rectangle: ~affinda.models.Rectangle
    :ivar rectangles: Required. x/y coordinates for the rectangles containing the data. An
     annotation can be contained within multiple rectangles.
    :vartype rectangles: list[~affinda.models.Rectangle]
    :ivar document: Required. Unique identifier for the document.
    :vartype document: str
    :ivar page_index: Required. The page number within the document, starting from 0.
    :vartype page_index: int
    :ivar raw: Required. Raw data extracted from the before any post-processing.
    :vartype raw: str
    :ivar confidence: Required. The overall confidence that the model's prediction is correct.
    :vartype confidence: float
    :ivar classification_confidence: Required. The model's confidence that the text has been
     classified correctly.
    :vartype classification_confidence: float
    :ivar text_extraction_confidence: Required. If the document was submitted as an image, this is
     the confidence that the text in the image has been correctly read by the model.
    :vartype text_extraction_confidence: float
    :ivar is_verified: Required. Indicates whether the data has been validated, either by a human
     using our validation tool or through auto-validation rules.
    :vartype is_verified: bool
    :ivar is_client_verified: Required. Indicates whether the data has been validated by a human.
    :vartype is_client_verified: bool
    :ivar is_auto_verified: Required. Indicates whether the data has been auto-validated.
    :vartype is_auto_verified: bool
    :ivar data_point: Required. Data point's identifier.
    :vartype data_point: str
    :ivar content_type: Required. The different data types of annotations. Known values are:
     "text", "integer", "float", "decimal", "date", "datetime", "daterange", "boolean", "enum",
     "location", "phonenumber", "json", "table", "expectedremuneration", "jobtitle", "language",
     "skill", "yearsexperience", "group", "table_deprecated", "url", "image".
    :vartype content_type: str or ~affinda.models.AnnotationContentType
    :ivar parent: The parent annotation's ID.
    :vartype parent: int
    :ivar parsed: Years of experience range.
    :vartype parsed: ~affinda.models.JobTitleAnnotationParsed
    """

    _validation = {
        "id": {"required": True, "minimum": 1},
        "rectangle": {"required": True},
        "rectangles": {"required": True},
        "document": {"required": True},
        "page_index": {"required": True, "minimum": 0},
        "raw": {"required": True},
        "confidence": {"required": True},
        "classification_confidence": {"required": True},
        "text_extraction_confidence": {"required": True},
        "is_verified": {"required": True},
        "is_client_verified": {"required": True},
        "is_auto_verified": {"required": True},
        "data_point": {"required": True},
        "content_type": {"required": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "int"},
        "rectangle": {"key": "rectangle", "type": "Rectangle"},
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "document": {"key": "document", "type": "str"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "confidence": {"key": "confidence", "type": "float"},
        "classification_confidence": {"key": "classificationConfidence", "type": "float"},
        "text_extraction_confidence": {"key": "textExtractionConfidence", "type": "float"},
        "is_verified": {"key": "isVerified", "type": "bool"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "is_auto_verified": {"key": "isAutoVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "content_type": {"key": "contentType", "type": "str"},
        "parent": {"key": "parent", "type": "int"},
        "parsed": {"key": "parsed", "type": "JobTitleAnnotationParsed"},
    }

    def __init__(self, **kwargs):
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword id: Required. Annotation's ID.
        :paramtype id: int
        :keyword rectangle: Required. x/y coordinates for the rectangular bounding box containing the
         data.
        :paramtype rectangle: ~affinda.models.Rectangle
        :keyword rectangles: Required. x/y coordinates for the rectangles containing the data. An
         annotation can be contained within multiple rectangles.
        :paramtype rectangles: list[~affinda.models.Rectangle]
        :keyword document: Required. Unique identifier for the document.
        :paramtype document: str
        :keyword page_index: Required. The page number within the document, starting from 0.
        :paramtype page_index: int
        :keyword raw: Required. Raw data extracted from the before any post-processing.
        :paramtype raw: str
        :keyword confidence: Required. The overall confidence that the model's prediction is correct.
        :paramtype confidence: float
        :keyword classification_confidence: Required. The model's confidence that the text has been
         classified correctly.
        :paramtype classification_confidence: float
        :keyword text_extraction_confidence: Required. If the document was submitted as an image, this
         is the confidence that the text in the image has been correctly read by the model.
        :paramtype text_extraction_confidence: float
        :keyword is_verified: Required. Indicates whether the data has been validated, either by a
         human using our validation tool or through auto-validation rules.
        :paramtype is_verified: bool
        :keyword is_client_verified: Required. Indicates whether the data has been validated by a
         human.
        :paramtype is_client_verified: bool
        :keyword is_auto_verified: Required. Indicates whether the data has been auto-validated.
        :paramtype is_auto_verified: bool
        :keyword data_point: Required. Data point's identifier.
        :paramtype data_point: str
        :keyword content_type: Required. The different data types of annotations. Known values are:
         "text", "integer", "float", "decimal", "date", "datetime", "daterange", "boolean", "enum",
         "location", "phonenumber", "json", "table", "expectedremuneration", "jobtitle", "language",
         "skill", "yearsexperience", "group", "table_deprecated", "url", "image".
        :paramtype content_type: str or ~affinda.models.AnnotationContentType
        :keyword parent: The parent annotation's ID.
        :paramtype parent: int
        :keyword parsed: Years of experience range.
        :paramtype parsed: ~affinda.models.JobTitleAnnotationParsed
        """
        super(JobTitleAnnotation, self).__init__(**kwargs)
        self.parsed = kwargs.get("parsed", None)


class JobTitleAnnotationParsed(msrest.serialization.Model):
    """Years of experience range.

    :ivar name:
    :vartype name: str
    :ivar management_level:
    :vartype management_level: str
    :ivar classification:
    :vartype classification: ~affinda.models.JobTitleAnnotationParsedClassification
    """

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "management_level": {"key": "managementLevel", "type": "str"},
        "classification": {
            "key": "classification",
            "type": "JobTitleAnnotationParsedClassification",
        },
    }

    def __init__(self, **kwargs):
        """
        :keyword name:
        :paramtype name: str
        :keyword management_level:
        :paramtype management_level: str
        :keyword classification:
        :paramtype classification: ~affinda.models.JobTitleAnnotationParsedClassification
        """
        super(JobTitleAnnotationParsed, self).__init__(**kwargs)
        self.name = kwargs.get("name", None)
        self.management_level = kwargs.get("management_level", None)
        self.classification = kwargs.get("classification", None)


class JobTitleAnnotationParsedClassification(msrest.serialization.Model):
    """JobTitleAnnotationParsedClassification.

    :ivar soc_code:
    :vartype soc_code: float
    :ivar title:
    :vartype title: str
    :ivar minor_group:
    :vartype minor_group: str
    :ivar sub_major_group:
    :vartype sub_major_group: str
    :ivar major_group:
    :vartype major_group: str
    :ivar minor_group_code: The 4 digit code representing the SOC2020 classification for this job
     title.
    :vartype minor_group_code: int
    :ivar sub_major_group_code: The 4 digit code representing the SOC2020 classification for this
     job title.
    :vartype sub_major_group_code: int
    :ivar major_group_code: The 4 digit code representing the SOC2020 classification for this job
     title.
    :vartype major_group_code: int
    """

    _validation = {
        "minor_group_code": {"maximum": 9999, "minimum": 1},
        "sub_major_group_code": {"maximum": 9999, "minimum": 1},
        "major_group_code": {"maximum": 9999, "minimum": 1},
    }

    _attribute_map = {
        "soc_code": {"key": "socCode", "type": "float"},
        "title": {"key": "title", "type": "str"},
        "minor_group": {"key": "minorGroup", "type": "str"},
        "sub_major_group": {"key": "subMajorGroup", "type": "str"},
        "major_group": {"key": "majorGroup", "type": "str"},
        "minor_group_code": {"key": "minorGroupCode", "type": "int"},
        "sub_major_group_code": {"key": "subMajorGroupCode", "type": "int"},
        "major_group_code": {"key": "majorGroupCode", "type": "int"},
    }

    def __init__(self, **kwargs):
        """
        :keyword soc_code:
        :paramtype soc_code: float
        :keyword title:
        :paramtype title: str
        :keyword minor_group:
        :paramtype minor_group: str
        :keyword sub_major_group:
        :paramtype sub_major_group: str
        :keyword major_group:
        :paramtype major_group: str
        :keyword minor_group_code: The 4 digit code representing the SOC2020 classification for this
         job title.
        :paramtype minor_group_code: int
        :keyword sub_major_group_code: The 4 digit code representing the SOC2020 classification for
         this job title.
        :paramtype sub_major_group_code: int
        :keyword major_group_code: The 4 digit code representing the SOC2020 classification for this
         job title.
        :paramtype major_group_code: int
        """
        super(JobTitleAnnotationParsedClassification, self).__init__(**kwargs)
        self.soc_code = kwargs.get("soc_code", None)
        self.title = kwargs.get("title", None)
        self.minor_group = kwargs.get("minor_group", None)
        self.sub_major_group = kwargs.get("sub_major_group", None)
        self.major_group = kwargs.get("major_group", None)
        self.minor_group_code = kwargs.get("minor_group_code", None)
        self.sub_major_group_code = kwargs.get("sub_major_group_code", None)
        self.major_group_code = kwargs.get("major_group_code", None)


class JobTitleParsed(msrest.serialization.Model):
    """JobTitleParsed.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar parsed: Matching job title to extracted text.
    :vartype parsed: ~affinda.models.JobTitleParsedParsed
    """

    _validation = {
        "parsed": {"readonly": True},
    }

    _attribute_map = {
        "parsed": {"key": "parsed", "type": "JobTitleParsedParsed"},
    }

    def __init__(self, **kwargs):
        """ """
        super(JobTitleParsed, self).__init__(**kwargs)
        self.parsed = None


class JobTitleAnnotationUpdate(AnnotationBase, JobTitleParsed):
    """JobTitleAnnotationUpdate.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar parsed: Matching job title to extracted text.
    :vartype parsed: ~affinda.models.JobTitleParsedParsed
    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id:
    :vartype id: int
    :ivar rectangle:
    :vartype rectangle: ~affinda.models.Rectangle
    :ivar rectangles:
    :vartype rectangles: list[~affinda.models.Rectangle]
    :ivar page_index:
    :vartype page_index: int
    :ivar raw:
    :vartype raw: str
    :ivar confidence: The overall confidence that the model's prediction is correct.
    :vartype confidence: float
    :ivar classification_confidence: The model's confidence that the text has been classified
     correctly.
    :vartype classification_confidence: float
    :ivar text_extraction_confidence: If the document was submitted as an image, this is the
     confidence that the text in the image has been correctly read by the model.
    :vartype text_extraction_confidence: float
    :ivar is_verified:
    :vartype is_verified: bool
    :ivar is_client_verified:
    :vartype is_client_verified: bool
    :ivar is_auto_verified:
    :vartype is_auto_verified: bool
    :ivar data_point:
    :vartype data_point: str
    :ivar content_type:
    :vartype content_type: str
    """

    _validation = {
        "parsed": {"readonly": True},
        "rectangles": {"readonly": True},
    }

    _attribute_map = {
        "parsed": {"key": "parsed", "type": "JobTitleParsedParsed"},
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "int"},
        "rectangle": {"key": "rectangle", "type": "Rectangle"},
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "confidence": {"key": "confidence", "type": "float"},
        "classification_confidence": {"key": "classificationConfidence", "type": "float"},
        "text_extraction_confidence": {"key": "textExtractionConfidence", "type": "float"},
        "is_verified": {"key": "isVerified", "type": "bool"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "is_auto_verified": {"key": "isAutoVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "content_type": {"key": "contentType", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword id:
        :paramtype id: int
        :keyword rectangle:
        :paramtype rectangle: ~affinda.models.Rectangle
        :keyword page_index:
        :paramtype page_index: int
        :keyword raw:
        :paramtype raw: str
        :keyword confidence: The overall confidence that the model's prediction is correct.
        :paramtype confidence: float
        :keyword classification_confidence: The model's confidence that the text has been classified
         correctly.
        :paramtype classification_confidence: float
        :keyword text_extraction_confidence: If the document was submitted as an image, this is the
         confidence that the text in the image has been correctly read by the model.
        :paramtype text_extraction_confidence: float
        :keyword is_verified:
        :paramtype is_verified: bool
        :keyword is_client_verified:
        :paramtype is_client_verified: bool
        :keyword is_auto_verified:
        :paramtype is_auto_verified: bool
        :keyword data_point:
        :paramtype data_point: str
        :keyword content_type:
        :paramtype content_type: str
        """
        super(JobTitleAnnotationUpdate, self).__init__(**kwargs)
        self.parsed = None
        self.additional_properties = kwargs.get("additional_properties", None)
        self.id = kwargs.get("id", None)
        self.rectangle = kwargs.get("rectangle", None)
        self.rectangles = None
        self.page_index = kwargs.get("page_index", None)
        self.raw = kwargs.get("raw", None)
        self.confidence = kwargs.get("confidence", None)
        self.classification_confidence = kwargs.get("classification_confidence", None)
        self.text_extraction_confidence = kwargs.get("text_extraction_confidence", None)
        self.is_verified = kwargs.get("is_verified", None)
        self.is_client_verified = kwargs.get("is_client_verified", None)
        self.is_auto_verified = kwargs.get("is_auto_verified", None)
        self.data_point = kwargs.get("data_point", None)
        self.content_type = kwargs.get("content_type", None)


class JobTitleParsedClassification(msrest.serialization.Model):
    """JobTitleParsedClassification.

    :ivar soc_code:
    :vartype soc_code: float
    :ivar title:
    :vartype title: str
    :ivar minor_group:
    :vartype minor_group: str
    :ivar sub_major_group:
    :vartype sub_major_group: str
    :ivar major_group:
    :vartype major_group: str
    :ivar minor_group_code: The 4 digit code representing the SOC2020 classification for this job
     title.
    :vartype minor_group_code: int
    :ivar sub_major_group_code: The 4 digit code representing the SOC2020 classification for this
     job title.
    :vartype sub_major_group_code: int
    :ivar major_group_code: The 4 digit code representing the SOC2020 classification for this job
     title.
    :vartype major_group_code: int
    """

    _attribute_map = {
        "soc_code": {"key": "socCode", "type": "float"},
        "title": {"key": "title", "type": "str"},
        "minor_group": {"key": "minorGroup", "type": "str"},
        "sub_major_group": {"key": "subMajorGroup", "type": "str"},
        "major_group": {"key": "majorGroup", "type": "str"},
        "minor_group_code": {"key": "minorGroupCode", "type": "int"},
        "sub_major_group_code": {"key": "subMajorGroupCode", "type": "int"},
        "major_group_code": {"key": "majorGroupCode", "type": "int"},
    }

    def __init__(self, **kwargs):
        """
        :keyword soc_code:
        :paramtype soc_code: float
        :keyword title:
        :paramtype title: str
        :keyword minor_group:
        :paramtype minor_group: str
        :keyword sub_major_group:
        :paramtype sub_major_group: str
        :keyword major_group:
        :paramtype major_group: str
        :keyword minor_group_code: The 4 digit code representing the SOC2020 classification for this
         job title.
        :paramtype minor_group_code: int
        :keyword sub_major_group_code: The 4 digit code representing the SOC2020 classification for
         this job title.
        :paramtype sub_major_group_code: int
        :keyword major_group_code: The 4 digit code representing the SOC2020 classification for this
         job title.
        :paramtype major_group_code: int
        """
        super(JobTitleParsedClassification, self).__init__(**kwargs)
        self.soc_code = kwargs.get("soc_code", None)
        self.title = kwargs.get("title", None)
        self.minor_group = kwargs.get("minor_group", None)
        self.sub_major_group = kwargs.get("sub_major_group", None)
        self.major_group = kwargs.get("major_group", None)
        self.minor_group_code = kwargs.get("minor_group_code", None)
        self.sub_major_group_code = kwargs.get("sub_major_group_code", None)
        self.major_group_code = kwargs.get("major_group_code", None)


class JobTitleParsedParsed(msrest.serialization.Model):
    """Matching job title to extracted text.

    :ivar name:
    :vartype name: str
    :ivar management_level:
    :vartype management_level: str
    :ivar classification:
    :vartype classification: ~affinda.models.JobTitleParsedClassification
    """

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "management_level": {"key": "managementLevel", "type": "str"},
        "classification": {"key": "classification", "type": "JobTitleParsedClassification"},
    }

    def __init__(self, **kwargs):
        """
        :keyword name:
        :paramtype name: str
        :keyword management_level:
        :paramtype management_level: str
        :keyword classification:
        :paramtype classification: ~affinda.models.JobTitleParsedClassification
        """
        super(JobTitleParsedParsed, self).__init__(**kwargs)
        self.name = kwargs.get("name", None)
        self.management_level = kwargs.get("management_level", None)
        self.classification = kwargs.get("classification", None)


class JobTitleSearchScoreComponent(msrest.serialization.Model):
    """JobTitleSearchScoreComponent.

    All required parameters must be populated in order to send to Azure.

    :ivar value:
    :vartype value: str
    :ivar label: Required.
    :vartype label: str
    :ivar score:
    :vartype score: float
    """

    _validation = {
        "label": {"required": True},
    }

    _attribute_map = {
        "value": {"key": "value", "type": "str"},
        "label": {"key": "label", "type": "str"},
        "score": {"key": "score", "type": "float"},
    }

    def __init__(self, **kwargs):
        """
        :keyword value:
        :paramtype value: str
        :keyword label: Required.
        :paramtype label: str
        :keyword score:
        :paramtype score: float
        """
        super(JobTitleSearchScoreComponent, self).__init__(**kwargs)
        self.value = kwargs.get("value", None)
        self.label = kwargs["label"]
        self.score = kwargs.get("score", None)


class LanguageAnnotation(Annotation):
    """LanguageAnnotation.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id: Required. Annotation's ID.
    :vartype id: int
    :ivar rectangle: Required. x/y coordinates for the rectangular bounding box containing the
     data.
    :vartype rectangle: ~affinda.models.Rectangle
    :ivar rectangles: Required. x/y coordinates for the rectangles containing the data. An
     annotation can be contained within multiple rectangles.
    :vartype rectangles: list[~affinda.models.Rectangle]
    :ivar document: Required. Unique identifier for the document.
    :vartype document: str
    :ivar page_index: Required. The page number within the document, starting from 0.
    :vartype page_index: int
    :ivar raw: Required. Raw data extracted from the before any post-processing.
    :vartype raw: str
    :ivar confidence: Required. The overall confidence that the model's prediction is correct.
    :vartype confidence: float
    :ivar classification_confidence: Required. The model's confidence that the text has been
     classified correctly.
    :vartype classification_confidence: float
    :ivar text_extraction_confidence: Required. If the document was submitted as an image, this is
     the confidence that the text in the image has been correctly read by the model.
    :vartype text_extraction_confidence: float
    :ivar is_verified: Required. Indicates whether the data has been validated, either by a human
     using our validation tool or through auto-validation rules.
    :vartype is_verified: bool
    :ivar is_client_verified: Required. Indicates whether the data has been validated by a human.
    :vartype is_client_verified: bool
    :ivar is_auto_verified: Required. Indicates whether the data has been auto-validated.
    :vartype is_auto_verified: bool
    :ivar data_point: Required. Data point's identifier.
    :vartype data_point: str
    :ivar content_type: Required. The different data types of annotations. Known values are:
     "text", "integer", "float", "decimal", "date", "datetime", "daterange", "boolean", "enum",
     "location", "phonenumber", "json", "table", "expectedremuneration", "jobtitle", "language",
     "skill", "yearsexperience", "group", "table_deprecated", "url", "image".
    :vartype content_type: str or ~affinda.models.AnnotationContentType
    :ivar parent: The parent annotation's ID.
    :vartype parent: int
    :ivar parsed:
    :vartype parsed: str
    """

    _validation = {
        "id": {"required": True, "minimum": 1},
        "rectangle": {"required": True},
        "rectangles": {"required": True},
        "document": {"required": True},
        "page_index": {"required": True, "minimum": 0},
        "raw": {"required": True},
        "confidence": {"required": True},
        "classification_confidence": {"required": True},
        "text_extraction_confidence": {"required": True},
        "is_verified": {"required": True},
        "is_client_verified": {"required": True},
        "is_auto_verified": {"required": True},
        "data_point": {"required": True},
        "content_type": {"required": True},
        "parsed": {"readonly": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "int"},
        "rectangle": {"key": "rectangle", "type": "Rectangle"},
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "document": {"key": "document", "type": "str"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "confidence": {"key": "confidence", "type": "float"},
        "classification_confidence": {"key": "classificationConfidence", "type": "float"},
        "text_extraction_confidence": {"key": "textExtractionConfidence", "type": "float"},
        "is_verified": {"key": "isVerified", "type": "bool"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "is_auto_verified": {"key": "isAutoVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "content_type": {"key": "contentType", "type": "str"},
        "parent": {"key": "parent", "type": "int"},
        "parsed": {"key": "parsed", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword id: Required. Annotation's ID.
        :paramtype id: int
        :keyword rectangle: Required. x/y coordinates for the rectangular bounding box containing the
         data.
        :paramtype rectangle: ~affinda.models.Rectangle
        :keyword rectangles: Required. x/y coordinates for the rectangles containing the data. An
         annotation can be contained within multiple rectangles.
        :paramtype rectangles: list[~affinda.models.Rectangle]
        :keyword document: Required. Unique identifier for the document.
        :paramtype document: str
        :keyword page_index: Required. The page number within the document, starting from 0.
        :paramtype page_index: int
        :keyword raw: Required. Raw data extracted from the before any post-processing.
        :paramtype raw: str
        :keyword confidence: Required. The overall confidence that the model's prediction is correct.
        :paramtype confidence: float
        :keyword classification_confidence: Required. The model's confidence that the text has been
         classified correctly.
        :paramtype classification_confidence: float
        :keyword text_extraction_confidence: Required. If the document was submitted as an image, this
         is the confidence that the text in the image has been correctly read by the model.
        :paramtype text_extraction_confidence: float
        :keyword is_verified: Required. Indicates whether the data has been validated, either by a
         human using our validation tool or through auto-validation rules.
        :paramtype is_verified: bool
        :keyword is_client_verified: Required. Indicates whether the data has been validated by a
         human.
        :paramtype is_client_verified: bool
        :keyword is_auto_verified: Required. Indicates whether the data has been auto-validated.
        :paramtype is_auto_verified: bool
        :keyword data_point: Required. Data point's identifier.
        :paramtype data_point: str
        :keyword content_type: Required. The different data types of annotations. Known values are:
         "text", "integer", "float", "decimal", "date", "datetime", "daterange", "boolean", "enum",
         "location", "phonenumber", "json", "table", "expectedremuneration", "jobtitle", "language",
         "skill", "yearsexperience", "group", "table_deprecated", "url", "image".
        :paramtype content_type: str or ~affinda.models.AnnotationContentType
        :keyword parent: The parent annotation's ID.
        :paramtype parent: int
        """
        super(LanguageAnnotation, self).__init__(**kwargs)
        self.parsed = None


class LanguageAnnotationUpdate(AnnotationBase):
    """LanguageAnnotationUpdate.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id:
    :vartype id: int
    :ivar rectangle:
    :vartype rectangle: ~affinda.models.Rectangle
    :ivar rectangles:
    :vartype rectangles: list[~affinda.models.Rectangle]
    :ivar page_index:
    :vartype page_index: int
    :ivar raw:
    :vartype raw: str
    :ivar confidence: The overall confidence that the model's prediction is correct.
    :vartype confidence: float
    :ivar classification_confidence: The model's confidence that the text has been classified
     correctly.
    :vartype classification_confidence: float
    :ivar text_extraction_confidence: If the document was submitted as an image, this is the
     confidence that the text in the image has been correctly read by the model.
    :vartype text_extraction_confidence: float
    :ivar is_verified:
    :vartype is_verified: bool
    :ivar is_client_verified:
    :vartype is_client_verified: bool
    :ivar is_auto_verified:
    :vartype is_auto_verified: bool
    :ivar data_point:
    :vartype data_point: str
    :ivar content_type:
    :vartype content_type: str
    :ivar parsed:
    :vartype parsed: str
    """

    _validation = {
        "rectangles": {"readonly": True},
        "parsed": {"readonly": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "int"},
        "rectangle": {"key": "rectangle", "type": "Rectangle"},
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "confidence": {"key": "confidence", "type": "float"},
        "classification_confidence": {"key": "classificationConfidence", "type": "float"},
        "text_extraction_confidence": {"key": "textExtractionConfidence", "type": "float"},
        "is_verified": {"key": "isVerified", "type": "bool"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "is_auto_verified": {"key": "isAutoVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "content_type": {"key": "contentType", "type": "str"},
        "parsed": {"key": "parsed", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword id:
        :paramtype id: int
        :keyword rectangle:
        :paramtype rectangle: ~affinda.models.Rectangle
        :keyword page_index:
        :paramtype page_index: int
        :keyword raw:
        :paramtype raw: str
        :keyword confidence: The overall confidence that the model's prediction is correct.
        :paramtype confidence: float
        :keyword classification_confidence: The model's confidence that the text has been classified
         correctly.
        :paramtype classification_confidence: float
        :keyword text_extraction_confidence: If the document was submitted as an image, this is the
         confidence that the text in the image has been correctly read by the model.
        :paramtype text_extraction_confidence: float
        :keyword is_verified:
        :paramtype is_verified: bool
        :keyword is_client_verified:
        :paramtype is_client_verified: bool
        :keyword is_auto_verified:
        :paramtype is_auto_verified: bool
        :keyword data_point:
        :paramtype data_point: str
        :keyword content_type:
        :paramtype content_type: str
        """
        super(LanguageAnnotationUpdate, self).__init__(**kwargs)
        self.parsed = None


class LanguagesSearchScoreComponent(msrest.serialization.Model):
    """LanguagesSearchScoreComponent.

    All required parameters must be populated in order to send to Azure.

    :ivar value:
    :vartype value: str
    :ivar label: Required.
    :vartype label: str
    :ivar score:
    :vartype score: float
    """

    _validation = {
        "label": {"required": True},
    }

    _attribute_map = {
        "value": {"key": "value", "type": "str"},
        "label": {"key": "label", "type": "str"},
        "score": {"key": "score", "type": "float"},
    }

    def __init__(self, **kwargs):
        """
        :keyword value:
        :paramtype value: str
        :keyword label: Required.
        :paramtype label: str
        :keyword score:
        :paramtype score: float
        """
        super(LanguagesSearchScoreComponent, self).__init__(**kwargs)
        self.value = kwargs.get("value", None)
        self.label = kwargs["label"]
        self.score = kwargs.get("score", None)


class LocationAnnotation(Annotation):
    """LocationAnnotation.

    All required parameters must be populated in order to send to Azure.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id: Required. Annotation's ID.
    :vartype id: int
    :ivar rectangle: Required. x/y coordinates for the rectangular bounding box containing the
     data.
    :vartype rectangle: ~affinda.models.Rectangle
    :ivar rectangles: Required. x/y coordinates for the rectangles containing the data. An
     annotation can be contained within multiple rectangles.
    :vartype rectangles: list[~affinda.models.Rectangle]
    :ivar document: Required. Unique identifier for the document.
    :vartype document: str
    :ivar page_index: Required. The page number within the document, starting from 0.
    :vartype page_index: int
    :ivar raw: Required. Raw data extracted from the before any post-processing.
    :vartype raw: str
    :ivar confidence: Required. The overall confidence that the model's prediction is correct.
    :vartype confidence: float
    :ivar classification_confidence: Required. The model's confidence that the text has been
     classified correctly.
    :vartype classification_confidence: float
    :ivar text_extraction_confidence: Required. If the document was submitted as an image, this is
     the confidence that the text in the image has been correctly read by the model.
    :vartype text_extraction_confidence: float
    :ivar is_verified: Required. Indicates whether the data has been validated, either by a human
     using our validation tool or through auto-validation rules.
    :vartype is_verified: bool
    :ivar is_client_verified: Required. Indicates whether the data has been validated by a human.
    :vartype is_client_verified: bool
    :ivar is_auto_verified: Required. Indicates whether the data has been auto-validated.
    :vartype is_auto_verified: bool
    :ivar data_point: Required. Data point's identifier.
    :vartype data_point: str
    :ivar content_type: Required. The different data types of annotations. Known values are:
     "text", "integer", "float", "decimal", "date", "datetime", "daterange", "boolean", "enum",
     "location", "phonenumber", "json", "table", "expectedremuneration", "jobtitle", "language",
     "skill", "yearsexperience", "group", "table_deprecated", "url", "image".
    :vartype content_type: str or ~affinda.models.AnnotationContentType
    :ivar parent: The parent annotation's ID.
    :vartype parent: int
    :ivar parsed:
    :vartype parsed: ~affinda.models.Location
    """

    _validation = {
        "id": {"required": True, "minimum": 1},
        "rectangle": {"required": True},
        "rectangles": {"required": True},
        "document": {"required": True},
        "page_index": {"required": True, "minimum": 0},
        "raw": {"required": True},
        "confidence": {"required": True},
        "classification_confidence": {"required": True},
        "text_extraction_confidence": {"required": True},
        "is_verified": {"required": True},
        "is_client_verified": {"required": True},
        "is_auto_verified": {"required": True},
        "data_point": {"required": True},
        "content_type": {"required": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "int"},
        "rectangle": {"key": "rectangle", "type": "Rectangle"},
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "document": {"key": "document", "type": "str"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "confidence": {"key": "confidence", "type": "float"},
        "classification_confidence": {"key": "classificationConfidence", "type": "float"},
        "text_extraction_confidence": {"key": "textExtractionConfidence", "type": "float"},
        "is_verified": {"key": "isVerified", "type": "bool"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "is_auto_verified": {"key": "isAutoVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "content_type": {"key": "contentType", "type": "str"},
        "parent": {"key": "parent", "type": "int"},
        "parsed": {"key": "parsed", "type": "Location"},
    }

    def __init__(self, **kwargs):
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword id: Required. Annotation's ID.
        :paramtype id: int
        :keyword rectangle: Required. x/y coordinates for the rectangular bounding box containing the
         data.
        :paramtype rectangle: ~affinda.models.Rectangle
        :keyword rectangles: Required. x/y coordinates for the rectangles containing the data. An
         annotation can be contained within multiple rectangles.
        :paramtype rectangles: list[~affinda.models.Rectangle]
        :keyword document: Required. Unique identifier for the document.
        :paramtype document: str
        :keyword page_index: Required. The page number within the document, starting from 0.
        :paramtype page_index: int
        :keyword raw: Required. Raw data extracted from the before any post-processing.
        :paramtype raw: str
        :keyword confidence: Required. The overall confidence that the model's prediction is correct.
        :paramtype confidence: float
        :keyword classification_confidence: Required. The model's confidence that the text has been
         classified correctly.
        :paramtype classification_confidence: float
        :keyword text_extraction_confidence: Required. If the document was submitted as an image, this
         is the confidence that the text in the image has been correctly read by the model.
        :paramtype text_extraction_confidence: float
        :keyword is_verified: Required. Indicates whether the data has been validated, either by a
         human using our validation tool or through auto-validation rules.
        :paramtype is_verified: bool
        :keyword is_client_verified: Required. Indicates whether the data has been validated by a
         human.
        :paramtype is_client_verified: bool
        :keyword is_auto_verified: Required. Indicates whether the data has been auto-validated.
        :paramtype is_auto_verified: bool
        :keyword data_point: Required. Data point's identifier.
        :paramtype data_point: str
        :keyword content_type: Required. The different data types of annotations. Known values are:
         "text", "integer", "float", "decimal", "date", "datetime", "daterange", "boolean", "enum",
         "location", "phonenumber", "json", "table", "expectedremuneration", "jobtitle", "language",
         "skill", "yearsexperience", "group", "table_deprecated", "url", "image".
        :paramtype content_type: str or ~affinda.models.AnnotationContentType
        :keyword parent: The parent annotation's ID.
        :paramtype parent: int
        :keyword parsed:
        :paramtype parsed: ~affinda.models.Location
        """
        super(LocationAnnotation, self).__init__(**kwargs)
        self.parsed = kwargs.get("parsed", None)


class LocationAnnotationUpdate(AnnotationBase):
    """LocationAnnotationUpdate.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id:
    :vartype id: int
    :ivar rectangle:
    :vartype rectangle: ~affinda.models.Rectangle
    :ivar rectangles:
    :vartype rectangles: list[~affinda.models.Rectangle]
    :ivar page_index:
    :vartype page_index: int
    :ivar raw:
    :vartype raw: str
    :ivar confidence: The overall confidence that the model's prediction is correct.
    :vartype confidence: float
    :ivar classification_confidence: The model's confidence that the text has been classified
     correctly.
    :vartype classification_confidence: float
    :ivar text_extraction_confidence: If the document was submitted as an image, this is the
     confidence that the text in the image has been correctly read by the model.
    :vartype text_extraction_confidence: float
    :ivar is_verified:
    :vartype is_verified: bool
    :ivar is_client_verified:
    :vartype is_client_verified: bool
    :ivar is_auto_verified:
    :vartype is_auto_verified: bool
    :ivar data_point:
    :vartype data_point: str
    :ivar content_type:
    :vartype content_type: str
    :ivar parsed:
    :vartype parsed: ~affinda.models.LocationAnnotationUpdateParsed
    """

    _validation = {
        "rectangles": {"readonly": True},
        "parsed": {"readonly": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "int"},
        "rectangle": {"key": "rectangle", "type": "Rectangle"},
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "confidence": {"key": "confidence", "type": "float"},
        "classification_confidence": {"key": "classificationConfidence", "type": "float"},
        "text_extraction_confidence": {"key": "textExtractionConfidence", "type": "float"},
        "is_verified": {"key": "isVerified", "type": "bool"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "is_auto_verified": {"key": "isAutoVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "content_type": {"key": "contentType", "type": "str"},
        "parsed": {"key": "parsed", "type": "LocationAnnotationUpdateParsed"},
    }

    def __init__(self, **kwargs):
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword id:
        :paramtype id: int
        :keyword rectangle:
        :paramtype rectangle: ~affinda.models.Rectangle
        :keyword page_index:
        :paramtype page_index: int
        :keyword raw:
        :paramtype raw: str
        :keyword confidence: The overall confidence that the model's prediction is correct.
        :paramtype confidence: float
        :keyword classification_confidence: The model's confidence that the text has been classified
         correctly.
        :paramtype classification_confidence: float
        :keyword text_extraction_confidence: If the document was submitted as an image, this is the
         confidence that the text in the image has been correctly read by the model.
        :paramtype text_extraction_confidence: float
        :keyword is_verified:
        :paramtype is_verified: bool
        :keyword is_client_verified:
        :paramtype is_client_verified: bool
        :keyword is_auto_verified:
        :paramtype is_auto_verified: bool
        :keyword data_point:
        :paramtype data_point: str
        :keyword content_type:
        :paramtype content_type: str
        """
        super(LocationAnnotationUpdate, self).__init__(**kwargs)
        self.parsed = None


class LocationAnnotationUpdateParsed(Location):
    """LocationAnnotationUpdateParsed.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar formatted:
    :vartype formatted: str
    :ivar postal_code:
    :vartype postal_code: str
    :ivar state:
    :vartype state: str
    :ivar state_code:
    :vartype state_code: str
    :ivar country:
    :vartype country: str
    :ivar country_code: Two letter country code (ISO 3166-1 alpha-2).
    :vartype country_code: str
    :ivar raw_input: Required.
    :vartype raw_input: str
    :ivar street_number:
    :vartype street_number: str
    :ivar street:
    :vartype street: str
    :ivar apartment_number:
    :vartype apartment_number: str
    :ivar city:
    :vartype city: str
    :ivar latitude:
    :vartype latitude: float
    :ivar longitude:
    :vartype longitude: float
    :ivar po_box:
    :vartype po_box: str
    """

    _validation = {
        "formatted": {"readonly": True},
        "postal_code": {"readonly": True},
        "state": {"readonly": True},
        "state_code": {"readonly": True},
        "country": {"readonly": True},
        "country_code": {"readonly": True},
        "raw_input": {"required": True},
        "street_number": {"readonly": True},
        "street": {"readonly": True},
        "apartment_number": {"readonly": True},
        "city": {"readonly": True},
        "latitude": {"readonly": True},
        "longitude": {"readonly": True},
        "po_box": {"readonly": True},
    }

    _attribute_map = {
        "formatted": {"key": "formatted", "type": "str"},
        "postal_code": {"key": "postalCode", "type": "str"},
        "state": {"key": "state", "type": "str"},
        "state_code": {"key": "stateCode", "type": "str"},
        "country": {"key": "country", "type": "str"},
        "country_code": {"key": "countryCode", "type": "str"},
        "raw_input": {"key": "rawInput", "type": "str"},
        "street_number": {"key": "streetNumber", "type": "str"},
        "street": {"key": "street", "type": "str"},
        "apartment_number": {"key": "apartmentNumber", "type": "str"},
        "city": {"key": "city", "type": "str"},
        "latitude": {"key": "latitude", "type": "float"},
        "longitude": {"key": "longitude", "type": "float"},
        "po_box": {"key": "poBox", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword raw_input: Required.
        :paramtype raw_input: str
        """
        super(LocationAnnotationUpdateParsed, self).__init__(**kwargs)


class LocationSearchScoreComponent(msrest.serialization.Model):
    """LocationSearchScoreComponent.

    All required parameters must be populated in order to send to Azure.

    :ivar value:
    :vartype value: str
    :ivar label: Required.
    :vartype label: str
    :ivar score:
    :vartype score: float
    """

    _validation = {
        "label": {"required": True},
    }

    _attribute_map = {
        "value": {"key": "value", "type": "str"},
        "label": {"key": "label", "type": "str"},
        "score": {"key": "score", "type": "float"},
    }

    def __init__(self, **kwargs):
        """
        :keyword value:
        :paramtype value: str
        :keyword label: Required.
        :paramtype label: str
        :keyword score:
        :paramtype score: float
        """
        super(LocationSearchScoreComponent, self).__init__(**kwargs)
        self.value = kwargs.get("value", None)
        self.label = kwargs["label"]
        self.score = kwargs.get("score", None)


class ManagementLevelSearchScoreComponent(msrest.serialization.Model):
    """ManagementLevelSearchScoreComponent.

    All required parameters must be populated in order to send to Azure.

    :ivar value:
    :vartype value: str
    :ivar label: Required.
    :vartype label: str
    :ivar score:
    :vartype score: float
    """

    _validation = {
        "label": {"required": True},
    }

    _attribute_map = {
        "value": {"key": "value", "type": "str"},
        "label": {"key": "label", "type": "str"},
        "score": {"key": "score", "type": "float"},
    }

    def __init__(self, **kwargs):
        """
        :keyword value:
        :paramtype value: str
        :keyword label: Required.
        :paramtype label: str
        :keyword score:
        :paramtype score: float
        """
        super(ManagementLevelSearchScoreComponent, self).__init__(**kwargs)
        self.value = kwargs.get("value", None)
        self.label = kwargs["label"]
        self.score = kwargs.get("score", None)


class Mapping(msrest.serialization.Model):
    """A mapping allows you to specify specific settings regarding a lookup against a MappingDataSource should be applied.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar identifier: Required. Uniquely identify a mapping.
    :vartype identifier: str
    :ivar organization: The organization that this mapping belongs to.
    :vartype organization: str
    :ivar data_source: Required. The mapping data source this mapping applies to.
    :vartype data_source: str
    :ivar score_cutoff: Higher values will result in more strict matching.
    :vartype score_cutoff: float
    :ivar order_by: The field to order the results by. Leave blank for ordering by relevance.
    :vartype order_by: str
    """

    _validation = {
        "identifier": {"required": True, "readonly": True},
        "data_source": {"required": True},
    }

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
        "organization": {"key": "organization", "type": "str"},
        "data_source": {"key": "dataSource", "type": "str"},
        "score_cutoff": {"key": "scoreCutoff", "type": "float"},
        "order_by": {"key": "orderBy", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword organization: The organization that this mapping belongs to.
        :paramtype organization: str
        :keyword data_source: Required. The mapping data source this mapping applies to.
        :paramtype data_source: str
        :keyword score_cutoff: Higher values will result in more strict matching.
        :paramtype score_cutoff: float
        :keyword order_by: The field to order the results by. Leave blank for ordering by relevance.
        :paramtype order_by: str
        """
        super(Mapping, self).__init__(**kwargs)
        self.identifier = None
        self.organization = kwargs.get("organization", None)
        self.data_source = kwargs["data_source"]
        self.score_cutoff = kwargs.get("score_cutoff", None)
        self.order_by = kwargs.get("order_by", None)


class MappingCreate(msrest.serialization.Model):
    """MappingCreate.

    All required parameters must be populated in order to send to Azure.

    :ivar data_source: Required. The mapping data source this mapping applies to.
    :vartype data_source: str
    :ivar score_cutoff: Higher values will result in more strict matching.
    :vartype score_cutoff: float
    :ivar organization: The organization that this mapping belongs to.
    :vartype organization: str
    :ivar order_by: The field to order the results by. Leave blank for ordering by relevance.
    :vartype order_by: str
    """

    _validation = {
        "data_source": {"required": True},
    }

    _attribute_map = {
        "data_source": {"key": "dataSource", "type": "str"},
        "score_cutoff": {"key": "scoreCutoff", "type": "float"},
        "organization": {"key": "organization", "type": "str"},
        "order_by": {"key": "orderBy", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword data_source: Required. The mapping data source this mapping applies to.
        :paramtype data_source: str
        :keyword score_cutoff: Higher values will result in more strict matching.
        :paramtype score_cutoff: float
        :keyword organization: The organization that this mapping belongs to.
        :paramtype organization: str
        :keyword order_by: The field to order the results by. Leave blank for ordering by relevance.
        :paramtype order_by: str
        """
        super(MappingCreate, self).__init__(**kwargs)
        self.data_source = kwargs["data_source"]
        self.score_cutoff = kwargs.get("score_cutoff", None)
        self.organization = kwargs.get("organization", None)
        self.order_by = kwargs.get("order_by", None)


class MappingDataSource(msrest.serialization.Model):
    """A mapping data source is used to map from raw data found by our AI models to records in your database.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar identifier: Required. Uniquely identify a mapping data source.
    :vartype identifier: str
    :ivar name:
    :vartype name: str
    :ivar key_property: Required. Attribute in the schema which uniquely identifiers the value.
    :vartype key_property: str
    :ivar display_property: Required. Attribute in the schema which is used to display the value.
    :vartype display_property: str
    :ivar organization: Required. The organization that this mapping data source belongs to.
    :vartype organization: str
    :ivar workspace: Required. The workspace that this mapping data source belongs to.
    :vartype workspace: str
    :ivar schema: The schema of the mapping data source.
    :vartype schema: any
    """

    _validation = {
        "identifier": {"required": True, "readonly": True},
        "key_property": {"required": True},
        "display_property": {"required": True},
        "organization": {"required": True},
        "workspace": {"required": True},
    }

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "key_property": {"key": "keyProperty", "type": "str"},
        "display_property": {"key": "displayProperty", "type": "str"},
        "organization": {"key": "organization", "type": "str"},
        "workspace": {"key": "workspace", "type": "str"},
        "schema": {"key": "schema", "type": "object"},
    }

    def __init__(self, **kwargs):
        """
        :keyword name:
        :paramtype name: str
        :keyword key_property: Required. Attribute in the schema which uniquely identifiers the value.
        :paramtype key_property: str
        :keyword display_property: Required. Attribute in the schema which is used to display the
         value.
        :paramtype display_property: str
        :keyword organization: Required. The organization that this mapping data source belongs to.
        :paramtype organization: str
        :keyword workspace: Required. The workspace that this mapping data source belongs to.
        :paramtype workspace: str
        :keyword schema: The schema of the mapping data source.
        :paramtype schema: any
        """
        super(MappingDataSource, self).__init__(**kwargs)
        self.identifier = None
        self.name = kwargs.get("name", None)
        self.key_property = kwargs["key_property"]
        self.display_property = kwargs["display_property"]
        self.organization = kwargs["organization"]
        self.workspace = kwargs["workspace"]
        self.schema = kwargs.get("schema", None)


class MappingDataSourceCreate(msrest.serialization.Model):
    """A mapping data source is used to map from raw data found by our AI models to records in your database.

    :ivar name:
    :vartype name: str
    :ivar organization: The organization that this mapping data source belongs to.
    :vartype organization: str
    :ivar workspace: The workspace that this mapping data source belongs to.
    :vartype workspace: str
    :ivar key_property: Attribute in the schema which uniquely identifiers the value.
    :vartype key_property: str
    :ivar display_property: Attribute in the schema which is used to display the value.
    :vartype display_property: str
    :ivar values:
    :vartype values: list[any]
    :ivar schema: The schema of the mapping data source.
    :vartype schema: any
    """

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "organization": {"key": "organization", "type": "str"},
        "workspace": {"key": "workspace", "type": "str"},
        "key_property": {"key": "keyProperty", "type": "str"},
        "display_property": {"key": "displayProperty", "type": "str"},
        "values": {"key": "values", "type": "[object]"},
        "schema": {"key": "schema", "type": "object"},
    }

    def __init__(self, **kwargs):
        """
        :keyword name:
        :paramtype name: str
        :keyword organization: The organization that this mapping data source belongs to.
        :paramtype organization: str
        :keyword workspace: The workspace that this mapping data source belongs to.
        :paramtype workspace: str
        :keyword key_property: Attribute in the schema which uniquely identifiers the value.
        :paramtype key_property: str
        :keyword display_property: Attribute in the schema which is used to display the value.
        :paramtype display_property: str
        :keyword values:
        :paramtype values: list[any]
        :keyword schema: The schema of the mapping data source.
        :paramtype schema: any
        """
        super(MappingDataSourceCreate, self).__init__(**kwargs)
        self.name = kwargs.get("name", None)
        self.organization = kwargs.get("organization", None)
        self.workspace = kwargs.get("workspace", None)
        self.key_property = kwargs.get("key_property", None)
        self.display_property = kwargs.get("display_property", None)
        self.values = kwargs.get("values", None)
        self.schema = kwargs.get("schema", None)


class MappingUpdate(msrest.serialization.Model):
    """MappingUpdate.

    :ivar score_cutoff: Higher values will result in more strict matching.
    :vartype score_cutoff: float
    :ivar order_by: The field to order the results by. Leave blank for ordering by relevance.
    :vartype order_by: str
    """

    _attribute_map = {
        "score_cutoff": {"key": "scoreCutoff", "type": "float"},
        "order_by": {"key": "orderBy", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword score_cutoff: Higher values will result in more strict matching.
        :paramtype score_cutoff: float
        :keyword order_by: The field to order the results by. Leave blank for ordering by relevance.
        :paramtype order_by: str
        """
        super(MappingUpdate, self).__init__(**kwargs)
        self.score_cutoff = kwargs.get("score_cutoff", None)
        self.order_by = kwargs.get("order_by", None)


class Meta(msrest.serialization.Model):
    """Meta.

    :ivar identifier: Unique identifier for the document.
    :vartype identifier: str
    :ivar custom_identifier: Optional identifier for the document that you can set to track the
     document in the Affinda system.  Is not required to be unique.
    :vartype custom_identifier: str
    :ivar file_name: Optional filename of the file.
    :vartype file_name: str
    :ivar ready: If true, the document has finished processing. Particularly useful if an endpoint
     request specified wait=False, when polling use this variable to determine when to stop polling.
    :vartype ready: bool
    :ivar ready_dt: The datetime when the document was ready.
    :vartype ready_dt: ~datetime.datetime
    :ivar failed: If true, some exception was raised during processing. Check the 'error' field of
     the main return object.
    :vartype failed: bool
    :ivar expiry_time: The date/time in ISO-8601 format when the document will be automatically
     deleted.  Defaults to no expiry.
    :vartype expiry_time: ~datetime.datetime
    :ivar language: The document's language.
    :vartype language: str
    :ivar pdf: The URL to the document's pdf (if the uploaded document is not already pdf, it's
     converted to pdf as part of the parsing process).
    :vartype pdf: str
    :ivar parent_document: If this document is part of a splitted document, this attribute points
     to the original document that this document is splitted from.
    :vartype parent_document: ~affinda.models.MetaParentDocument
    :ivar child_documents: If this document has been splitted into a number of child documents,
     this attribute points to those child documents.
    :vartype child_documents: list[~affinda.models.MetaChildDocumentsItem]
    :ivar pages: The document's pages.
    :vartype pages: list[~affinda.models.PageMeta]
    :ivar is_verified: This is true if the 'confirm' button has been clicked in the Affinda
     validation tool.
    :vartype is_verified: bool
    :ivar review_url: Signed URL (valid for 60 minutes) to access the validation tool.  Not
     applicable for documents types such a resumes.
    :vartype review_url: str
    :ivar ocr_confidence: The overall confidence in the conversion of image to text.  (only
     applicable for images or PDF documents without a text layer).
    :vartype ocr_confidence: float
    :ivar created_dt:
    :vartype created_dt: ~datetime.datetime
    :ivar document_type:
    :vartype document_type: str
    :ivar region_bias:
    :vartype region_bias: ~affinda.models.RegionBias
    :ivar is_ocrd:
    :vartype is_ocrd: bool
    """

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
        "custom_identifier": {"key": "customIdentifier", "type": "str"},
        "file_name": {"key": "fileName", "type": "str"},
        "ready": {"key": "ready", "type": "bool"},
        "ready_dt": {"key": "readyDt", "type": "iso-8601"},
        "failed": {"key": "failed", "type": "bool"},
        "expiry_time": {"key": "expiryTime", "type": "iso-8601"},
        "language": {"key": "language", "type": "str"},
        "pdf": {"key": "pdf", "type": "str"},
        "parent_document": {"key": "parentDocument", "type": "MetaParentDocument"},
        "child_documents": {"key": "childDocuments", "type": "[MetaChildDocumentsItem]"},
        "pages": {"key": "pages", "type": "[PageMeta]"},
        "is_verified": {"key": "isVerified", "type": "bool"},
        "review_url": {"key": "reviewUrl", "type": "str"},
        "ocr_confidence": {"key": "ocrConfidence", "type": "float"},
        "created_dt": {"key": "createdDt", "type": "iso-8601"},
        "document_type": {"key": "documentType", "type": "str"},
        "region_bias": {"key": "regionBias", "type": "RegionBias"},
        "is_ocrd": {"key": "isOcrd", "type": "bool"},
    }

    def __init__(self, **kwargs):
        """
        :keyword identifier: Unique identifier for the document.
        :paramtype identifier: str
        :keyword custom_identifier: Optional identifier for the document that you can set to track the
         document in the Affinda system.  Is not required to be unique.
        :paramtype custom_identifier: str
        :keyword file_name: Optional filename of the file.
        :paramtype file_name: str
        :keyword ready: If true, the document has finished processing. Particularly useful if an
         endpoint request specified wait=False, when polling use this variable to determine when to stop
         polling.
        :paramtype ready: bool
        :keyword ready_dt: The datetime when the document was ready.
        :paramtype ready_dt: ~datetime.datetime
        :keyword failed: If true, some exception was raised during processing. Check the 'error' field
         of the main return object.
        :paramtype failed: bool
        :keyword expiry_time: The date/time in ISO-8601 format when the document will be automatically
         deleted.  Defaults to no expiry.
        :paramtype expiry_time: ~datetime.datetime
        :keyword language: The document's language.
        :paramtype language: str
        :keyword pdf: The URL to the document's pdf (if the uploaded document is not already pdf, it's
         converted to pdf as part of the parsing process).
        :paramtype pdf: str
        :keyword parent_document: If this document is part of a splitted document, this attribute
         points to the original document that this document is splitted from.
        :paramtype parent_document: ~affinda.models.MetaParentDocument
        :keyword child_documents: If this document has been splitted into a number of child documents,
         this attribute points to those child documents.
        :paramtype child_documents: list[~affinda.models.MetaChildDocumentsItem]
        :keyword pages: The document's pages.
        :paramtype pages: list[~affinda.models.PageMeta]
        :keyword is_verified: This is true if the 'confirm' button has been clicked in the Affinda
         validation tool.
        :paramtype is_verified: bool
        :keyword review_url: Signed URL (valid for 60 minutes) to access the validation tool.  Not
         applicable for documents types such a resumes.
        :paramtype review_url: str
        :keyword ocr_confidence: The overall confidence in the conversion of image to text.  (only
         applicable for images or PDF documents without a text layer).
        :paramtype ocr_confidence: float
        :keyword created_dt:
        :paramtype created_dt: ~datetime.datetime
        :keyword document_type:
        :paramtype document_type: str
        :keyword region_bias:
        :paramtype region_bias: ~affinda.models.RegionBias
        :keyword is_ocrd:
        :paramtype is_ocrd: bool
        """
        super(Meta, self).__init__(**kwargs)
        self.identifier = kwargs.get("identifier", None)
        self.custom_identifier = kwargs.get("custom_identifier", None)
        self.file_name = kwargs.get("file_name", None)
        self.ready = kwargs.get("ready", None)
        self.ready_dt = kwargs.get("ready_dt", None)
        self.failed = kwargs.get("failed", None)
        self.expiry_time = kwargs.get("expiry_time", None)
        self.language = kwargs.get("language", None)
        self.pdf = kwargs.get("pdf", None)
        self.parent_document = kwargs.get("parent_document", None)
        self.child_documents = kwargs.get("child_documents", None)
        self.pages = kwargs.get("pages", None)
        self.is_verified = kwargs.get("is_verified", None)
        self.review_url = kwargs.get("review_url", None)
        self.ocr_confidence = kwargs.get("ocr_confidence", None)
        self.created_dt = kwargs.get("created_dt", None)
        self.document_type = kwargs.get("document_type", None)
        self.region_bias = kwargs.get("region_bias", None)
        self.is_ocrd = kwargs.get("is_ocrd", None)


class MetaChildDocumentsItem(msrest.serialization.Model):
    """MetaChildDocumentsItem.

    :ivar identifier: Unique identifier for the document.
    :vartype identifier: str
    """

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword identifier: Unique identifier for the document.
        :paramtype identifier: str
        """
        super(MetaChildDocumentsItem, self).__init__(**kwargs)
        self.identifier = kwargs.get("identifier", None)


class MetaParentDocument(msrest.serialization.Model):
    """If this document is part of a splitted document, this attribute points to the original document that this document is splitted from.

    :ivar identifier: Unique identifier for the document.
    :vartype identifier: str
    """

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword identifier: Unique identifier for the document.
        :paramtype identifier: str
        """
        super(MetaParentDocument, self).__init__(**kwargs)
        self.identifier = kwargs.get("identifier", None)


class OccupationGroup(msrest.serialization.Model):
    """OccupationGroup.

    All required parameters must be populated in order to send to Azure.

    :ivar code: Required.
    :vartype code: int
    :ivar name: Required.
    :vartype name: str
    :ivar children: Required.
    :vartype children: list[~affinda.models.OccupationGroup]
    """

    _validation = {
        "code": {"required": True},
        "name": {"required": True},
        "children": {"required": True},
    }

    _attribute_map = {
        "code": {"key": "code", "type": "int"},
        "name": {"key": "name", "type": "str"},
        "children": {"key": "children", "type": "[OccupationGroup]"},
    }

    def __init__(self, **kwargs):
        """
        :keyword code: Required.
        :paramtype code: int
        :keyword name: Required.
        :paramtype name: str
        :keyword children: Required.
        :paramtype children: list[~affinda.models.OccupationGroup]
        """
        super(OccupationGroup, self).__init__(**kwargs)
        self.code = kwargs["code"]
        self.name = kwargs["name"]
        self.children = kwargs["children"]


class OccupationGroupSearchScoreComponent(msrest.serialization.Model):
    """OccupationGroupSearchScoreComponent.

    All required parameters must be populated in order to send to Azure.

    :ivar value:
    :vartype value: str
    :ivar label: Required.
    :vartype label: str
    :ivar score:
    :vartype score: float
    """

    _validation = {
        "label": {"required": True},
    }

    _attribute_map = {
        "value": {"key": "value", "type": "str"},
        "label": {"key": "label", "type": "str"},
        "score": {"key": "score", "type": "float"},
    }

    def __init__(self, **kwargs):
        """
        :keyword value:
        :paramtype value: str
        :keyword label: Required.
        :paramtype label: str
        :keyword score:
        :paramtype score: float
        """
        super(OccupationGroupSearchScoreComponent, self).__init__(**kwargs)
        self.value = kwargs.get("value", None)
        self.label = kwargs["label"]
        self.score = kwargs.get("score", None)


class Organization(msrest.serialization.Model):
    """Organization.

    :ivar identifier: Uniquely identify an organization.
    :vartype identifier: str
    :ivar name:
    :vartype name: str
    :ivar user_role: The role of the logged in user within the organization. Known values are:
     "admin", "member".
    :vartype user_role: str or ~affinda.models.OrganizationUserRole
    :ivar avatar: URL of the organization's avatar.
    :vartype avatar: str
    :ivar resthook_signature_key: Used to sign webhook payloads so you can verify their integrity.
    :vartype resthook_signature_key: str
    :ivar is_trial:
    :vartype is_trial: bool
    :ivar validation_tool_config: Configuration of the embeddable validation tool.
    :vartype validation_tool_config: ~affinda.models.OrganizationValidationToolConfig
    :ivar show_custom_field_creation: Whether to show the custom field creation in the UI.
    :vartype show_custom_field_creation: bool
    """

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "user_role": {"key": "userRole", "type": "str"},
        "avatar": {"key": "avatar", "type": "str"},
        "resthook_signature_key": {"key": "resthookSignatureKey", "type": "str"},
        "is_trial": {"key": "isTrial", "type": "bool"},
        "validation_tool_config": {
            "key": "validationToolConfig",
            "type": "OrganizationValidationToolConfig",
        },
        "show_custom_field_creation": {"key": "showCustomFieldCreation", "type": "bool"},
    }

    def __init__(self, **kwargs):
        """
        :keyword identifier: Uniquely identify an organization.
        :paramtype identifier: str
        :keyword name:
        :paramtype name: str
        :keyword user_role: The role of the logged in user within the organization. Known values are:
         "admin", "member".
        :paramtype user_role: str or ~affinda.models.OrganizationUserRole
        :keyword avatar: URL of the organization's avatar.
        :paramtype avatar: str
        :keyword resthook_signature_key: Used to sign webhook payloads so you can verify their
         integrity.
        :paramtype resthook_signature_key: str
        :keyword is_trial:
        :paramtype is_trial: bool
        :keyword validation_tool_config: Configuration of the embeddable validation tool.
        :paramtype validation_tool_config: ~affinda.models.OrganizationValidationToolConfig
        :keyword show_custom_field_creation: Whether to show the custom field creation in the UI.
        :paramtype show_custom_field_creation: bool
        """
        super(Organization, self).__init__(**kwargs)
        self.identifier = kwargs.get("identifier", None)
        self.name = kwargs.get("name", None)
        self.user_role = kwargs.get("user_role", None)
        self.avatar = kwargs.get("avatar", None)
        self.resthook_signature_key = kwargs.get("resthook_signature_key", None)
        self.is_trial = kwargs.get("is_trial", None)
        self.validation_tool_config = kwargs.get("validation_tool_config", None)
        self.show_custom_field_creation = kwargs.get("show_custom_field_creation", None)


class OrganizationCreate(msrest.serialization.Model):
    """OrganizationCreate.

    All required parameters must be populated in order to send to Azure.

    :ivar name: Required.
    :vartype name: str
    :ivar avatar: Upload avatar for the organization.
    :vartype avatar: IO
    :ivar resthook_signature_key: Used to sign webhook payloads so you can verify their integrity.
    :vartype resthook_signature_key: str
    """

    _validation = {
        "name": {"required": True},
    }

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "avatar": {"key": "avatar", "type": "IO"},
        "resthook_signature_key": {"key": "resthookSignatureKey", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword name: Required.
        :paramtype name: str
        :keyword avatar: Upload avatar for the organization.
        :paramtype avatar: IO
        :keyword resthook_signature_key: Used to sign webhook payloads so you can verify their
         integrity.
        :paramtype resthook_signature_key: str
        """
        super(OrganizationCreate, self).__init__(**kwargs)
        self.name = kwargs["name"]
        self.avatar = kwargs.get("avatar", None)
        self.resthook_signature_key = kwargs.get("resthook_signature_key", None)


class OrganizationMembership(msrest.serialization.Model):
    """OrganizationMembership.

    All required parameters must be populated in order to send to Azure.

    :ivar identifier: Required. A random string that uniquely identify the resource.
    :vartype identifier: str
    :ivar organization: Required. Uniquely identify an organization.
    :vartype organization: str
    :ivar user: Required.
    :vartype user: ~affinda.models.User
    :ivar role: Required. Known values are: "admin", "member".
    :vartype role: str or ~affinda.models.OrganizationRole
    """

    _validation = {
        "identifier": {"required": True},
        "organization": {"required": True},
        "user": {"required": True},
        "role": {"required": True},
    }

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
        "organization": {"key": "organization", "type": "str"},
        "user": {"key": "user", "type": "User"},
        "role": {"key": "role", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword identifier: Required. A random string that uniquely identify the resource.
        :paramtype identifier: str
        :keyword organization: Required. Uniquely identify an organization.
        :paramtype organization: str
        :keyword user: Required.
        :paramtype user: ~affinda.models.User
        :keyword role: Required. Known values are: "admin", "member".
        :paramtype role: str or ~affinda.models.OrganizationRole
        """
        super(OrganizationMembership, self).__init__(**kwargs)
        self.identifier = kwargs["identifier"]
        self.organization = kwargs["organization"]
        self.user = kwargs["user"]
        self.role = kwargs["role"]


class OrganizationMembershipUpdate(msrest.serialization.Model):
    """OrganizationMembershipUpdate.

    :ivar role: Known values are: "admin", "member".
    :vartype role: str or ~affinda.models.OrganizationRole
    """

    _attribute_map = {
        "role": {"key": "role", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword role: Known values are: "admin", "member".
        :paramtype role: str or ~affinda.models.OrganizationRole
        """
        super(OrganizationMembershipUpdate, self).__init__(**kwargs)
        self.role = kwargs.get("role", None)


class OrganizationUpdate(msrest.serialization.Model):
    """OrganizationUpdate.

    :ivar name:
    :vartype name: str
    :ivar avatar: Upload avatar for the organization.
    :vartype avatar: IO
    :ivar resthook_signature_key: Used to sign webhook payloads so you can verify their integrity.
    :vartype resthook_signature_key: str
    :ivar validation_tool_config: Configuration of the embeddable validation tool.
    :vartype validation_tool_config: ~affinda.models.ValidationToolConfig
    """

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "avatar": {"key": "avatar", "type": "IO"},
        "resthook_signature_key": {"key": "resthookSignatureKey", "type": "str"},
        "validation_tool_config": {"key": "validationToolConfig", "type": "ValidationToolConfig"},
    }

    def __init__(self, **kwargs):
        """
        :keyword name:
        :paramtype name: str
        :keyword avatar: Upload avatar for the organization.
        :paramtype avatar: IO
        :keyword resthook_signature_key: Used to sign webhook payloads so you can verify their
         integrity.
        :paramtype resthook_signature_key: str
        :keyword validation_tool_config: Configuration of the embeddable validation tool.
        :paramtype validation_tool_config: ~affinda.models.ValidationToolConfig
        """
        super(OrganizationUpdate, self).__init__(**kwargs)
        self.name = kwargs.get("name", None)
        self.avatar = kwargs.get("avatar", None)
        self.resthook_signature_key = kwargs.get("resthook_signature_key", None)
        self.validation_tool_config = kwargs.get("validation_tool_config", None)


class OrganizationValidationToolConfig(msrest.serialization.Model):
    """Configuration of the embeddable validation tool.

    :ivar theme:
    :vartype theme: ~affinda.models.ThemeConfig
    :ivar hide_actions: Hide the confirm document button and other actions.
    :vartype hide_actions: bool
    :ivar hide_collection: Hide the collection selector.
    :vartype hide_collection: bool
    :ivar hide_edit_pages: Hide the edit pages button.
    :vartype hide_edit_pages: bool
    :ivar hide_export: Hide the export menu.
    :vartype hide_export: bool
    :ivar hide_filename: Hide the filename input.
    :vartype hide_filename: bool
    :ivar hide_reject: Hide the reject document button.
    :vartype hide_reject: bool
    :ivar hide_reparse: Hide the reparse button.
    :vartype hide_reparse: bool
    :ivar hide_run_ocr: Hide the run OCR button.
    :vartype hide_run_ocr: bool
    :ivar hide_tags: Hide the tags editor.
    :vartype hide_tags: bool
    :ivar hide_warnings: Hide the warnings panel.
    :vartype hide_warnings: bool
    :ivar restrict_document_splitting: Disable the page editor after a document has been split
     once.
    :vartype restrict_document_splitting: bool
    :ivar disable_currency_formatting: Disable currency formatting of decimals values.
    :vartype disable_currency_formatting: bool
    :ivar disable_edit_document_metadata: Disable editing document metadata. Makes the collection
     selector, filename input and tags editor read only.
    :vartype disable_edit_document_metadata: bool
    """

    _attribute_map = {
        "theme": {"key": "theme", "type": "ThemeConfig"},
        "hide_actions": {"key": "hideActions", "type": "bool"},
        "hide_collection": {"key": "hideCollection", "type": "bool"},
        "hide_edit_pages": {"key": "hideEditPages", "type": "bool"},
        "hide_export": {"key": "hideExport", "type": "bool"},
        "hide_filename": {"key": "hideFilename", "type": "bool"},
        "hide_reject": {"key": "hideReject", "type": "bool"},
        "hide_reparse": {"key": "hideReparse", "type": "bool"},
        "hide_run_ocr": {"key": "hideRunOcr", "type": "bool"},
        "hide_tags": {"key": "hideTags", "type": "bool"},
        "hide_warnings": {"key": "hideWarnings", "type": "bool"},
        "restrict_document_splitting": {"key": "restrictDocumentSplitting", "type": "bool"},
        "disable_currency_formatting": {"key": "disableCurrencyFormatting", "type": "bool"},
        "disable_edit_document_metadata": {"key": "disableEditDocumentMetadata", "type": "bool"},
    }

    def __init__(self, **kwargs):
        """
        :keyword theme:
        :paramtype theme: ~affinda.models.ThemeConfig
        :keyword hide_actions: Hide the confirm document button and other actions.
        :paramtype hide_actions: bool
        :keyword hide_collection: Hide the collection selector.
        :paramtype hide_collection: bool
        :keyword hide_edit_pages: Hide the edit pages button.
        :paramtype hide_edit_pages: bool
        :keyword hide_export: Hide the export menu.
        :paramtype hide_export: bool
        :keyword hide_filename: Hide the filename input.
        :paramtype hide_filename: bool
        :keyword hide_reject: Hide the reject document button.
        :paramtype hide_reject: bool
        :keyword hide_reparse: Hide the reparse button.
        :paramtype hide_reparse: bool
        :keyword hide_run_ocr: Hide the run OCR button.
        :paramtype hide_run_ocr: bool
        :keyword hide_tags: Hide the tags editor.
        :paramtype hide_tags: bool
        :keyword hide_warnings: Hide the warnings panel.
        :paramtype hide_warnings: bool
        :keyword restrict_document_splitting: Disable the page editor after a document has been split
         once.
        :paramtype restrict_document_splitting: bool
        :keyword disable_currency_formatting: Disable currency formatting of decimals values.
        :paramtype disable_currency_formatting: bool
        :keyword disable_edit_document_metadata: Disable editing document metadata. Makes the
         collection selector, filename input and tags editor read only.
        :paramtype disable_edit_document_metadata: bool
        """
        super(OrganizationValidationToolConfig, self).__init__(**kwargs)
        self.theme = kwargs.get("theme", None)
        self.hide_actions = kwargs.get("hide_actions", None)
        self.hide_collection = kwargs.get("hide_collection", None)
        self.hide_edit_pages = kwargs.get("hide_edit_pages", None)
        self.hide_export = kwargs.get("hide_export", None)
        self.hide_filename = kwargs.get("hide_filename", None)
        self.hide_reject = kwargs.get("hide_reject", None)
        self.hide_reparse = kwargs.get("hide_reparse", None)
        self.hide_run_ocr = kwargs.get("hide_run_ocr", None)
        self.hide_tags = kwargs.get("hide_tags", None)
        self.hide_warnings = kwargs.get("hide_warnings", None)
        self.restrict_document_splitting = kwargs.get("restrict_document_splitting", None)
        self.disable_currency_formatting = kwargs.get("disable_currency_formatting", None)
        self.disable_edit_document_metadata = kwargs.get("disable_edit_document_metadata", None)


class PageMeta(msrest.serialization.Model):
    """PageMeta.

    All required parameters must be populated in order to send to Azure.

    :ivar id: Required.
    :vartype id: int
    :ivar page_index: Required. Page number within the document, starts from 0.
    :vartype page_index: int
    :ivar image: Required. The URL to the image of the page.
    :vartype image: str
    :ivar image_translated: The URL to the translated image of the page.
    :vartype image_translated: str
    :ivar height: Required. Height of the page's image in px.
    :vartype height: float
    :ivar width: Required. Width of the page's image in px.
    :vartype width: float
    :ivar rotation: Required. The degree of rotation applied to the page. Greater than 0 indicates
     clockwise rotation. Less than 0 indicates counter-clockwise rotation.
    :vartype rotation: int
    """

    _validation = {
        "id": {"required": True, "minimum": 1},
        "page_index": {"required": True, "minimum": 0},
        "image": {"required": True},
        "height": {"required": True},
        "width": {"required": True},
        "rotation": {"required": True, "maximum": 360, "minimum": -360},
    }

    _attribute_map = {
        "id": {"key": "id", "type": "int"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "image": {"key": "image", "type": "str"},
        "image_translated": {"key": "imageTranslated", "type": "str"},
        "height": {"key": "height", "type": "float"},
        "width": {"key": "width", "type": "float"},
        "rotation": {"key": "rotation", "type": "int"},
    }

    def __init__(self, **kwargs):
        """
        :keyword id: Required.
        :paramtype id: int
        :keyword page_index: Required. Page number within the document, starts from 0.
        :paramtype page_index: int
        :keyword image: Required. The URL to the image of the page.
        :paramtype image: str
        :keyword image_translated: The URL to the translated image of the page.
        :paramtype image_translated: str
        :keyword height: Required. Height of the page's image in px.
        :paramtype height: float
        :keyword width: Required. Width of the page's image in px.
        :paramtype width: float
        :keyword rotation: Required. The degree of rotation applied to the page. Greater than 0
         indicates clockwise rotation. Less than 0 indicates counter-clockwise rotation.
        :paramtype rotation: int
        """
        super(PageMeta, self).__init__(**kwargs)
        self.id = kwargs["id"]
        self.page_index = kwargs["page_index"]
        self.image = kwargs["image"]
        self.image_translated = kwargs.get("image_translated", None)
        self.height = kwargs["height"]
        self.width = kwargs["width"]
        self.rotation = kwargs["rotation"]


class PaginatedResponse(msrest.serialization.Model):
    """PaginatedResponse.

    All required parameters must be populated in order to send to Azure.

    :ivar count: Required. Number of items in results.
    :vartype count: int
    :ivar next: URL to request next page of results.
    :vartype next: str
    :ivar previous: URL to request previous page of results.
    :vartype previous: str
    """

    _validation = {
        "count": {"required": True, "minimum": 0},
    }

    _attribute_map = {
        "count": {"key": "count", "type": "int"},
        "next": {"key": "next", "type": "str"},
        "previous": {"key": "previous", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword count: Required. Number of items in results.
        :paramtype count: int
        :keyword next: URL to request next page of results.
        :paramtype next: str
        :keyword previous: URL to request previous page of results.
        :paramtype previous: str
        """
        super(PaginatedResponse, self).__init__(**kwargs)
        self.count = kwargs["count"]
        self.next = kwargs.get("next", None)
        self.previous = kwargs.get("previous", None)


class PaletteColorOptions(msrest.serialization.Model):
    """PaletteColorOptions.

    All required parameters must be populated in order to send to Azure.

    :ivar main: Required.
    :vartype main: str
    :ivar light:
    :vartype light: str
    :ivar dark:
    :vartype dark: str
    :ivar contrast_text:
    :vartype contrast_text: str
    """

    _validation = {
        "main": {"required": True},
    }

    _attribute_map = {
        "main": {"key": "main", "type": "str"},
        "light": {"key": "light", "type": "str"},
        "dark": {"key": "dark", "type": "str"},
        "contrast_text": {"key": "contrastText", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword main: Required.
        :paramtype main: str
        :keyword light:
        :paramtype light: str
        :keyword dark:
        :paramtype dark: str
        :keyword contrast_text:
        :paramtype contrast_text: str
        """
        super(PaletteColorOptions, self).__init__(**kwargs)
        self.main = kwargs["main"]
        self.light = kwargs.get("light", None)
        self.dark = kwargs.get("dark", None)
        self.contrast_text = kwargs.get("contrast_text", None)


class Paths11PzrpaV3ApiUsersGetResponses200ContentApplicationJsonSchemaAllof1(
    msrest.serialization.Model
):
    """Paths11PzrpaV3ApiUsersGetResponses200ContentApplicationJsonSchemaAllof1.

    :ivar results:
    :vartype results: list[~affinda.models.ApiUserWithoutKey]
    """

    _attribute_map = {
        "results": {"key": "results", "type": "[ApiUserWithoutKey]"},
    }

    def __init__(self, **kwargs):
        """
        :keyword results:
        :paramtype results: list[~affinda.models.ApiUserWithoutKey]
        """
        super(
            Paths11PzrpaV3ApiUsersGetResponses200ContentApplicationJsonSchemaAllof1, self
        ).__init__(**kwargs)
        self.results = kwargs.get("results", None)


class Paths1UmoszuV3MappingDataSourcesGetResponses200ContentApplicationJsonSchemaAllof1(
    msrest.serialization.Model
):
    """Paths1UmoszuV3MappingDataSourcesGetResponses200ContentApplicationJsonSchemaAllof1.

    :ivar results:
    :vartype results: list[~affinda.models.MappingDataSource]
    """

    _attribute_map = {
        "results": {"key": "results", "type": "[MappingDataSource]"},
    }

    def __init__(self, **kwargs):
        """
        :keyword results:
        :paramtype results: list[~affinda.models.MappingDataSource]
        """
        super(
            Paths1UmoszuV3MappingDataSourcesGetResponses200ContentApplicationJsonSchemaAllof1, self
        ).__init__(**kwargs)
        self.results = kwargs.get("results", None)


class Paths11QdcofV3MappingDataSourcesGetResponses200ContentApplicationJsonSchema(
    PaginatedResponse,
    Paths1UmoszuV3MappingDataSourcesGetResponses200ContentApplicationJsonSchemaAllof1,
):
    """Paths11QdcofV3MappingDataSourcesGetResponses200ContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar results:
    :vartype results: list[~affinda.models.MappingDataSource]
    :ivar count: Required. Number of items in results.
    :vartype count: int
    :ivar next: URL to request next page of results.
    :vartype next: str
    :ivar previous: URL to request previous page of results.
    :vartype previous: str
    """

    _validation = {
        "count": {"required": True, "minimum": 0},
    }

    _attribute_map = {
        "results": {"key": "results", "type": "[MappingDataSource]"},
        "count": {"key": "count", "type": "int"},
        "next": {"key": "next", "type": "str"},
        "previous": {"key": "previous", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword results:
        :paramtype results: list[~affinda.models.MappingDataSource]
        :keyword count: Required. Number of items in results.
        :paramtype count: int
        :keyword next: URL to request next page of results.
        :paramtype next: str
        :keyword previous: URL to request previous page of results.
        :paramtype previous: str
        """
        super(
            Paths11QdcofV3MappingDataSourcesGetResponses200ContentApplicationJsonSchema, self
        ).__init__(**kwargs)
        self.results = kwargs.get("results", None)
        self.count = kwargs["count"]
        self.next = kwargs.get("next", None)
        self.previous = kwargs.get("previous", None)


class PathsKhpbbuV3InvitationsGetResponses200ContentApplicationJsonSchemaAllof1(
    msrest.serialization.Model
):
    """PathsKhpbbuV3InvitationsGetResponses200ContentApplicationJsonSchemaAllof1.

    :ivar results:
    :vartype results: list[~affinda.models.Invitation]
    """

    _attribute_map = {
        "results": {"key": "results", "type": "[Invitation]"},
    }

    def __init__(self, **kwargs):
        """
        :keyword results:
        :paramtype results: list[~affinda.models.Invitation]
        """
        super(
            PathsKhpbbuV3InvitationsGetResponses200ContentApplicationJsonSchemaAllof1, self
        ).__init__(**kwargs)
        self.results = kwargs.get("results", None)


class Paths18Wh2VcV3InvitationsGetResponses200ContentApplicationJsonSchema(
    PaginatedResponse, PathsKhpbbuV3InvitationsGetResponses200ContentApplicationJsonSchemaAllof1
):
    """Paths18Wh2VcV3InvitationsGetResponses200ContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar results:
    :vartype results: list[~affinda.models.Invitation]
    :ivar count: Required. Number of items in results.
    :vartype count: int
    :ivar next: URL to request next page of results.
    :vartype next: str
    :ivar previous: URL to request previous page of results.
    :vartype previous: str
    """

    _validation = {
        "count": {"required": True, "minimum": 0},
    }

    _attribute_map = {
        "results": {"key": "results", "type": "[Invitation]"},
        "count": {"key": "count", "type": "int"},
        "next": {"key": "next", "type": "str"},
        "previous": {"key": "previous", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword results:
        :paramtype results: list[~affinda.models.Invitation]
        :keyword count: Required. Number of items in results.
        :paramtype count: int
        :keyword next: URL to request next page of results.
        :paramtype next: str
        :keyword previous: URL to request previous page of results.
        :paramtype previous: str
        """
        super(Paths18Wh2VcV3InvitationsGetResponses200ContentApplicationJsonSchema, self).__init__(
            **kwargs
        )
        self.results = kwargs.get("results", None)
        self.count = kwargs["count"]
        self.next = kwargs.get("next", None)
        self.previous = kwargs.get("previous", None)


class Paths1Czpnk1V3ResumeSearchEmbedPostRequestbodyContentApplicationJsonSchema(
    msrest.serialization.Model
):
    """Paths1Czpnk1V3ResumeSearchEmbedPostRequestbodyContentApplicationJsonSchema.

    :ivar config_override:
    :vartype config_override: ~affinda.models.ResumeSearchConfig
    """

    _attribute_map = {
        "config_override": {"key": "configOverride", "type": "ResumeSearchConfig"},
    }

    def __init__(self, **kwargs):
        """
        :keyword config_override:
        :paramtype config_override: ~affinda.models.ResumeSearchConfig
        """
        super(
            Paths1Czpnk1V3ResumeSearchEmbedPostRequestbodyContentApplicationJsonSchema, self
        ).__init__(**kwargs)
        self.config_override = kwargs.get("config_override", None)


class Paths1Dgz0V9V3AnnotationsGetResponses200ContentApplicationJsonSchemaAllof1(
    msrest.serialization.Model
):
    """Paths1Dgz0V9V3AnnotationsGetResponses200ContentApplicationJsonSchemaAllof1.

    :ivar results:
    :vartype results: list[~affinda.models.Annotation]
    """

    _attribute_map = {
        "results": {"key": "results", "type": "[Annotation]"},
    }

    def __init__(self, **kwargs):
        """
        :keyword results:
        :paramtype results: list[~affinda.models.Annotation]
        """
        super(
            Paths1Dgz0V9V3AnnotationsGetResponses200ContentApplicationJsonSchemaAllof1, self
        ).__init__(**kwargs)
        self.results = kwargs.get("results", None)


class Paths1D5Zg6MV3AnnotationsGetResponses200ContentApplicationJsonSchema(
    PaginatedResponse, Paths1Dgz0V9V3AnnotationsGetResponses200ContentApplicationJsonSchemaAllof1
):
    """Paths1D5Zg6MV3AnnotationsGetResponses200ContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar results:
    :vartype results: list[~affinda.models.Annotation]
    :ivar count: Required. Number of items in results.
    :vartype count: int
    :ivar next: URL to request next page of results.
    :vartype next: str
    :ivar previous: URL to request previous page of results.
    :vartype previous: str
    """

    _validation = {
        "count": {"required": True, "minimum": 0},
    }

    _attribute_map = {
        "results": {"key": "results", "type": "[Annotation]"},
        "count": {"key": "count", "type": "int"},
        "next": {"key": "next", "type": "str"},
        "previous": {"key": "previous", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword results:
        :paramtype results: list[~affinda.models.Annotation]
        :keyword count: Required. Number of items in results.
        :paramtype count: int
        :keyword next: URL to request next page of results.
        :paramtype next: str
        :keyword previous: URL to request previous page of results.
        :paramtype previous: str
        """
        super(Paths1D5Zg6MV3AnnotationsGetResponses200ContentApplicationJsonSchema, self).__init__(
            **kwargs
        )
        self.results = kwargs.get("results", None)
        self.count = kwargs["count"]
        self.next = kwargs.get("next", None)
        self.previous = kwargs.get("previous", None)


class PathsWvcyp9V3MappingsGetResponses200ContentApplicationJsonSchemaAllof1(
    msrest.serialization.Model
):
    """PathsWvcyp9V3MappingsGetResponses200ContentApplicationJsonSchemaAllof1.

    :ivar results:
    :vartype results: list[~affinda.models.Mapping]
    """

    _attribute_map = {
        "results": {"key": "results", "type": "[Mapping]"},
    }

    def __init__(self, **kwargs):
        """
        :keyword results:
        :paramtype results: list[~affinda.models.Mapping]
        """
        super(
            PathsWvcyp9V3MappingsGetResponses200ContentApplicationJsonSchemaAllof1, self
        ).__init__(**kwargs)
        self.results = kwargs.get("results", None)


class Paths1Dpvb2PV3MappingsGetResponses200ContentApplicationJsonSchema(
    PaginatedResponse, PathsWvcyp9V3MappingsGetResponses200ContentApplicationJsonSchemaAllof1
):
    """Paths1Dpvb2PV3MappingsGetResponses200ContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar results:
    :vartype results: list[~affinda.models.Mapping]
    :ivar count: Required. Number of items in results.
    :vartype count: int
    :ivar next: URL to request next page of results.
    :vartype next: str
    :ivar previous: URL to request previous page of results.
    :vartype previous: str
    """

    _validation = {
        "count": {"required": True, "minimum": 0},
    }

    _attribute_map = {
        "results": {"key": "results", "type": "[Mapping]"},
        "count": {"key": "count", "type": "int"},
        "next": {"key": "next", "type": "str"},
        "previous": {"key": "previous", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword results:
        :paramtype results: list[~affinda.models.Mapping]
        :keyword count: Required. Number of items in results.
        :paramtype count: int
        :keyword next: URL to request next page of results.
        :paramtype next: str
        :keyword previous: URL to request previous page of results.
        :paramtype previous: str
        """
        super(Paths1Dpvb2PV3MappingsGetResponses200ContentApplicationJsonSchema, self).__init__(
            **kwargs
        )
        self.results = kwargs.get("results", None)
        self.count = kwargs["count"]
        self.next = kwargs.get("next", None)
        self.previous = kwargs.get("previous", None)


class Paths1O6IvdaV3MappingDataSourcesIdentifierValuesGetResponses200ContentApplicationJsonSchemaAllof1(
    msrest.serialization.Model
):
    """Paths1O6IvdaV3MappingDataSourcesIdentifierValuesGetResponses200ContentApplicationJsonSchemaAllof1.

    :ivar results:
    :vartype results: list[any]
    """

    _attribute_map = {
        "results": {"key": "results", "type": "[object]"},
    }

    def __init__(self, **kwargs):
        """
        :keyword results:
        :paramtype results: list[any]
        """
        super(
            Paths1O6IvdaV3MappingDataSourcesIdentifierValuesGetResponses200ContentApplicationJsonSchemaAllof1,
            self,
        ).__init__(**kwargs)
        self.results = kwargs.get("results", None)


class Paths1Qojy9V3ResthookSubscriptionsGetResponses200ContentApplicationJsonSchemaAllof1(
    msrest.serialization.Model
):
    """Paths1Qojy9V3ResthookSubscriptionsGetResponses200ContentApplicationJsonSchemaAllof1.

    :ivar results:
    :vartype results: list[~affinda.models.ResthookSubscription]
    """

    _attribute_map = {
        "results": {"key": "results", "type": "[ResthookSubscription]"},
    }

    def __init__(self, **kwargs):
        """
        :keyword results:
        :paramtype results: list[~affinda.models.ResthookSubscription]
        """
        super(
            Paths1Qojy9V3ResthookSubscriptionsGetResponses200ContentApplicationJsonSchemaAllof1,
            self,
        ).__init__(**kwargs)
        self.results = kwargs.get("results", None)


class Paths1Qr7BnyV3MappingDataSourcesIdentifierValuesGetResponses200ContentApplicationJsonSchema(
    PaginatedResponse,
    Paths1O6IvdaV3MappingDataSourcesIdentifierValuesGetResponses200ContentApplicationJsonSchemaAllof1,
):
    """Paths1Qr7BnyV3MappingDataSourcesIdentifierValuesGetResponses200ContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar results:
    :vartype results: list[any]
    :ivar count: Required. Number of items in results.
    :vartype count: int
    :ivar next: URL to request next page of results.
    :vartype next: str
    :ivar previous: URL to request previous page of results.
    :vartype previous: str
    """

    _validation = {
        "count": {"required": True, "minimum": 0},
    }

    _attribute_map = {
        "results": {"key": "results", "type": "[object]"},
        "count": {"key": "count", "type": "int"},
        "next": {"key": "next", "type": "str"},
        "previous": {"key": "previous", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword results:
        :paramtype results: list[any]
        :keyword count: Required. Number of items in results.
        :paramtype count: int
        :keyword next: URL to request next page of results.
        :paramtype next: str
        :keyword previous: URL to request previous page of results.
        :paramtype previous: str
        """
        super(
            Paths1Qr7BnyV3MappingDataSourcesIdentifierValuesGetResponses200ContentApplicationJsonSchema,
            self,
        ).__init__(**kwargs)
        self.results = kwargs.get("results", None)
        self.count = kwargs["count"]
        self.next = kwargs.get("next", None)
        self.previous = kwargs.get("previous", None)


class Paths26Civ0V3ApiUsersGetResponses200ContentApplicationJsonSchema(
    PaginatedResponse, Paths11PzrpaV3ApiUsersGetResponses200ContentApplicationJsonSchemaAllof1
):
    """Paths26Civ0V3ApiUsersGetResponses200ContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar results:
    :vartype results: list[~affinda.models.ApiUserWithoutKey]
    :ivar count: Required. Number of items in results.
    :vartype count: int
    :ivar next: URL to request next page of results.
    :vartype next: str
    :ivar previous: URL to request previous page of results.
    :vartype previous: str
    """

    _validation = {
        "count": {"required": True, "minimum": 0},
    }

    _attribute_map = {
        "results": {"key": "results", "type": "[ApiUserWithoutKey]"},
        "count": {"key": "count", "type": "int"},
        "next": {"key": "next", "type": "str"},
        "previous": {"key": "previous", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword results:
        :paramtype results: list[~affinda.models.ApiUserWithoutKey]
        :keyword count: Required. Number of items in results.
        :paramtype count: int
        :keyword next: URL to request next page of results.
        :paramtype next: str
        :keyword previous: URL to request previous page of results.
        :paramtype previous: str
        """
        super(Paths26Civ0V3ApiUsersGetResponses200ContentApplicationJsonSchema, self).__init__(
            **kwargs
        )
        self.results = kwargs.get("results", None)
        self.count = kwargs["count"]
        self.next = kwargs.get("next", None)
        self.previous = kwargs.get("previous", None)


class Paths2Ld2HiV3WorkspaceMembershipsGetResponses200ContentApplicationJsonSchemaAllof1(
    msrest.serialization.Model
):
    """Paths2Ld2HiV3WorkspaceMembershipsGetResponses200ContentApplicationJsonSchemaAllof1.

    All required parameters must be populated in order to send to Azure.

    :ivar results: Required.
    :vartype results: list[~affinda.models.WorkspaceMembership]
    """

    _validation = {
        "results": {"required": True},
    }

    _attribute_map = {
        "results": {"key": "results", "type": "[WorkspaceMembership]"},
    }

    def __init__(self, **kwargs):
        """
        :keyword results: Required.
        :paramtype results: list[~affinda.models.WorkspaceMembership]
        """
        super(
            Paths2Ld2HiV3WorkspaceMembershipsGetResponses200ContentApplicationJsonSchemaAllof1,
            self,
        ).__init__(**kwargs)
        self.results = kwargs["results"]


class Paths4K6IzqV3DataPointChoicesGetResponses200ContentApplicationJsonSchemaAllof1(
    msrest.serialization.Model
):
    """Paths4K6IzqV3DataPointChoicesGetResponses200ContentApplicationJsonSchemaAllof1.

    :ivar results:
    :vartype results: list[~affinda.models.DataPointChoice]
    """

    _attribute_map = {
        "results": {"key": "results", "type": "[DataPointChoice]"},
    }

    def __init__(self, **kwargs):
        """
        :keyword results:
        :paramtype results: list[~affinda.models.DataPointChoice]
        """
        super(
            Paths4K6IzqV3DataPointChoicesGetResponses200ContentApplicationJsonSchemaAllof1, self
        ).__init__(**kwargs)
        self.results = kwargs.get("results", None)


class Paths4T5Cm5V3IndexGetResponses200ContentApplicationJsonSchemaAllof1(
    msrest.serialization.Model
):
    """Paths4T5Cm5V3IndexGetResponses200ContentApplicationJsonSchemaAllof1.

    :ivar results:
    :vartype results: list[~affinda.models.Index]
    """

    _attribute_map = {
        "results": {"key": "results", "type": "[Index]"},
    }

    def __init__(self, **kwargs):
        """
        :keyword results:
        :paramtype results: list[~affinda.models.Index]
        """
        super(Paths4T5Cm5V3IndexGetResponses200ContentApplicationJsonSchemaAllof1, self).__init__(
            **kwargs
        )
        self.results = kwargs.get("results", None)


class Paths93Fa0ZV3OrganizationMembershipsGetResponses200ContentApplicationJsonSchemaAllof1(
    msrest.serialization.Model
):
    """Paths93Fa0ZV3OrganizationMembershipsGetResponses200ContentApplicationJsonSchemaAllof1.

    :ivar results:
    :vartype results: list[~affinda.models.OrganizationMembership]
    """

    _attribute_map = {
        "results": {"key": "results", "type": "[OrganizationMembership]"},
    }

    def __init__(self, **kwargs):
        """
        :keyword results:
        :paramtype results: list[~affinda.models.OrganizationMembership]
        """
        super(
            Paths93Fa0ZV3OrganizationMembershipsGetResponses200ContentApplicationJsonSchemaAllof1,
            self,
        ).__init__(**kwargs)
        self.results = kwargs.get("results", None)


class PathsCl024WV3IndexNameDocumentsPostRequestbodyContentApplicationJsonSchema(
    msrest.serialization.Model
):
    """PathsCl024WV3IndexNameDocumentsPostRequestbodyContentApplicationJsonSchema.

    :ivar document:
    :vartype document: str
    """

    _attribute_map = {
        "document": {"key": "document", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword document:
        :paramtype document: str
        """
        super(
            PathsCl024WV3IndexNameDocumentsPostRequestbodyContentApplicationJsonSchema, self
        ).__init__(**kwargs)
        self.document = kwargs.get("document", None)


class PathsDvrcp3V3IndexGetResponses200ContentApplicationJsonSchema(
    PaginatedResponse, Paths4T5Cm5V3IndexGetResponses200ContentApplicationJsonSchemaAllof1
):
    """PathsDvrcp3V3IndexGetResponses200ContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar results:
    :vartype results: list[~affinda.models.Index]
    :ivar count: Required. Number of items in results.
    :vartype count: int
    :ivar next: URL to request next page of results.
    :vartype next: str
    :ivar previous: URL to request previous page of results.
    :vartype previous: str
    """

    _validation = {
        "count": {"required": True, "minimum": 0},
    }

    _attribute_map = {
        "results": {"key": "results", "type": "[Index]"},
        "count": {"key": "count", "type": "int"},
        "next": {"key": "next", "type": "str"},
        "previous": {"key": "previous", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword results:
        :paramtype results: list[~affinda.models.Index]
        :keyword count: Required. Number of items in results.
        :paramtype count: int
        :keyword next: URL to request next page of results.
        :paramtype next: str
        :keyword previous: URL to request previous page of results.
        :paramtype previous: str
        """
        super(PathsDvrcp3V3IndexGetResponses200ContentApplicationJsonSchema, self).__init__(
            **kwargs
        )
        self.results = kwargs.get("results", None)
        self.count = kwargs["count"]
        self.next = kwargs.get("next", None)
        self.previous = kwargs.get("previous", None)


class PathsFte27NV3IndexNameDocumentsPostResponses201ContentApplicationJsonSchema(
    msrest.serialization.Model
):
    """PathsFte27NV3IndexNameDocumentsPostResponses201ContentApplicationJsonSchema.

    :ivar document: Unique identifier for the document.
    :vartype document: str
    """

    _attribute_map = {
        "document": {"key": "document", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword document: Unique identifier for the document.
        :paramtype document: str
        """
        super(
            PathsFte27NV3IndexNameDocumentsPostResponses201ContentApplicationJsonSchema, self
        ).__init__(**kwargs)
        self.document = kwargs.get("document", None)


class PathsL3R02CV3DocumentsGetResponses200ContentApplicationJsonSchemaAllof1(
    msrest.serialization.Model
):
    """PathsL3R02CV3DocumentsGetResponses200ContentApplicationJsonSchemaAllof1.

    :ivar results:
    :vartype results: list[~affinda.models.Document]
    """

    _attribute_map = {
        "results": {"key": "results", "type": "[Document]"},
    }

    def __init__(self, **kwargs):
        """
        :keyword results:
        :paramtype results: list[~affinda.models.Document]
        """
        super(
            PathsL3R02CV3DocumentsGetResponses200ContentApplicationJsonSchemaAllof1, self
        ).__init__(**kwargs)
        self.results = kwargs.get("results", None)


class PathsM3DzbgV3JobDescriptionSearchEmbedPostRequestbodyContentApplicationJsonSchema(
    msrest.serialization.Model
):
    """PathsM3DzbgV3JobDescriptionSearchEmbedPostRequestbodyContentApplicationJsonSchema.

    :ivar config_override:
    :vartype config_override: ~affinda.models.JobDescriptionSearchConfig
    """

    _attribute_map = {
        "config_override": {"key": "configOverride", "type": "JobDescriptionSearchConfig"},
    }

    def __init__(self, **kwargs):
        """
        :keyword config_override:
        :paramtype config_override: ~affinda.models.JobDescriptionSearchConfig
        """
        super(
            PathsM3DzbgV3JobDescriptionSearchEmbedPostRequestbodyContentApplicationJsonSchema, self
        ).__init__(**kwargs)
        self.config_override = kwargs.get("config_override", None)


class PathsMnwxgV3DataPointChoicesGetResponses200ContentApplicationJsonSchema(
    PaginatedResponse,
    Paths4K6IzqV3DataPointChoicesGetResponses200ContentApplicationJsonSchemaAllof1,
):
    """PathsMnwxgV3DataPointChoicesGetResponses200ContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar results:
    :vartype results: list[~affinda.models.DataPointChoice]
    :ivar count: Required. Number of items in results.
    :vartype count: int
    :ivar next: URL to request next page of results.
    :vartype next: str
    :ivar previous: URL to request previous page of results.
    :vartype previous: str
    """

    _validation = {
        "count": {"required": True, "minimum": 0},
    }

    _attribute_map = {
        "results": {"key": "results", "type": "[DataPointChoice]"},
        "count": {"key": "count", "type": "int"},
        "next": {"key": "next", "type": "str"},
        "previous": {"key": "previous", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword results:
        :paramtype results: list[~affinda.models.DataPointChoice]
        :keyword count: Required. Number of items in results.
        :paramtype count: int
        :keyword next: URL to request next page of results.
        :paramtype next: str
        :keyword previous: URL to request previous page of results.
        :paramtype previous: str
        """
        super(
            PathsMnwxgV3DataPointChoicesGetResponses200ContentApplicationJsonSchema, self
        ).__init__(**kwargs)
        self.results = kwargs.get("results", None)
        self.count = kwargs["count"]
        self.next = kwargs.get("next", None)
        self.previous = kwargs.get("previous", None)


class PathsO7SnenV3IndexNameDocumentsGetResponses200ContentApplicationJsonSchema(
    msrest.serialization.Model
):
    """PathsO7SnenV3IndexNameDocumentsGetResponses200ContentApplicationJsonSchema.

    :ivar count: Number of indexed documents in result.
    :vartype count: int
    :ivar next: URL to request next page of results.
    :vartype next: str
    :ivar previous: URL to request previous page of results.
    :vartype previous: str
    :ivar results:
    :vartype results: list[~affinda.models.Get200ApplicationJsonPropertiesItemsItem]
    """

    _validation = {
        "count": {"minimum": 1},
    }

    _attribute_map = {
        "count": {"key": "count", "type": "int"},
        "next": {"key": "next", "type": "str"},
        "previous": {"key": "previous", "type": "str"},
        "results": {"key": "results", "type": "[Get200ApplicationJsonPropertiesItemsItem]"},
    }

    def __init__(self, **kwargs):
        """
        :keyword count: Number of indexed documents in result.
        :paramtype count: int
        :keyword next: URL to request next page of results.
        :paramtype next: str
        :keyword previous: URL to request previous page of results.
        :paramtype previous: str
        :keyword results:
        :paramtype results: list[~affinda.models.Get200ApplicationJsonPropertiesItemsItem]
        """
        super(
            PathsO7SnenV3IndexNameDocumentsGetResponses200ContentApplicationJsonSchema, self
        ).__init__(**kwargs)
        self.count = kwargs.get("count", None)
        self.next = kwargs.get("next", None)
        self.previous = kwargs.get("previous", None)
        self.results = kwargs.get("results", None)


class PathsOxm5M7V3DocumentsGetResponses200ContentApplicationJsonSchema(
    PaginatedResponse, PathsL3R02CV3DocumentsGetResponses200ContentApplicationJsonSchemaAllof1
):
    """PathsOxm5M7V3DocumentsGetResponses200ContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar results:
    :vartype results: list[~affinda.models.Document]
    :ivar count: Required. Number of items in results.
    :vartype count: int
    :ivar next: URL to request next page of results.
    :vartype next: str
    :ivar previous: URL to request previous page of results.
    :vartype previous: str
    """

    _validation = {
        "count": {"required": True, "minimum": 0},
    }

    _attribute_map = {
        "results": {"key": "results", "type": "[Document]"},
        "count": {"key": "count", "type": "int"},
        "next": {"key": "next", "type": "str"},
        "previous": {"key": "previous", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword results:
        :paramtype results: list[~affinda.models.Document]
        :keyword count: Required. Number of items in results.
        :paramtype count: int
        :keyword next: URL to request next page of results.
        :paramtype next: str
        :keyword previous: URL to request previous page of results.
        :paramtype previous: str
        """
        super(PathsOxm5M7V3DocumentsGetResponses200ContentApplicationJsonSchema, self).__init__(
            **kwargs
        )
        self.results = kwargs.get("results", None)
        self.count = kwargs["count"]
        self.next = kwargs.get("next", None)
        self.previous = kwargs.get("previous", None)


class PathsQ5Os5RV3OrganizationMembershipsGetResponses200ContentApplicationJsonSchema(
    PaginatedResponse,
    Paths93Fa0ZV3OrganizationMembershipsGetResponses200ContentApplicationJsonSchemaAllof1,
):
    """PathsQ5Os5RV3OrganizationMembershipsGetResponses200ContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar results:
    :vartype results: list[~affinda.models.OrganizationMembership]
    :ivar count: Required. Number of items in results.
    :vartype count: int
    :ivar next: URL to request next page of results.
    :vartype next: str
    :ivar previous: URL to request previous page of results.
    :vartype previous: str
    """

    _validation = {
        "count": {"required": True, "minimum": 0},
    }

    _attribute_map = {
        "results": {"key": "results", "type": "[OrganizationMembership]"},
        "count": {"key": "count", "type": "int"},
        "next": {"key": "next", "type": "str"},
        "previous": {"key": "previous", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword results:
        :paramtype results: list[~affinda.models.OrganizationMembership]
        :keyword count: Required. Number of items in results.
        :paramtype count: int
        :keyword next: URL to request next page of results.
        :paramtype next: str
        :keyword previous: URL to request previous page of results.
        :paramtype previous: str
        """
        super(
            PathsQ5Os5RV3OrganizationMembershipsGetResponses200ContentApplicationJsonSchema, self
        ).__init__(**kwargs)
        self.results = kwargs.get("results", None)
        self.count = kwargs["count"]
        self.next = kwargs.get("next", None)
        self.previous = kwargs.get("previous", None)


class PathsVz5Kj2V3ResthookSubscriptionsGetResponses200ContentApplicationJsonSchema(
    PaginatedResponse,
    Paths1Qojy9V3ResthookSubscriptionsGetResponses200ContentApplicationJsonSchemaAllof1,
):
    """PathsVz5Kj2V3ResthookSubscriptionsGetResponses200ContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar results:
    :vartype results: list[~affinda.models.ResthookSubscription]
    :ivar count: Required. Number of items in results.
    :vartype count: int
    :ivar next: URL to request next page of results.
    :vartype next: str
    :ivar previous: URL to request previous page of results.
    :vartype previous: str
    """

    _validation = {
        "count": {"required": True, "minimum": 0},
    }

    _attribute_map = {
        "results": {"key": "results", "type": "[ResthookSubscription]"},
        "count": {"key": "count", "type": "int"},
        "next": {"key": "next", "type": "str"},
        "previous": {"key": "previous", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword results:
        :paramtype results: list[~affinda.models.ResthookSubscription]
        :keyword count: Required. Number of items in results.
        :paramtype count: int
        :keyword next: URL to request next page of results.
        :paramtype next: str
        :keyword previous: URL to request previous page of results.
        :paramtype previous: str
        """
        super(
            PathsVz5Kj2V3ResthookSubscriptionsGetResponses200ContentApplicationJsonSchema, self
        ).__init__(**kwargs)
        self.results = kwargs.get("results", None)
        self.count = kwargs["count"]
        self.next = kwargs.get("next", None)
        self.previous = kwargs.get("previous", None)


class PathsZ1JuagV3WorkspaceMembershipsGetResponses200ContentApplicationJsonSchema(
    PaginatedResponse,
    Paths2Ld2HiV3WorkspaceMembershipsGetResponses200ContentApplicationJsonSchemaAllof1,
):
    """PathsZ1JuagV3WorkspaceMembershipsGetResponses200ContentApplicationJsonSchema.

    All required parameters must be populated in order to send to Azure.

    :ivar results: Required.
    :vartype results: list[~affinda.models.WorkspaceMembership]
    :ivar count: Required. Number of items in results.
    :vartype count: int
    :ivar next: URL to request next page of results.
    :vartype next: str
    :ivar previous: URL to request previous page of results.
    :vartype previous: str
    """

    _validation = {
        "results": {"required": True},
        "count": {"required": True, "minimum": 0},
    }

    _attribute_map = {
        "results": {"key": "results", "type": "[WorkspaceMembership]"},
        "count": {"key": "count", "type": "int"},
        "next": {"key": "next", "type": "str"},
        "previous": {"key": "previous", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword results: Required.
        :paramtype results: list[~affinda.models.WorkspaceMembership]
        :keyword count: Required. Number of items in results.
        :paramtype count: int
        :keyword next: URL to request next page of results.
        :paramtype next: str
        :keyword previous: URL to request previous page of results.
        :paramtype previous: str
        """
        super(
            PathsZ1JuagV3WorkspaceMembershipsGetResponses200ContentApplicationJsonSchema, self
        ).__init__(**kwargs)
        self.results = kwargs["results"]
        self.count = kwargs["count"]
        self.next = kwargs.get("next", None)
        self.previous = kwargs.get("previous", None)


class PhoneNumberAnnotation(Annotation):
    """PhoneNumberAnnotation.

    All required parameters must be populated in order to send to Azure.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id: Required. Annotation's ID.
    :vartype id: int
    :ivar rectangle: Required. x/y coordinates for the rectangular bounding box containing the
     data.
    :vartype rectangle: ~affinda.models.Rectangle
    :ivar rectangles: Required. x/y coordinates for the rectangles containing the data. An
     annotation can be contained within multiple rectangles.
    :vartype rectangles: list[~affinda.models.Rectangle]
    :ivar document: Required. Unique identifier for the document.
    :vartype document: str
    :ivar page_index: Required. The page number within the document, starting from 0.
    :vartype page_index: int
    :ivar raw: Required. Raw data extracted from the before any post-processing.
    :vartype raw: str
    :ivar confidence: Required. The overall confidence that the model's prediction is correct.
    :vartype confidence: float
    :ivar classification_confidence: Required. The model's confidence that the text has been
     classified correctly.
    :vartype classification_confidence: float
    :ivar text_extraction_confidence: Required. If the document was submitted as an image, this is
     the confidence that the text in the image has been correctly read by the model.
    :vartype text_extraction_confidence: float
    :ivar is_verified: Required. Indicates whether the data has been validated, either by a human
     using our validation tool or through auto-validation rules.
    :vartype is_verified: bool
    :ivar is_client_verified: Required. Indicates whether the data has been validated by a human.
    :vartype is_client_verified: bool
    :ivar is_auto_verified: Required. Indicates whether the data has been auto-validated.
    :vartype is_auto_verified: bool
    :ivar data_point: Required. Data point's identifier.
    :vartype data_point: str
    :ivar content_type: Required. The different data types of annotations. Known values are:
     "text", "integer", "float", "decimal", "date", "datetime", "daterange", "boolean", "enum",
     "location", "phonenumber", "json", "table", "expectedremuneration", "jobtitle", "language",
     "skill", "yearsexperience", "group", "table_deprecated", "url", "image".
    :vartype content_type: str or ~affinda.models.AnnotationContentType
    :ivar parent: The parent annotation's ID.
    :vartype parent: int
    :ivar parsed:
    :vartype parsed: ~affinda.models.PhoneNumberAnnotationParsed
    """

    _validation = {
        "id": {"required": True, "minimum": 1},
        "rectangle": {"required": True},
        "rectangles": {"required": True},
        "document": {"required": True},
        "page_index": {"required": True, "minimum": 0},
        "raw": {"required": True},
        "confidence": {"required": True},
        "classification_confidence": {"required": True},
        "text_extraction_confidence": {"required": True},
        "is_verified": {"required": True},
        "is_client_verified": {"required": True},
        "is_auto_verified": {"required": True},
        "data_point": {"required": True},
        "content_type": {"required": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "int"},
        "rectangle": {"key": "rectangle", "type": "Rectangle"},
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "document": {"key": "document", "type": "str"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "confidence": {"key": "confidence", "type": "float"},
        "classification_confidence": {"key": "classificationConfidence", "type": "float"},
        "text_extraction_confidence": {"key": "textExtractionConfidence", "type": "float"},
        "is_verified": {"key": "isVerified", "type": "bool"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "is_auto_verified": {"key": "isAutoVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "content_type": {"key": "contentType", "type": "str"},
        "parent": {"key": "parent", "type": "int"},
        "parsed": {"key": "parsed", "type": "PhoneNumberAnnotationParsed"},
    }

    def __init__(self, **kwargs):
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword id: Required. Annotation's ID.
        :paramtype id: int
        :keyword rectangle: Required. x/y coordinates for the rectangular bounding box containing the
         data.
        :paramtype rectangle: ~affinda.models.Rectangle
        :keyword rectangles: Required. x/y coordinates for the rectangles containing the data. An
         annotation can be contained within multiple rectangles.
        :paramtype rectangles: list[~affinda.models.Rectangle]
        :keyword document: Required. Unique identifier for the document.
        :paramtype document: str
        :keyword page_index: Required. The page number within the document, starting from 0.
        :paramtype page_index: int
        :keyword raw: Required. Raw data extracted from the before any post-processing.
        :paramtype raw: str
        :keyword confidence: Required. The overall confidence that the model's prediction is correct.
        :paramtype confidence: float
        :keyword classification_confidence: Required. The model's confidence that the text has been
         classified correctly.
        :paramtype classification_confidence: float
        :keyword text_extraction_confidence: Required. If the document was submitted as an image, this
         is the confidence that the text in the image has been correctly read by the model.
        :paramtype text_extraction_confidence: float
        :keyword is_verified: Required. Indicates whether the data has been validated, either by a
         human using our validation tool or through auto-validation rules.
        :paramtype is_verified: bool
        :keyword is_client_verified: Required. Indicates whether the data has been validated by a
         human.
        :paramtype is_client_verified: bool
        :keyword is_auto_verified: Required. Indicates whether the data has been auto-validated.
        :paramtype is_auto_verified: bool
        :keyword data_point: Required. Data point's identifier.
        :paramtype data_point: str
        :keyword content_type: Required. The different data types of annotations. Known values are:
         "text", "integer", "float", "decimal", "date", "datetime", "daterange", "boolean", "enum",
         "location", "phonenumber", "json", "table", "expectedremuneration", "jobtitle", "language",
         "skill", "yearsexperience", "group", "table_deprecated", "url", "image".
        :paramtype content_type: str or ~affinda.models.AnnotationContentType
        :keyword parent: The parent annotation's ID.
        :paramtype parent: int
        :keyword parsed:
        :paramtype parsed: ~affinda.models.PhoneNumberAnnotationParsed
        """
        super(PhoneNumberAnnotation, self).__init__(**kwargs)
        self.parsed = kwargs.get("parsed", None)


class PhoneNumberAnnotationParsed(msrest.serialization.Model):
    """PhoneNumberAnnotationParsed.

    :ivar raw_text:
    :vartype raw_text: str
    :ivar formatted_number:
    :vartype formatted_number: str
    :ivar country_code:
    :vartype country_code: str
    :ivar international_country_code:
    :vartype international_country_code: int
    :ivar national_number:
    :vartype national_number: str
    """

    _validation = {
        "international_country_code": {"minimum": 1},
    }

    _attribute_map = {
        "raw_text": {"key": "rawText", "type": "str"},
        "formatted_number": {"key": "formattedNumber", "type": "str"},
        "country_code": {"key": "countryCode", "type": "str"},
        "international_country_code": {"key": "internationalCountryCode", "type": "int"},
        "national_number": {"key": "nationalNumber", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword raw_text:
        :paramtype raw_text: str
        :keyword formatted_number:
        :paramtype formatted_number: str
        :keyword country_code:
        :paramtype country_code: str
        :keyword international_country_code:
        :paramtype international_country_code: int
        :keyword national_number:
        :paramtype national_number: str
        """
        super(PhoneNumberAnnotationParsed, self).__init__(**kwargs)
        self.raw_text = kwargs.get("raw_text", None)
        self.formatted_number = kwargs.get("formatted_number", None)
        self.country_code = kwargs.get("country_code", None)
        self.international_country_code = kwargs.get("international_country_code", None)
        self.national_number = kwargs.get("national_number", None)


class Rectangle(msrest.serialization.Model):
    """Rectangle.

    All required parameters must be populated in order to send to Azure.

    :ivar page_index:
    :vartype page_index: int
    :ivar x0: Required.
    :vartype x0: float
    :ivar y0: Required.
    :vartype y0: float
    :ivar x1: Required.
    :vartype x1: float
    :ivar y1: Required.
    :vartype y1: float
    """

    _validation = {
        "page_index": {"minimum": 0},
        "x0": {"required": True},
        "y0": {"required": True},
        "x1": {"required": True},
        "y1": {"required": True},
    }

    _attribute_map = {
        "page_index": {"key": "pageIndex", "type": "int"},
        "x0": {"key": "x0", "type": "float"},
        "y0": {"key": "y0", "type": "float"},
        "x1": {"key": "x1", "type": "float"},
        "y1": {"key": "y1", "type": "float"},
    }

    def __init__(self, **kwargs):
        """
        :keyword page_index:
        :paramtype page_index: int
        :keyword x0: Required.
        :paramtype x0: float
        :keyword y0: Required.
        :paramtype y0: float
        :keyword x1: Required.
        :paramtype x1: float
        :keyword y1: Required.
        :paramtype y1: float
        """
        super(Rectangle, self).__init__(**kwargs)
        self.page_index = kwargs.get("page_index", None)
        self.x0 = kwargs["x0"]
        self.y0 = kwargs["y0"]
        self.x1 = kwargs["x1"]
        self.y1 = kwargs["y1"]


class RedactConfig(msrest.serialization.Model):
    """RedactConfig.

    :ivar redact_headshot:
    :vartype redact_headshot: bool
    :ivar redact_personal_details:
    :vartype redact_personal_details: bool
    :ivar redact_work_details:
    :vartype redact_work_details: bool
    :ivar redact_referees:
    :vartype redact_referees: bool
    :ivar redact_education_details:
    :vartype redact_education_details: bool
    :ivar redact_locations:
    :vartype redact_locations: bool
    :ivar redact_dates:
    :vartype redact_dates: bool
    :ivar redact_gender:
    :vartype redact_gender: bool
    """

    _attribute_map = {
        "redact_headshot": {"key": "redactHeadshot", "type": "bool"},
        "redact_personal_details": {"key": "redactPersonalDetails", "type": "bool"},
        "redact_work_details": {"key": "redactWorkDetails", "type": "bool"},
        "redact_referees": {"key": "redactReferees", "type": "bool"},
        "redact_education_details": {"key": "redactEducationDetails", "type": "bool"},
        "redact_locations": {"key": "redactLocations", "type": "bool"},
        "redact_dates": {"key": "redactDates", "type": "bool"},
        "redact_gender": {"key": "redactGender", "type": "bool"},
    }

    def __init__(self, **kwargs):
        """
        :keyword redact_headshot:
        :paramtype redact_headshot: bool
        :keyword redact_personal_details:
        :paramtype redact_personal_details: bool
        :keyword redact_work_details:
        :paramtype redact_work_details: bool
        :keyword redact_referees:
        :paramtype redact_referees: bool
        :keyword redact_education_details:
        :paramtype redact_education_details: bool
        :keyword redact_locations:
        :paramtype redact_locations: bool
        :keyword redact_dates:
        :paramtype redact_dates: bool
        :keyword redact_gender:
        :paramtype redact_gender: bool
        """
        super(RedactConfig, self).__init__(**kwargs)
        self.redact_headshot = kwargs.get("redact_headshot", None)
        self.redact_personal_details = kwargs.get("redact_personal_details", None)
        self.redact_work_details = kwargs.get("redact_work_details", None)
        self.redact_referees = kwargs.get("redact_referees", None)
        self.redact_education_details = kwargs.get("redact_education_details", None)
        self.redact_locations = kwargs.get("redact_locations", None)
        self.redact_dates = kwargs.get("redact_dates", None)
        self.redact_gender = kwargs.get("redact_gender", None)


class RegionBias(msrest.serialization.Model):
    """RegionBias.

    :ivar country: A single alpha-2 country code (e.g. AU) used by google geocoding service.
    :vartype country: str
    :ivar countries: A list of alpha-2 country codes used by Pelias.
    :vartype countries: list[str]
    :ivar square_coordinates: A list of coordinates used by Pelias in the shape of [min_lon,
     min_lat, max_lon, max_lat].
    :vartype square_coordinates: list[float]
    :ivar strict: If true, the location must be within the region, as opposed to prefering
     locations within the region.
     Default to false.
    :vartype strict: bool
    """

    _attribute_map = {
        "country": {"key": "country", "type": "str"},
        "countries": {"key": "countries", "type": "[str]"},
        "square_coordinates": {"key": "squareCoordinates", "type": "[float]"},
        "strict": {"key": "strict", "type": "bool"},
    }

    def __init__(self, **kwargs):
        """
        :keyword country: A single alpha-2 country code (e.g. AU) used by google geocoding service.
        :paramtype country: str
        :keyword countries: A list of alpha-2 country codes used by Pelias.
        :paramtype countries: list[str]
        :keyword square_coordinates: A list of coordinates used by Pelias in the shape of [min_lon,
         min_lat, max_lon, max_lat].
        :paramtype square_coordinates: list[float]
        :keyword strict: If true, the location must be within the region, as opposed to prefering
         locations within the region.
         Default to false.
        :paramtype strict: bool
        """
        super(RegionBias, self).__init__(**kwargs)
        self.country = kwargs.get("country", None)
        self.countries = kwargs.get("countries", None)
        self.square_coordinates = kwargs.get("square_coordinates", None)
        self.strict = kwargs.get("strict", None)


class RequestError(msrest.serialization.Model):
    """RequestError.

    All required parameters must be populated in order to send to Azure.

    :ivar type: Required.
    :vartype type: str
    :ivar errors: Required.
    :vartype errors: list[~affinda.models.RequestErrorErrorsItem]
    """

    _validation = {
        "type": {"required": True},
        "errors": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "errors": {"key": "errors", "type": "[RequestErrorErrorsItem]"},
    }

    def __init__(self, **kwargs):
        """
        :keyword type: Required.
        :paramtype type: str
        :keyword errors: Required.
        :paramtype errors: list[~affinda.models.RequestErrorErrorsItem]
        """
        super(RequestError, self).__init__(**kwargs)
        self.type = kwargs["type"]
        self.errors = kwargs["errors"]


class RequestErrorErrorsItem(msrest.serialization.Model):
    """RequestErrorErrorsItem.

    All required parameters must be populated in order to send to Azure.

    :ivar attr: Required.
    :vartype attr: str
    :ivar code: Required.
    :vartype code: str
    :ivar detail: Required.
    :vartype detail: str
    """

    _validation = {
        "attr": {"required": True},
        "code": {"required": True},
        "detail": {"required": True},
    }

    _attribute_map = {
        "attr": {"key": "attr", "type": "str"},
        "code": {"key": "code", "type": "str"},
        "detail": {"key": "detail", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword attr: Required.
        :paramtype attr: str
        :keyword code: Required.
        :paramtype code: str
        :keyword detail: Required.
        :paramtype detail: str
        """
        super(RequestErrorErrorsItem, self).__init__(**kwargs)
        self.attr = kwargs["attr"]
        self.code = kwargs["code"]
        self.detail = kwargs["detail"]


class ResthookSubscription(msrest.serialization.Model):
    """ResthookSubscription.

    All required parameters must be populated in order to send to Azure.

    :ivar id: Required. Resthook subscription's ID.
    :vartype id: int
    :ivar event: Required. The event name to subscribe to. Known values are:
     "resume.parse.succeeded", "resume.parse.failed", "resume.parse.completed",
     "invoice.parse.succeeded", "invoice.parse.failed", "invoice.parse.completed",
     "invoice.validate.completed", "document.parse.succeeded", "document.parse.failed",
     "document.parse.completed", "document.validate.completed", "document.classify.succeeded",
     "document.classify.failed", "document.classify.completed", "document.rejected",
     "annotation.validated".
    :vartype event: str or ~affinda.models.ResthookEvent
    :ivar organization: Required.
    :vartype organization: ~affinda.models.Organization
    :ivar workspace: Required.
    :vartype workspace: ~affinda.models.ResthookSubscriptionWorkspace
    :ivar target_url: Required. URL of the resthook's receiver.
    :vartype target_url: str
    :ivar active: Required. Resthooks only fire for active subscriptions.
    :vartype active: bool
    :ivar auto_deactivated: Required. Resthook subscriptions can be auto deactivated if the
     receiver continuously returns error status code over a period of time.
    :vartype auto_deactivated: bool
    :ivar auto_deactivate_reason: Required. The reason for the subscription being auto deactivated.
     May contains the error response that the receiver returned.
    :vartype auto_deactivate_reason: str
    :ivar version: Required. Version of the resthook subscription. Determines the resthook body
     being fired. Known values are: "v1", "v2", "v3".
    :vartype version: str or ~affinda.models.ResthookSubscriptionVersion
    """

    _validation = {
        "id": {"required": True},
        "event": {"required": True},
        "organization": {"required": True},
        "workspace": {"required": True},
        "target_url": {"required": True},
        "active": {"required": True},
        "auto_deactivated": {"required": True},
        "auto_deactivate_reason": {"required": True},
        "version": {"required": True},
    }

    _attribute_map = {
        "id": {"key": "id", "type": "int"},
        "event": {"key": "event", "type": "str"},
        "organization": {"key": "organization", "type": "Organization"},
        "workspace": {"key": "workspace", "type": "ResthookSubscriptionWorkspace"},
        "target_url": {"key": "targetUrl", "type": "str"},
        "active": {"key": "active", "type": "bool"},
        "auto_deactivated": {"key": "autoDeactivated", "type": "bool"},
        "auto_deactivate_reason": {"key": "autoDeactivateReason", "type": "str"},
        "version": {"key": "version", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword id: Required. Resthook subscription's ID.
        :paramtype id: int
        :keyword event: Required. The event name to subscribe to. Known values are:
         "resume.parse.succeeded", "resume.parse.failed", "resume.parse.completed",
         "invoice.parse.succeeded", "invoice.parse.failed", "invoice.parse.completed",
         "invoice.validate.completed", "document.parse.succeeded", "document.parse.failed",
         "document.parse.completed", "document.validate.completed", "document.classify.succeeded",
         "document.classify.failed", "document.classify.completed", "document.rejected",
         "annotation.validated".
        :paramtype event: str or ~affinda.models.ResthookEvent
        :keyword organization: Required.
        :paramtype organization: ~affinda.models.Organization
        :keyword workspace: Required.
        :paramtype workspace: ~affinda.models.ResthookSubscriptionWorkspace
        :keyword target_url: Required. URL of the resthook's receiver.
        :paramtype target_url: str
        :keyword active: Required. Resthooks only fire for active subscriptions.
        :paramtype active: bool
        :keyword auto_deactivated: Required. Resthook subscriptions can be auto deactivated if the
         receiver continuously returns error status code over a period of time.
        :paramtype auto_deactivated: bool
        :keyword auto_deactivate_reason: Required. The reason for the subscription being auto
         deactivated. May contains the error response that the receiver returned.
        :paramtype auto_deactivate_reason: str
        :keyword version: Required. Version of the resthook subscription. Determines the resthook body
         being fired. Known values are: "v1", "v2", "v3".
        :paramtype version: str or ~affinda.models.ResthookSubscriptionVersion
        """
        super(ResthookSubscription, self).__init__(**kwargs)
        self.id = kwargs["id"]
        self.event = kwargs["event"]
        self.organization = kwargs["organization"]
        self.workspace = kwargs["workspace"]
        self.target_url = kwargs["target_url"]
        self.active = kwargs["active"]
        self.auto_deactivated = kwargs["auto_deactivated"]
        self.auto_deactivate_reason = kwargs["auto_deactivate_reason"]
        self.version = kwargs["version"]


class ResthookSubscriptionCreate(msrest.serialization.Model):
    """ResthookSubscriptionCreate.

    All required parameters must be populated in order to send to Azure.

    :ivar target_url: Required. URL of the resthook's receiver.
    :vartype target_url: str
    :ivar event: Required. The event name to subscribe to. Known values are:
     "resume.parse.succeeded", "resume.parse.failed", "resume.parse.completed",
     "invoice.parse.succeeded", "invoice.parse.failed", "invoice.parse.completed",
     "invoice.validate.completed", "document.parse.succeeded", "document.parse.failed",
     "document.parse.completed", "document.validate.completed", "document.classify.succeeded",
     "document.classify.failed", "document.classify.completed", "document.rejected",
     "annotation.validated".
    :vartype event: str or ~affinda.models.ResthookEvent
    :ivar organization:
    :vartype organization: str
    :ivar workspace:
    :vartype workspace: str
    :ivar version: Version of the resthook subscription. Determines the resthook body being fired.
     Known values are: "v1", "v2", "v3".
    :vartype version: str or ~affinda.models.Version
    """

    _validation = {
        "target_url": {"required": True},
        "event": {"required": True},
    }

    _attribute_map = {
        "target_url": {"key": "targetUrl", "type": "str"},
        "event": {"key": "event", "type": "str"},
        "organization": {"key": "organization", "type": "str"},
        "workspace": {"key": "workspace", "type": "str"},
        "version": {"key": "version", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword target_url: Required. URL of the resthook's receiver.
        :paramtype target_url: str
        :keyword event: Required. The event name to subscribe to. Known values are:
         "resume.parse.succeeded", "resume.parse.failed", "resume.parse.completed",
         "invoice.parse.succeeded", "invoice.parse.failed", "invoice.parse.completed",
         "invoice.validate.completed", "document.parse.succeeded", "document.parse.failed",
         "document.parse.completed", "document.validate.completed", "document.classify.succeeded",
         "document.classify.failed", "document.classify.completed", "document.rejected",
         "annotation.validated".
        :paramtype event: str or ~affinda.models.ResthookEvent
        :keyword organization:
        :paramtype organization: str
        :keyword workspace:
        :paramtype workspace: str
        :keyword version: Version of the resthook subscription. Determines the resthook body being
         fired. Known values are: "v1", "v2", "v3".
        :paramtype version: str or ~affinda.models.Version
        """
        super(ResthookSubscriptionCreate, self).__init__(**kwargs)
        self.target_url = kwargs["target_url"]
        self.event = kwargs["event"]
        self.organization = kwargs.get("organization", None)
        self.workspace = kwargs.get("workspace", None)
        self.version = kwargs.get("version", None)


class ResthookSubscriptionUpdate(msrest.serialization.Model):
    """ResthookSubscriptionUpdate.

    :ivar event: The event name to subscribe to. Known values are: "resume.parse.succeeded",
     "resume.parse.failed", "resume.parse.completed", "invoice.parse.succeeded",
     "invoice.parse.failed", "invoice.parse.completed", "invoice.validate.completed",
     "document.parse.succeeded", "document.parse.failed", "document.parse.completed",
     "document.validate.completed", "document.classify.succeeded", "document.classify.failed",
     "document.classify.completed", "document.rejected", "annotation.validated".
    :vartype event: str or ~affinda.models.ResthookEvent
    :ivar organization: Uniquely identify an organization.
    :vartype organization: str
    :ivar workspace: Uniquely identify a workspace.
    :vartype workspace: str
    :ivar version: Version of the resthook subscription. Determines the resthook body being fired.
     Known values are: "v1", "v2", "v3".
    :vartype version: str or ~affinda.models.Version
    """

    _attribute_map = {
        "event": {"key": "event", "type": "str"},
        "organization": {"key": "organization", "type": "str"},
        "workspace": {"key": "workspace", "type": "str"},
        "version": {"key": "version", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword event: The event name to subscribe to. Known values are: "resume.parse.succeeded",
         "resume.parse.failed", "resume.parse.completed", "invoice.parse.succeeded",
         "invoice.parse.failed", "invoice.parse.completed", "invoice.validate.completed",
         "document.parse.succeeded", "document.parse.failed", "document.parse.completed",
         "document.validate.completed", "document.classify.succeeded", "document.classify.failed",
         "document.classify.completed", "document.rejected", "annotation.validated".
        :paramtype event: str or ~affinda.models.ResthookEvent
        :keyword organization: Uniquely identify an organization.
        :paramtype organization: str
        :keyword workspace: Uniquely identify a workspace.
        :paramtype workspace: str
        :keyword version: Version of the resthook subscription. Determines the resthook body being
         fired. Known values are: "v1", "v2", "v3".
        :paramtype version: str or ~affinda.models.Version
        """
        super(ResthookSubscriptionUpdate, self).__init__(**kwargs)
        self.event = kwargs.get("event", None)
        self.organization = kwargs.get("organization", None)
        self.workspace = kwargs.get("workspace", None)
        self.version = kwargs.get("version", None)


class ResthookSubscriptionWorkspace(msrest.serialization.Model):
    """ResthookSubscriptionWorkspace.

    All required parameters must be populated in order to send to Azure.

    :ivar identifier: Required. Uniquely identify a workspace.
    :vartype identifier: str
    :ivar name: Required.
    :vartype name: str
    :ivar organization: Required.
    :vartype organization: ~affinda.models.Organization
    """

    _validation = {
        "identifier": {"required": True},
        "name": {"required": True},
        "organization": {"required": True},
    }

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "organization": {"key": "organization", "type": "Organization"},
    }

    def __init__(self, **kwargs):
        """
        :keyword identifier: Required. Uniquely identify a workspace.
        :paramtype identifier: str
        :keyword name: Required.
        :paramtype name: str
        :keyword organization: Required.
        :paramtype organization: ~affinda.models.Organization
        """
        super(ResthookSubscriptionWorkspace, self).__init__(**kwargs)
        self.identifier = kwargs["identifier"]
        self.name = kwargs["name"]
        self.organization = kwargs["organization"]


class Resume(Document):
    """Resume.

    All required parameters must be populated in order to send to Azure.

    :ivar extractor: Required. Constant filled by server.
    :vartype extractor: str
    :ivar meta: Required.
    :vartype meta: ~affinda.models.DocumentMeta
    :ivar error:
    :vartype error: ~affinda.models.DocumentError
    :ivar warnings:
    :vartype warnings: list[~affinda.models.DocumentWarning]
    :ivar data: A JSON-encoded string of the ``ResumeData`` object.
    :vartype data: ~affinda.models.ResumeData
    """

    _validation = {
        "extractor": {"required": True},
        "meta": {"required": True},
    }

    _attribute_map = {
        "extractor": {"key": "extractor", "type": "str"},
        "meta": {"key": "meta", "type": "DocumentMeta"},
        "error": {"key": "error", "type": "DocumentError"},
        "warnings": {"key": "warnings", "type": "[DocumentWarning]"},
        "data": {"key": "data", "type": "ResumeData"},
    }

    def __init__(self, **kwargs):
        """
        :keyword meta: Required.
        :paramtype meta: ~affinda.models.DocumentMeta
        :keyword error:
        :paramtype error: ~affinda.models.DocumentError
        :keyword warnings:
        :paramtype warnings: list[~affinda.models.DocumentWarning]
        :keyword data: A JSON-encoded string of the ``ResumeData`` object.
        :paramtype data: ~affinda.models.ResumeData
        """
        super(Resume, self).__init__(**kwargs)
        self.extractor = "resume"  # type: str
        self.data = kwargs.get("data", None)


class ResumeData(msrest.serialization.Model):
    """A JSON-encoded string of the ``ResumeData`` object.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar name:
    :vartype name: ~affinda.models.ResumeDataName
    :ivar phone_numbers:
    :vartype phone_numbers: list[str]
    :ivar phone_number_details:
    :vartype phone_number_details: list[~affinda.models.ResumeDataPhoneNumberDetailsItem]
    :ivar websites:
    :vartype websites: list[str]
    :ivar emails:
    :vartype emails: list[str]
    :ivar date_of_birth:
    :vartype date_of_birth: str
    :ivar location:
    :vartype location: ~affinda.models.Location
    :ivar objective:
    :vartype objective: str
    :ivar languages:
    :vartype languages: list[str or ~affinda.models.ResumeDataLanguagesItem]
    :ivar language_codes:
    :vartype language_codes: list[str]
    :ivar summary:
    :vartype summary: str
    :ivar total_years_experience:
    :vartype total_years_experience: int
    :ivar head_shot: base64 encoded string.
    :vartype head_shot: bytearray
    :ivar education:
    :vartype education: list[~affinda.models.Education]
    :ivar profession: Prediction of the candidate's profession based on recent work experience.
    :vartype profession: str
    :ivar linkedin: Linkedin account associated with the candidate.
    :vartype linkedin: str
    :ivar work_experience:
    :vartype work_experience: list[~affinda.models.ResumeDataWorkExperienceItem]
    :ivar skills:
    :vartype skills: list[~affinda.models.ResumeDataSkillsItem]
    :ivar certifications:
    :vartype certifications: list[str]
    :ivar publications:
    :vartype publications: list[str]
    :ivar referees:
    :vartype referees: list[~affinda.models.ResumeDataRefereesItem]
    :ivar sections:
    :vartype sections: list[~affinda.models.ResumeDataSectionsItem]
    :ivar is_resume_probability: Probability that the given document is a resume. Values below 30
     suggest that the document is not a resume.
    :vartype is_resume_probability: int
    :ivar raw_text: All of the raw text of the parsed resume, example is shortened for readability.
    :vartype raw_text: str
    :ivar redacted_text: Redacted version of the text in the resume, removing PII.
    :vartype redacted_text: str
    """

    _validation = {
        "language_codes": {"readonly": True},
        "total_years_experience": {"minimum": 0},
        "head_shot": {"readonly": True},
        "profession": {"readonly": True},
        "linkedin": {"readonly": True},
        "sections": {"readonly": True},
        "is_resume_probability": {"readonly": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "name": {"key": "name", "type": "ResumeDataName"},
        "phone_numbers": {"key": "phoneNumbers", "type": "[str]"},
        "phone_number_details": {
            "key": "phoneNumberDetails",
            "type": "[ResumeDataPhoneNumberDetailsItem]",
        },
        "websites": {"key": "websites", "type": "[str]"},
        "emails": {"key": "emails", "type": "[str]"},
        "date_of_birth": {"key": "dateOfBirth", "type": "str"},
        "location": {"key": "location", "type": "Location"},
        "objective": {"key": "objective", "type": "str"},
        "languages": {"key": "languages", "type": "[str]"},
        "language_codes": {"key": "languageCodes", "type": "[str]"},
        "summary": {"key": "summary", "type": "str"},
        "total_years_experience": {"key": "totalYearsExperience", "type": "int"},
        "head_shot": {"key": "headShot", "type": "bytearray"},
        "education": {"key": "education", "type": "[Education]"},
        "profession": {"key": "profession", "type": "str"},
        "linkedin": {"key": "linkedin", "type": "str"},
        "work_experience": {"key": "workExperience", "type": "[ResumeDataWorkExperienceItem]"},
        "skills": {"key": "skills", "type": "[ResumeDataSkillsItem]"},
        "certifications": {"key": "certifications", "type": "[str]"},
        "publications": {"key": "publications", "type": "[str]"},
        "referees": {"key": "referees", "type": "[ResumeDataRefereesItem]"},
        "sections": {"key": "sections", "type": "[ResumeDataSectionsItem]"},
        "is_resume_probability": {"key": "isResumeProbability", "type": "int"},
        "raw_text": {"key": "rawText", "type": "str"},
        "redacted_text": {"key": "redactedText", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword name:
        :paramtype name: ~affinda.models.ResumeDataName
        :keyword phone_numbers:
        :paramtype phone_numbers: list[str]
        :keyword phone_number_details:
        :paramtype phone_number_details: list[~affinda.models.ResumeDataPhoneNumberDetailsItem]
        :keyword websites:
        :paramtype websites: list[str]
        :keyword emails:
        :paramtype emails: list[str]
        :keyword date_of_birth:
        :paramtype date_of_birth: str
        :keyword location:
        :paramtype location: ~affinda.models.Location
        :keyword objective:
        :paramtype objective: str
        :keyword languages:
        :paramtype languages: list[str or ~affinda.models.ResumeDataLanguagesItem]
        :keyword summary:
        :paramtype summary: str
        :keyword total_years_experience:
        :paramtype total_years_experience: int
        :keyword education:
        :paramtype education: list[~affinda.models.Education]
        :keyword work_experience:
        :paramtype work_experience: list[~affinda.models.ResumeDataWorkExperienceItem]
        :keyword skills:
        :paramtype skills: list[~affinda.models.ResumeDataSkillsItem]
        :keyword certifications:
        :paramtype certifications: list[str]
        :keyword publications:
        :paramtype publications: list[str]
        :keyword referees:
        :paramtype referees: list[~affinda.models.ResumeDataRefereesItem]
        :keyword raw_text: All of the raw text of the parsed resume, example is shortened for
         readability.
        :paramtype raw_text: str
        :keyword redacted_text: Redacted version of the text in the resume, removing PII.
        :paramtype redacted_text: str
        """
        super(ResumeData, self).__init__(**kwargs)
        self.additional_properties = kwargs.get("additional_properties", None)
        self.name = kwargs.get("name", None)
        self.phone_numbers = kwargs.get("phone_numbers", None)
        self.phone_number_details = kwargs.get("phone_number_details", None)
        self.websites = kwargs.get("websites", None)
        self.emails = kwargs.get("emails", None)
        self.date_of_birth = kwargs.get("date_of_birth", None)
        self.location = kwargs.get("location", None)
        self.objective = kwargs.get("objective", "")
        self.languages = kwargs.get("languages", None)
        self.language_codes = None
        self.summary = kwargs.get("summary", "")
        self.total_years_experience = kwargs.get("total_years_experience", None)
        self.head_shot = None
        self.education = kwargs.get("education", None)
        self.profession = None
        self.linkedin = None
        self.work_experience = kwargs.get("work_experience", None)
        self.skills = kwargs.get("skills", None)
        self.certifications = kwargs.get("certifications", None)
        self.publications = kwargs.get("publications", None)
        self.referees = kwargs.get("referees", None)
        self.sections = None
        self.is_resume_probability = None
        self.raw_text = kwargs.get("raw_text", None)
        self.redacted_text = kwargs.get("redacted_text", None)


class ResumeDataName(msrest.serialization.Model):
    """ResumeDataName.

    :ivar raw:
    :vartype raw: str
    :ivar first:
    :vartype first: str
    :ivar last:
    :vartype last: str
    :ivar middle:
    :vartype middle: str
    :ivar title:
    :vartype title: str
    """

    _attribute_map = {
        "raw": {"key": "raw", "type": "str"},
        "first": {"key": "first", "type": "str"},
        "last": {"key": "last", "type": "str"},
        "middle": {"key": "middle", "type": "str"},
        "title": {"key": "title", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword raw:
        :paramtype raw: str
        :keyword first:
        :paramtype first: str
        :keyword last:
        :paramtype last: str
        :keyword middle:
        :paramtype middle: str
        :keyword title:
        :paramtype title: str
        """
        super(ResumeDataName, self).__init__(**kwargs)
        self.raw = kwargs.get("raw", None)
        self.first = kwargs.get("first", None)
        self.last = kwargs.get("last", None)
        self.middle = kwargs.get("middle", None)
        self.title = kwargs.get("title", None)


class ResumeDataPhoneNumberDetailsItem(msrest.serialization.Model):
    """ResumeDataPhoneNumberDetailsItem.

    :ivar raw_text:
    :vartype raw_text: str
    :ivar formatted_number:
    :vartype formatted_number: str
    :ivar country_code:
    :vartype country_code: str
    :ivar international_country_code:
    :vartype international_country_code: int
    :ivar national_number:
    :vartype national_number: str
    """

    _validation = {
        "international_country_code": {"minimum": 1},
    }

    _attribute_map = {
        "raw_text": {"key": "rawText", "type": "str"},
        "formatted_number": {"key": "formattedNumber", "type": "str"},
        "country_code": {"key": "countryCode", "type": "str"},
        "international_country_code": {"key": "internationalCountryCode", "type": "int"},
        "national_number": {"key": "nationalNumber", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword raw_text:
        :paramtype raw_text: str
        :keyword formatted_number:
        :paramtype formatted_number: str
        :keyword country_code:
        :paramtype country_code: str
        :keyword international_country_code:
        :paramtype international_country_code: int
        :keyword national_number:
        :paramtype national_number: str
        """
        super(ResumeDataPhoneNumberDetailsItem, self).__init__(**kwargs)
        self.raw_text = kwargs.get("raw_text", None)
        self.formatted_number = kwargs.get("formatted_number", None)
        self.country_code = kwargs.get("country_code", None)
        self.international_country_code = kwargs.get("international_country_code", None)
        self.national_number = kwargs.get("national_number", None)


class ResumeDataRefereesItem(msrest.serialization.Model):
    """ResumeDataRefereesItem.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar name:
    :vartype name: str
    :ivar text:
    :vartype text: str
    :ivar email:
    :vartype email: str
    :ivar number:
    :vartype number: str
    :ivar position:
    :vartype position: str
    """

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "name": {"key": "name", "type": "str"},
        "text": {"key": "text", "type": "str"},
        "email": {"key": "email", "type": "str"},
        "number": {"key": "number", "type": "str"},
        "position": {"key": "position", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword name:
        :paramtype name: str
        :keyword text:
        :paramtype text: str
        :keyword email:
        :paramtype email: str
        :keyword number:
        :paramtype number: str
        :keyword position:
        :paramtype position: str
        """
        super(ResumeDataRefereesItem, self).__init__(**kwargs)
        self.additional_properties = kwargs.get("additional_properties", None)
        self.name = kwargs.get("name", None)
        self.text = kwargs.get("text", None)
        self.email = kwargs.get("email", None)
        self.number = kwargs.get("number", None)
        self.position = kwargs.get("position", None)


class ResumeDataSectionsItem(msrest.serialization.Model):
    """ResumeDataSectionsItem.

    :ivar section_type:
    :vartype section_type: str
    :ivar bbox:
    :vartype bbox: list[float]
    :ivar page_index:
    :vartype page_index: int
    :ivar text:
    :vartype text: str
    """

    _validation = {
        "bbox": {"max_items": 4, "min_items": 4},
    }

    _attribute_map = {
        "section_type": {"key": "sectionType", "type": "str"},
        "bbox": {"key": "bbox", "type": "[float]"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "text": {"key": "text", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword section_type:
        :paramtype section_type: str
        :keyword bbox:
        :paramtype bbox: list[float]
        :keyword page_index:
        :paramtype page_index: int
        :keyword text:
        :paramtype text: str
        """
        super(ResumeDataSectionsItem, self).__init__(**kwargs)
        self.section_type = kwargs.get("section_type", None)
        self.bbox = kwargs.get("bbox", None)
        self.page_index = kwargs.get("page_index", None)
        self.text = kwargs.get("text", None)


class ResumeDataSkillsItem(msrest.serialization.Model):
    """ResumeDataSkillsItem.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id:
    :vartype id: int
    :ivar emsi_id: EMSI id of this skill.
    :vartype emsi_id: str
    :ivar name:
    :vartype name: str
    :ivar last_used:
    :vartype last_used: str
    :ivar number_of_months:
    :vartype number_of_months: int
    :ivar type:
    :vartype type: str
    :ivar count:
    :vartype count: int
    :ivar weighting:
    :vartype weighting: float
    :ivar sources:
    :vartype sources: list[~affinda.models.ResumeDataSkillsPropertiesItemsItem]
    """

    _validation = {
        "id": {"minimum": 1},
        "emsi_id": {"readonly": True},
        "number_of_months": {"minimum": 0},
        "type": {"readonly": True},
        "count": {"readonly": True, "minimum": 0},
        "weighting": {"readonly": True},
        "sources": {"readonly": True},
    }

    _attribute_map = {
        "id": {"key": "id", "type": "int"},
        "emsi_id": {"key": "emsiId", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "last_used": {"key": "lastUsed", "type": "str"},
        "number_of_months": {"key": "numberOfMonths", "type": "int"},
        "type": {"key": "type", "type": "str"},
        "count": {"key": "count", "type": "int"},
        "weighting": {"key": "weighting", "type": "float"},
        "sources": {"key": "sources", "type": "[ResumeDataSkillsPropertiesItemsItem]"},
    }

    def __init__(self, **kwargs):
        """
        :keyword id:
        :paramtype id: int
        :keyword name:
        :paramtype name: str
        :keyword last_used:
        :paramtype last_used: str
        :keyword number_of_months:
        :paramtype number_of_months: int
        """
        super(ResumeDataSkillsItem, self).__init__(**kwargs)
        self.id = kwargs.get("id", None)
        self.emsi_id = None
        self.name = kwargs.get("name", None)
        self.last_used = kwargs.get("last_used", None)
        self.number_of_months = kwargs.get("number_of_months", None)
        self.type = None
        self.count = None
        self.weighting = None
        self.sources = None


class ResumeDataSkillsPropertiesItemsItem(msrest.serialization.Model):
    """ResumeDataSkillsPropertiesItemsItem.

    :ivar section:
    :vartype section: str
    :ivar position: If this skill is extracted from a "workExperience" section, the "position" is
     the index of the work experience where this skill is found, with 0 being the first work
     experience, 1 being the second work experience, and so on.
    :vartype position: int
    :ivar work_experience_id: If this skill is extracted from a "workExperience" section, the
     "workExperienceId" is the id of the work experience where this skill is found.
    :vartype work_experience_id: int
    """

    _attribute_map = {
        "section": {"key": "section", "type": "str"},
        "position": {"key": "position", "type": "int"},
        "work_experience_id": {"key": "workExperienceId", "type": "int"},
    }

    def __init__(self, **kwargs):
        """
        :keyword section:
        :paramtype section: str
        :keyword position: If this skill is extracted from a "workExperience" section, the "position"
         is the index of the work experience where this skill is found, with 0 being the first work
         experience, 1 being the second work experience, and so on.
        :paramtype position: int
        :keyword work_experience_id: If this skill is extracted from a "workExperience" section, the
         "workExperienceId" is the id of the work experience where this skill is found.
        :paramtype work_experience_id: int
        """
        super(ResumeDataSkillsPropertiesItemsItem, self).__init__(**kwargs)
        self.section = kwargs.get("section", None)
        self.position = kwargs.get("position", None)
        self.work_experience_id = kwargs.get("work_experience_id", None)


class ResumeDataWorkExperienceItem(msrest.serialization.Model):
    """ResumeDataWorkExperienceItem.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id:
    :vartype id: int
    :ivar job_title:
    :vartype job_title: str
    :ivar soc_code:
    :vartype soc_code: str
    :ivar soc_name:
    :vartype soc_name: str
    :ivar organization:
    :vartype organization: str
    :ivar industry:
    :vartype industry: str
    :ivar location:
    :vartype location: ~affinda.models.Location
    :ivar job_description:
    :vartype job_description: str
    :ivar dates:
    :vartype dates: ~affinda.models.ResumeDataWorkExperienceItemDates
    :ivar occupation:
    :vartype occupation: ~affinda.models.ResumeDataWorkExperienceItemOccupation
    """

    _validation = {
        "id": {"minimum": 1},
        "soc_code": {"readonly": True},
        "soc_name": {"readonly": True},
        "industry": {"readonly": True},
        "occupation": {"readonly": True},
    }

    _attribute_map = {
        "id": {"key": "id", "type": "int"},
        "job_title": {"key": "jobTitle", "type": "str"},
        "soc_code": {"key": "socCode", "type": "str"},
        "soc_name": {"key": "socName", "type": "str"},
        "organization": {"key": "organization", "type": "str"},
        "industry": {"key": "industry", "type": "str"},
        "location": {"key": "location", "type": "Location"},
        "job_description": {"key": "jobDescription", "type": "str"},
        "dates": {"key": "dates", "type": "ResumeDataWorkExperienceItemDates"},
        "occupation": {"key": "occupation", "type": "ResumeDataWorkExperienceItemOccupation"},
    }

    def __init__(self, **kwargs):
        """
        :keyword id:
        :paramtype id: int
        :keyword job_title:
        :paramtype job_title: str
        :keyword organization:
        :paramtype organization: str
        :keyword location:
        :paramtype location: ~affinda.models.Location
        :keyword job_description:
        :paramtype job_description: str
        :keyword dates:
        :paramtype dates: ~affinda.models.ResumeDataWorkExperienceItemDates
        """
        super(ResumeDataWorkExperienceItem, self).__init__(**kwargs)
        self.id = kwargs.get("id", None)
        self.job_title = kwargs.get("job_title", None)
        self.soc_code = None
        self.soc_name = None
        self.organization = kwargs.get("organization", None)
        self.industry = None
        self.location = kwargs.get("location", None)
        self.job_description = kwargs.get("job_description", None)
        self.dates = kwargs.get("dates", None)
        self.occupation = None


class ResumeDataWorkExperienceItemDates(msrest.serialization.Model):
    """ResumeDataWorkExperienceItemDates.

    :ivar start_date:
    :vartype start_date: ~datetime.date
    :ivar end_date:
    :vartype end_date: ~datetime.date
    :ivar months_in_position:
    :vartype months_in_position: int
    :ivar is_current:
    :vartype is_current: bool
    :ivar raw_text:
    :vartype raw_text: str
    """

    _validation = {
        "months_in_position": {"minimum": 0},
    }

    _attribute_map = {
        "start_date": {"key": "startDate", "type": "date"},
        "end_date": {"key": "endDate", "type": "date"},
        "months_in_position": {"key": "monthsInPosition", "type": "int"},
        "is_current": {"key": "isCurrent", "type": "bool"},
        "raw_text": {"key": "rawText", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword start_date:
        :paramtype start_date: ~datetime.date
        :keyword end_date:
        :paramtype end_date: ~datetime.date
        :keyword months_in_position:
        :paramtype months_in_position: int
        :keyword is_current:
        :paramtype is_current: bool
        :keyword raw_text:
        :paramtype raw_text: str
        """
        super(ResumeDataWorkExperienceItemDates, self).__init__(**kwargs)
        self.start_date = kwargs.get("start_date", None)
        self.end_date = kwargs.get("end_date", None)
        self.months_in_position = kwargs.get("months_in_position", None)
        self.is_current = kwargs.get("is_current", None)
        self.raw_text = kwargs.get("raw_text", None)


class ResumeDataWorkExperienceItemOccupation(msrest.serialization.Model):
    """ResumeDataWorkExperienceItemOccupation.

    :ivar job_title: The raw (not normalized) job title pulled from the work experience entry.
    :vartype job_title: str
    :ivar job_title_normalized: Mapped onto the EMSI job title taxonomy if a sufficiently close
     match exists.
    :vartype job_title_normalized: str
    :ivar emsi_id: EMSI id of the normalised job title.
    :vartype emsi_id: str
    :ivar management_level: Known values are: "None", "Low", "Mid", "Upper".
    :vartype management_level: str or ~affinda.models.ManagementLevel
    :ivar classification:
    :vartype classification:
     ~affinda.models.Components1TryetgSchemasResumedataPropertiesWorkexperienceItemsPropertiesOccupationPropertiesClassification
    """

    _attribute_map = {
        "job_title": {"key": "jobTitle", "type": "str"},
        "job_title_normalized": {"key": "jobTitleNormalized", "type": "str"},
        "emsi_id": {"key": "emsiId", "type": "str"},
        "management_level": {"key": "managementLevel", "type": "str"},
        "classification": {
            "key": "classification",
            "type": "Components1TryetgSchemasResumedataPropertiesWorkexperienceItemsPropertiesOccupationPropertiesClassification",
        },
    }

    def __init__(self, **kwargs):
        """
        :keyword job_title: The raw (not normalized) job title pulled from the work experience entry.
        :paramtype job_title: str
        :keyword job_title_normalized: Mapped onto the EMSI job title taxonomy if a sufficiently close
         match exists.
        :paramtype job_title_normalized: str
        :keyword emsi_id: EMSI id of the normalised job title.
        :paramtype emsi_id: str
        :keyword management_level: Known values are: "None", "Low", "Mid", "Upper".
        :paramtype management_level: str or ~affinda.models.ManagementLevel
        :keyword classification:
        :paramtype classification:
         ~affinda.models.Components1TryetgSchemasResumedataPropertiesWorkexperienceItemsPropertiesOccupationPropertiesClassification
        """
        super(ResumeDataWorkExperienceItemOccupation, self).__init__(**kwargs)
        self.job_title = kwargs.get("job_title", None)
        self.job_title_normalized = kwargs.get("job_title_normalized", None)
        self.emsi_id = kwargs.get("emsi_id", None)
        self.management_level = kwargs.get("management_level", None)
        self.classification = kwargs.get("classification", None)


class ResumeRedact(Document):
    """ResumeRedact.

    All required parameters must be populated in order to send to Azure.

    :ivar extractor: Required. Constant filled by server.
    :vartype extractor: str
    :ivar meta: Required.
    :vartype meta: ~affinda.models.DocumentMeta
    :ivar error:
    :vartype error: ~affinda.models.DocumentError
    :ivar warnings:
    :vartype warnings: list[~affinda.models.DocumentWarning]
    :ivar data:
    :vartype data: ~affinda.models.ResumeRedactData
    """

    _validation = {
        "extractor": {"required": True},
        "meta": {"required": True},
    }

    _attribute_map = {
        "extractor": {"key": "extractor", "type": "str"},
        "meta": {"key": "meta", "type": "DocumentMeta"},
        "error": {"key": "error", "type": "DocumentError"},
        "warnings": {"key": "warnings", "type": "[DocumentWarning]"},
        "data": {"key": "data", "type": "ResumeRedactData"},
    }

    def __init__(self, **kwargs):
        """
        :keyword meta: Required.
        :paramtype meta: ~affinda.models.DocumentMeta
        :keyword error:
        :paramtype error: ~affinda.models.DocumentError
        :keyword warnings:
        :paramtype warnings: list[~affinda.models.DocumentWarning]
        :keyword data:
        :paramtype data: ~affinda.models.ResumeRedactData
        """
        super(ResumeRedact, self).__init__(**kwargs)
        self.extractor = "resume-redact"  # type: str
        self.data = kwargs.get("data", None)


class ResumeRedactData(msrest.serialization.Model):
    """ResumeRedactData.

    :ivar redacted_pdf: URL to download the redacted resume.
    :vartype redacted_pdf: str
    """

    _attribute_map = {
        "redacted_pdf": {"key": "redactedPdf", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword redacted_pdf: URL to download the redacted resume.
        :paramtype redacted_pdf: str
        """
        super(ResumeRedactData, self).__init__(**kwargs)
        self.redacted_pdf = kwargs.get("redacted_pdf", None)


class ResumeSearch(msrest.serialization.Model):
    """ResumeSearch.

    :ivar count: Total number of results.
    :vartype count: int
    :ivar next: URL to request next page of results.
    :vartype next: str
    :ivar previous: URL to request previous page of results.
    :vartype previous: str
    :ivar parameters:
    :vartype parameters: ~affinda.models.ResumeSearchParameters
    :ivar results:
    :vartype results: list[~affinda.models.ResumeSearchResult]
    """

    _validation = {
        "count": {"minimum": 0},
    }

    _attribute_map = {
        "count": {"key": "count", "type": "int"},
        "next": {"key": "next", "type": "str"},
        "previous": {"key": "previous", "type": "str"},
        "parameters": {"key": "parameters", "type": "ResumeSearchParameters"},
        "results": {"key": "results", "type": "[ResumeSearchResult]"},
    }

    def __init__(self, **kwargs):
        """
        :keyword count: Total number of results.
        :paramtype count: int
        :keyword next: URL to request next page of results.
        :paramtype next: str
        :keyword previous: URL to request previous page of results.
        :paramtype previous: str
        :keyword parameters:
        :paramtype parameters: ~affinda.models.ResumeSearchParameters
        :keyword results:
        :paramtype results: list[~affinda.models.ResumeSearchResult]
        """
        super(ResumeSearch, self).__init__(**kwargs)
        self.count = kwargs.get("count", None)
        self.next = kwargs.get("next", None)
        self.previous = kwargs.get("previous", None)
        self.parameters = kwargs.get("parameters", None)
        self.results = kwargs.get("results", None)


class ResumeSearchConfig(msrest.serialization.Model):
    """ResumeSearchConfig.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar allow_pdf_download:
    :vartype allow_pdf_download: bool
    :ivar max_results: Maximum number of results that can be returned. Setting to "null" means no
     limitation.
    :vartype max_results: int
    :ivar display_job_title:
    :vartype display_job_title: bool
    :ivar display_location:
    :vartype display_location: bool
    :ivar display_years_experience:
    :vartype display_years_experience: bool
    :ivar display_occupation_group:
    :vartype display_occupation_group: bool
    :ivar display_education:
    :vartype display_education: bool
    :ivar display_skills:
    :vartype display_skills: bool
    :ivar display_languages:
    :vartype display_languages: bool
    :ivar display_management_level:
    :vartype display_management_level: bool
    :ivar display_keywords:
    :vartype display_keywords: bool
    :ivar weight_job_title:
    :vartype weight_job_title: float
    :ivar weight_location:
    :vartype weight_location: float
    :ivar weight_years_experience:
    :vartype weight_years_experience: float
    :ivar weight_occupation_group:
    :vartype weight_occupation_group: float
    :ivar weight_education:
    :vartype weight_education: float
    :ivar weight_skills:
    :vartype weight_skills: float
    :ivar weight_languages:
    :vartype weight_languages: float
    :ivar weight_management_level:
    :vartype weight_management_level: float
    :ivar weight_keywords:
    :vartype weight_keywords: float
    :ivar indices: List of index names.
    :vartype indices: list[str]
    :ivar show_index_dropdown: Controls whether or not the index dropdown is displayed to the user.
    :vartype show_index_dropdown: bool
    :ivar search_tool_theme: Customize the theme of the embeded search tool.
    :vartype search_tool_theme: ~affinda.models.ResumeSearchConfigSearchToolTheme
    :ivar user_id: ID of the logged in user.
    :vartype user_id: int
    :ivar username: Username of the logged in user.
    :vartype username: str
    :ivar actions: A list of actions to show in the dropdown in the embedded search tool.
    :vartype actions: list[~affinda.models.SearchConfigAction]
    :ivar hide_toolbar: Hide the reset/import toolbar.
    :vartype hide_toolbar: bool
    :ivar hide_side_panel: Hide the entire side panel.
    :vartype hide_side_panel: bool
    :ivar custom_fields_config:
    :vartype custom_fields_config: list[~affinda.models.CustomFieldConfig]
    :ivar distance_unit: The unit of distance to use for location based searches. Known values are:
     "mi", "km".
    :vartype distance_unit: str or ~affinda.models.ResumeSearchConfigDistanceUnit
    """

    _validation = {
        "max_results": {"minimum": 1},
        "user_id": {"readonly": True, "minimum": 1},
        "username": {"readonly": True},
    }

    _attribute_map = {
        "allow_pdf_download": {"key": "allowPdfDownload", "type": "bool"},
        "max_results": {"key": "maxResults", "type": "int"},
        "display_job_title": {"key": "displayJobTitle", "type": "bool"},
        "display_location": {"key": "displayLocation", "type": "bool"},
        "display_years_experience": {"key": "displayYearsExperience", "type": "bool"},
        "display_occupation_group": {"key": "displayOccupationGroup", "type": "bool"},
        "display_education": {"key": "displayEducation", "type": "bool"},
        "display_skills": {"key": "displaySkills", "type": "bool"},
        "display_languages": {"key": "displayLanguages", "type": "bool"},
        "display_management_level": {"key": "displayManagementLevel", "type": "bool"},
        "display_keywords": {"key": "displayKeywords", "type": "bool"},
        "weight_job_title": {"key": "weightJobTitle", "type": "float"},
        "weight_location": {"key": "weightLocation", "type": "float"},
        "weight_years_experience": {"key": "weightYearsExperience", "type": "float"},
        "weight_occupation_group": {"key": "weightOccupationGroup", "type": "float"},
        "weight_education": {"key": "weightEducation", "type": "float"},
        "weight_skills": {"key": "weightSkills", "type": "float"},
        "weight_languages": {"key": "weightLanguages", "type": "float"},
        "weight_management_level": {"key": "weightManagementLevel", "type": "float"},
        "weight_keywords": {"key": "weightKeywords", "type": "float"},
        "indices": {"key": "indices", "type": "[str]"},
        "show_index_dropdown": {"key": "showIndexDropdown", "type": "bool"},
        "search_tool_theme": {
            "key": "searchToolTheme",
            "type": "ResumeSearchConfigSearchToolTheme",
        },
        "user_id": {"key": "userId", "type": "int"},
        "username": {"key": "username", "type": "str"},
        "actions": {"key": "actions", "type": "[SearchConfigAction]"},
        "hide_toolbar": {"key": "hideToolbar", "type": "bool"},
        "hide_side_panel": {"key": "hideSidePanel", "type": "bool"},
        "custom_fields_config": {"key": "customFieldsConfig", "type": "[CustomFieldConfig]"},
        "distance_unit": {"key": "distanceUnit", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword allow_pdf_download:
        :paramtype allow_pdf_download: bool
        :keyword max_results: Maximum number of results that can be returned. Setting to "null" means
         no limitation.
        :paramtype max_results: int
        :keyword display_job_title:
        :paramtype display_job_title: bool
        :keyword display_location:
        :paramtype display_location: bool
        :keyword display_years_experience:
        :paramtype display_years_experience: bool
        :keyword display_occupation_group:
        :paramtype display_occupation_group: bool
        :keyword display_education:
        :paramtype display_education: bool
        :keyword display_skills:
        :paramtype display_skills: bool
        :keyword display_languages:
        :paramtype display_languages: bool
        :keyword display_management_level:
        :paramtype display_management_level: bool
        :keyword display_keywords:
        :paramtype display_keywords: bool
        :keyword weight_job_title:
        :paramtype weight_job_title: float
        :keyword weight_location:
        :paramtype weight_location: float
        :keyword weight_years_experience:
        :paramtype weight_years_experience: float
        :keyword weight_occupation_group:
        :paramtype weight_occupation_group: float
        :keyword weight_education:
        :paramtype weight_education: float
        :keyword weight_skills:
        :paramtype weight_skills: float
        :keyword weight_languages:
        :paramtype weight_languages: float
        :keyword weight_management_level:
        :paramtype weight_management_level: float
        :keyword weight_keywords:
        :paramtype weight_keywords: float
        :keyword indices: List of index names.
        :paramtype indices: list[str]
        :keyword show_index_dropdown: Controls whether or not the index dropdown is displayed to the
         user.
        :paramtype show_index_dropdown: bool
        :keyword search_tool_theme: Customize the theme of the embeded search tool.
        :paramtype search_tool_theme: ~affinda.models.ResumeSearchConfigSearchToolTheme
        :keyword actions: A list of actions to show in the dropdown in the embedded search tool.
        :paramtype actions: list[~affinda.models.SearchConfigAction]
        :keyword hide_toolbar: Hide the reset/import toolbar.
        :paramtype hide_toolbar: bool
        :keyword hide_side_panel: Hide the entire side panel.
        :paramtype hide_side_panel: bool
        :keyword custom_fields_config:
        :paramtype custom_fields_config: list[~affinda.models.CustomFieldConfig]
        :keyword distance_unit: The unit of distance to use for location based searches. Known values
         are: "mi", "km".
        :paramtype distance_unit: str or ~affinda.models.ResumeSearchConfigDistanceUnit
        """
        super(ResumeSearchConfig, self).__init__(**kwargs)
        self.allow_pdf_download = kwargs.get("allow_pdf_download", None)
        self.max_results = kwargs.get("max_results", None)
        self.display_job_title = kwargs.get("display_job_title", None)
        self.display_location = kwargs.get("display_location", None)
        self.display_years_experience = kwargs.get("display_years_experience", None)
        self.display_occupation_group = kwargs.get("display_occupation_group", None)
        self.display_education = kwargs.get("display_education", None)
        self.display_skills = kwargs.get("display_skills", None)
        self.display_languages = kwargs.get("display_languages", None)
        self.display_management_level = kwargs.get("display_management_level", None)
        self.display_keywords = kwargs.get("display_keywords", None)
        self.weight_job_title = kwargs.get("weight_job_title", None)
        self.weight_location = kwargs.get("weight_location", None)
        self.weight_years_experience = kwargs.get("weight_years_experience", None)
        self.weight_occupation_group = kwargs.get("weight_occupation_group", None)
        self.weight_education = kwargs.get("weight_education", None)
        self.weight_skills = kwargs.get("weight_skills", None)
        self.weight_languages = kwargs.get("weight_languages", None)
        self.weight_management_level = kwargs.get("weight_management_level", None)
        self.weight_keywords = kwargs.get("weight_keywords", None)
        self.indices = kwargs.get("indices", None)
        self.show_index_dropdown = kwargs.get("show_index_dropdown", None)
        self.search_tool_theme = kwargs.get("search_tool_theme", None)
        self.user_id = None
        self.username = None
        self.actions = kwargs.get("actions", None)
        self.hide_toolbar = kwargs.get("hide_toolbar", None)
        self.hide_side_panel = kwargs.get("hide_side_panel", None)
        self.custom_fields_config = kwargs.get("custom_fields_config", None)
        self.distance_unit = kwargs.get("distance_unit", None)


class ResumeSearchConfigSearchToolTheme(ThemeConfig):
    """Customize the theme of the embeded search tool.

    :ivar palette:
    :vartype palette: ~affinda.models.ThemeConfigPalette
    :ivar typography:
    :vartype typography: ~affinda.models.ThemeConfigTypography
    :ivar border_radius:
    :vartype border_radius: float
    :ivar font_url:
    :vartype font_url: str
    """

    _attribute_map = {
        "palette": {"key": "palette", "type": "ThemeConfigPalette"},
        "typography": {"key": "typography", "type": "ThemeConfigTypography"},
        "border_radius": {"key": "borderRadius", "type": "float"},
        "font_url": {"key": "fontUrl", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword palette:
        :paramtype palette: ~affinda.models.ThemeConfigPalette
        :keyword typography:
        :paramtype typography: ~affinda.models.ThemeConfigTypography
        :keyword border_radius:
        :paramtype border_radius: float
        :keyword font_url:
        :paramtype font_url: str
        """
        super(ResumeSearchConfigSearchToolTheme, self).__init__(**kwargs)


class ResumeSearchDetail(msrest.serialization.Model):
    """ResumeSearchDetail.

    :ivar job_title:
    :vartype job_title: ~affinda.models.ResumeSearchDetailJobTitle
    :ivar location:
    :vartype location: ~affinda.models.ResumeSearchDetailLocation
    :ivar education:
    :vartype education: ~affinda.models.ResumeSearchDetailEducation
    :ivar skills:
    :vartype skills: ~affinda.models.ResumeSearchDetailSkills
    :ivar experience:
    :vartype experience: ~affinda.models.ResumeSearchDetailExperience
    :ivar occupation_group:
    :vartype occupation_group: ~affinda.models.ResumeSearchDetailOccupationGroup
    :ivar languages:
    :vartype languages: ~affinda.models.ResumeSearchDetailLanguages
    :ivar management_level:
    :vartype management_level: ~affinda.models.ResumeSearchDetailManagementLevel
    :ivar search_expression:
    :vartype search_expression: ~affinda.models.ResumeSearchDetailSearchExpression
    """

    _attribute_map = {
        "job_title": {"key": "jobTitle", "type": "ResumeSearchDetailJobTitle"},
        "location": {"key": "location", "type": "ResumeSearchDetailLocation"},
        "education": {"key": "education", "type": "ResumeSearchDetailEducation"},
        "skills": {"key": "skills", "type": "ResumeSearchDetailSkills"},
        "experience": {"key": "experience", "type": "ResumeSearchDetailExperience"},
        "occupation_group": {
            "key": "occupationGroup",
            "type": "ResumeSearchDetailOccupationGroup",
        },
        "languages": {"key": "languages", "type": "ResumeSearchDetailLanguages"},
        "management_level": {
            "key": "managementLevel",
            "type": "ResumeSearchDetailManagementLevel",
        },
        "search_expression": {
            "key": "searchExpression",
            "type": "ResumeSearchDetailSearchExpression",
        },
    }

    def __init__(self, **kwargs):
        """
        :keyword job_title:
        :paramtype job_title: ~affinda.models.ResumeSearchDetailJobTitle
        :keyword location:
        :paramtype location: ~affinda.models.ResumeSearchDetailLocation
        :keyword education:
        :paramtype education: ~affinda.models.ResumeSearchDetailEducation
        :keyword skills:
        :paramtype skills: ~affinda.models.ResumeSearchDetailSkills
        :keyword experience:
        :paramtype experience: ~affinda.models.ResumeSearchDetailExperience
        :keyword occupation_group:
        :paramtype occupation_group: ~affinda.models.ResumeSearchDetailOccupationGroup
        :keyword languages:
        :paramtype languages: ~affinda.models.ResumeSearchDetailLanguages
        :keyword management_level:
        :paramtype management_level: ~affinda.models.ResumeSearchDetailManagementLevel
        :keyword search_expression:
        :paramtype search_expression: ~affinda.models.ResumeSearchDetailSearchExpression
        """
        super(ResumeSearchDetail, self).__init__(**kwargs)
        self.job_title = kwargs.get("job_title", None)
        self.location = kwargs.get("location", None)
        self.education = kwargs.get("education", None)
        self.skills = kwargs.get("skills", None)
        self.experience = kwargs.get("experience", None)
        self.occupation_group = kwargs.get("occupation_group", None)
        self.languages = kwargs.get("languages", None)
        self.management_level = kwargs.get("management_level", None)
        self.search_expression = kwargs.get("search_expression", None)


class ResumeSearchDetailEducation(msrest.serialization.Model):
    """ResumeSearchDetailEducation.

    :ivar missing:
    :vartype missing: ~affinda.models.ResumeSearchDetailEducationMissing
    :ivar value:
    :vartype value: list[~affinda.models.ResumeSearchDetailEducationValueItem]
    """

    _attribute_map = {
        "missing": {"key": "missing", "type": "ResumeSearchDetailEducationMissing"},
        "value": {"key": "value", "type": "[ResumeSearchDetailEducationValueItem]"},
    }

    def __init__(self, **kwargs):
        """
        :keyword missing:
        :paramtype missing: ~affinda.models.ResumeSearchDetailEducationMissing
        :keyword value:
        :paramtype value: list[~affinda.models.ResumeSearchDetailEducationValueItem]
        """
        super(ResumeSearchDetailEducation, self).__init__(**kwargs)
        self.missing = kwargs.get("missing", None)
        self.value = kwargs.get("value", None)


class ResumeSearchDetailEducationMissing(msrest.serialization.Model):
    """ResumeSearchDetailEducationMissing.

    :ivar degrees:
    :vartype degrees: list[str]
    :ivar highest_degree_types:
    :vartype highest_degree_types: list[str]
    :ivar institutions:
    :vartype institutions: list[str]
    :ivar current_student:
    :vartype current_student: bool
    :ivar recent_graduate:
    :vartype recent_graduate: bool
    """

    _attribute_map = {
        "degrees": {"key": "degrees", "type": "[str]"},
        "highest_degree_types": {"key": "highestDegreeTypes", "type": "[str]"},
        "institutions": {"key": "institutions", "type": "[str]"},
        "current_student": {"key": "currentStudent", "type": "bool"},
        "recent_graduate": {"key": "recentGraduate", "type": "bool"},
    }

    def __init__(self, **kwargs):
        """
        :keyword degrees:
        :paramtype degrees: list[str]
        :keyword highest_degree_types:
        :paramtype highest_degree_types: list[str]
        :keyword institutions:
        :paramtype institutions: list[str]
        :keyword current_student:
        :paramtype current_student: bool
        :keyword recent_graduate:
        :paramtype recent_graduate: bool
        """
        super(ResumeSearchDetailEducationMissing, self).__init__(**kwargs)
        self.degrees = kwargs.get("degrees", None)
        self.highest_degree_types = kwargs.get("highest_degree_types", None)
        self.institutions = kwargs.get("institutions", None)
        self.current_student = kwargs.get("current_student", None)
        self.recent_graduate = kwargs.get("recent_graduate", None)


class ResumeSearchDetailEducationValueItem(
    Education,
    ComponentsSxu0N3SchemasResumesearchdetailPropertiesEducationPropertiesValueItemsAllof1,
):
    """ResumeSearchDetailEducationValueItem.

    :ivar match:
    :vartype match: bool
    :ivar id:
    :vartype id: int
    :ivar organization:
    :vartype organization: str
    :ivar accreditation:
    :vartype accreditation: ~affinda.models.Accreditation
    :ivar grade:
    :vartype grade: ~affinda.models.EducationGrade
    :ivar location:
    :vartype location: ~affinda.models.Location
    :ivar dates:
    :vartype dates: ~affinda.models.EducationDates
    """

    _validation = {
        "id": {"minimum": 1},
    }

    _attribute_map = {
        "match": {"key": "match", "type": "bool"},
        "id": {"key": "id", "type": "int"},
        "organization": {"key": "organization", "type": "str"},
        "accreditation": {"key": "accreditation", "type": "Accreditation"},
        "grade": {"key": "grade", "type": "EducationGrade"},
        "location": {"key": "location", "type": "Location"},
        "dates": {"key": "dates", "type": "EducationDates"},
    }

    def __init__(self, **kwargs):
        """
        :keyword match:
        :paramtype match: bool
        :keyword id:
        :paramtype id: int
        :keyword organization:
        :paramtype organization: str
        :keyword accreditation:
        :paramtype accreditation: ~affinda.models.Accreditation
        :keyword grade:
        :paramtype grade: ~affinda.models.EducationGrade
        :keyword location:
        :paramtype location: ~affinda.models.Location
        :keyword dates:
        :paramtype dates: ~affinda.models.EducationDates
        """
        super(ResumeSearchDetailEducationValueItem, self).__init__(**kwargs)
        self.match = kwargs.get("match", None)
        self.id = kwargs.get("id", None)
        self.organization = kwargs.get("organization", None)
        self.accreditation = kwargs.get("accreditation", None)
        self.grade = kwargs.get("grade", None)
        self.location = kwargs.get("location", None)
        self.dates = kwargs.get("dates", None)


class ResumeSearchDetailExperience(msrest.serialization.Model):
    """ResumeSearchDetailExperience.

    :ivar years:
    :vartype years: int
    :ivar match:
    :vartype match: bool
    """

    _validation = {
        "years": {"minimum": 0},
    }

    _attribute_map = {
        "years": {"key": "years", "type": "int"},
        "match": {"key": "match", "type": "bool"},
    }

    def __init__(self, **kwargs):
        """
        :keyword years:
        :paramtype years: int
        :keyword match:
        :paramtype match: bool
        """
        super(ResumeSearchDetailExperience, self).__init__(**kwargs)
        self.years = kwargs.get("years", None)
        self.match = kwargs.get("match", None)


class ResumeSearchDetailJobTitle(msrest.serialization.Model):
    """ResumeSearchDetailJobTitle.

    :ivar missing:
    :vartype missing: list[str]
    :ivar value:
    :vartype value: list[~affinda.models.ResumeSearchDetailJobTitleValueItem]
    """

    _attribute_map = {
        "missing": {"key": "missing", "type": "[str]"},
        "value": {"key": "value", "type": "[ResumeSearchDetailJobTitleValueItem]"},
    }

    def __init__(self, **kwargs):
        """
        :keyword missing:
        :paramtype missing: list[str]
        :keyword value:
        :paramtype value: list[~affinda.models.ResumeSearchDetailJobTitleValueItem]
        """
        super(ResumeSearchDetailJobTitle, self).__init__(**kwargs)
        self.missing = kwargs.get("missing", None)
        self.value = kwargs.get("value", None)


class ResumeSearchDetailJobTitleValueItem(msrest.serialization.Model):
    """ResumeSearchDetailJobTitleValueItem.

    :ivar name:
    :vartype name: str
    :ivar start_date:
    :vartype start_date: str
    :ivar end_date:
    :vartype end_date: str
    :ivar company_name:
    :vartype company_name: str
    :ivar match:
    :vartype match: bool
    """

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "start_date": {"key": "startDate", "type": "str"},
        "end_date": {"key": "endDate", "type": "str"},
        "company_name": {"key": "companyName", "type": "str"},
        "match": {"key": "match", "type": "bool"},
    }

    def __init__(self, **kwargs):
        """
        :keyword name:
        :paramtype name: str
        :keyword start_date:
        :paramtype start_date: str
        :keyword end_date:
        :paramtype end_date: str
        :keyword company_name:
        :paramtype company_name: str
        :keyword match:
        :paramtype match: bool
        """
        super(ResumeSearchDetailJobTitleValueItem, self).__init__(**kwargs)
        self.name = kwargs.get("name", None)
        self.start_date = kwargs.get("start_date", None)
        self.end_date = kwargs.get("end_date", None)
        self.company_name = kwargs.get("company_name", None)
        self.match = kwargs.get("match", None)


class ResumeSearchDetailLanguages(msrest.serialization.Model):
    """ResumeSearchDetailLanguages.

    :ivar missing:
    :vartype missing: list[~affinda.models.ResumeSearchParametersSkill]
    :ivar value:
    :vartype value: list[~affinda.models.ResumeSearchDetailLanguagesValueItem]
    """

    _attribute_map = {
        "missing": {"key": "missing", "type": "[ResumeSearchParametersSkill]"},
        "value": {"key": "value", "type": "[ResumeSearchDetailLanguagesValueItem]"},
    }

    def __init__(self, **kwargs):
        """
        :keyword missing:
        :paramtype missing: list[~affinda.models.ResumeSearchParametersSkill]
        :keyword value:
        :paramtype value: list[~affinda.models.ResumeSearchDetailLanguagesValueItem]
        """
        super(ResumeSearchDetailLanguages, self).__init__(**kwargs)
        self.missing = kwargs.get("missing", None)
        self.value = kwargs.get("value", None)


class ResumeSkill(msrest.serialization.Model):
    """ResumeSkill.

    :ivar name:
    :vartype name: str
    :ivar last_used:
    :vartype last_used: str
    :ivar number_of_months:
    :vartype number_of_months: int
    :ivar type:
    :vartype type: str
    :ivar sources:
    :vartype sources: list[~affinda.models.ResumeSkillSourcesItem]
    """

    _validation = {
        "number_of_months": {"minimum": 0},
    }

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "last_used": {"key": "lastUsed", "type": "str"},
        "number_of_months": {"key": "numberOfMonths", "type": "int"},
        "type": {"key": "type", "type": "str"},
        "sources": {"key": "sources", "type": "[ResumeSkillSourcesItem]"},
    }

    def __init__(self, **kwargs):
        """
        :keyword name:
        :paramtype name: str
        :keyword last_used:
        :paramtype last_used: str
        :keyword number_of_months:
        :paramtype number_of_months: int
        :keyword type:
        :paramtype type: str
        :keyword sources:
        :paramtype sources: list[~affinda.models.ResumeSkillSourcesItem]
        """
        super(ResumeSkill, self).__init__(**kwargs)
        self.name = kwargs.get("name", None)
        self.last_used = kwargs.get("last_used", None)
        self.number_of_months = kwargs.get("number_of_months", None)
        self.type = kwargs.get("type", None)
        self.sources = kwargs.get("sources", None)


class ResumeSearchDetailLanguagesValueItem(
    ResumeSkill,
    Components159Ji55SchemasResumesearchdetailPropertiesLanguagesPropertiesValueItemsAllof1,
):
    """ResumeSearchDetailLanguagesValueItem.

    :ivar match:
    :vartype match: bool
    :ivar name:
    :vartype name: str
    :ivar last_used:
    :vartype last_used: str
    :ivar number_of_months:
    :vartype number_of_months: int
    :ivar type:
    :vartype type: str
    :ivar sources:
    :vartype sources: list[~affinda.models.ResumeSkillSourcesItem]
    """

    _validation = {
        "number_of_months": {"minimum": 0},
    }

    _attribute_map = {
        "match": {"key": "match", "type": "bool"},
        "name": {"key": "name", "type": "str"},
        "last_used": {"key": "lastUsed", "type": "str"},
        "number_of_months": {"key": "numberOfMonths", "type": "int"},
        "type": {"key": "type", "type": "str"},
        "sources": {"key": "sources", "type": "[ResumeSkillSourcesItem]"},
    }

    def __init__(self, **kwargs):
        """
        :keyword match:
        :paramtype match: bool
        :keyword name:
        :paramtype name: str
        :keyword last_used:
        :paramtype last_used: str
        :keyword number_of_months:
        :paramtype number_of_months: int
        :keyword type:
        :paramtype type: str
        :keyword sources:
        :paramtype sources: list[~affinda.models.ResumeSkillSourcesItem]
        """
        super(ResumeSearchDetailLanguagesValueItem, self).__init__(**kwargs)
        self.match = kwargs.get("match", None)
        self.name = kwargs.get("name", None)
        self.last_used = kwargs.get("last_used", None)
        self.number_of_months = kwargs.get("number_of_months", None)
        self.type = kwargs.get("type", None)
        self.sources = kwargs.get("sources", None)


class ResumeSearchDetailLocation(msrest.serialization.Model):
    """ResumeSearchDetailLocation.

    :ivar missing:
    :vartype missing: list[~affinda.models.ResumeSearchParametersLocation]
    :ivar value:
    :vartype value: ~affinda.models.ResumeSearchDetailLocationValue
    """

    _attribute_map = {
        "missing": {"key": "missing", "type": "[ResumeSearchParametersLocation]"},
        "value": {"key": "value", "type": "ResumeSearchDetailLocationValue"},
    }

    def __init__(self, **kwargs):
        """
        :keyword missing:
        :paramtype missing: list[~affinda.models.ResumeSearchParametersLocation]
        :keyword value:
        :paramtype value: ~affinda.models.ResumeSearchDetailLocationValue
        """
        super(ResumeSearchDetailLocation, self).__init__(**kwargs)
        self.missing = kwargs.get("missing", None)
        self.value = kwargs.get("value", None)


class ResumeSearchDetailLocationValue(
    Location, ComponentsN9ShogSchemasResumesearchdetailPropertiesLocationPropertiesValueAllof1
):
    """ResumeSearchDetailLocationValue.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar match:
    :vartype match: bool
    :ivar formatted:
    :vartype formatted: str
    :ivar postal_code:
    :vartype postal_code: str
    :ivar state:
    :vartype state: str
    :ivar state_code:
    :vartype state_code: str
    :ivar country:
    :vartype country: str
    :ivar country_code: Two letter country code (ISO 3166-1 alpha-2).
    :vartype country_code: str
    :ivar raw_input: Required.
    :vartype raw_input: str
    :ivar street_number:
    :vartype street_number: str
    :ivar street:
    :vartype street: str
    :ivar apartment_number:
    :vartype apartment_number: str
    :ivar city:
    :vartype city: str
    :ivar latitude:
    :vartype latitude: float
    :ivar longitude:
    :vartype longitude: float
    :ivar po_box:
    :vartype po_box: str
    """

    _validation = {
        "formatted": {"readonly": True},
        "postal_code": {"readonly": True},
        "state": {"readonly": True},
        "state_code": {"readonly": True},
        "country": {"readonly": True},
        "country_code": {"readonly": True},
        "raw_input": {"required": True},
        "street_number": {"readonly": True},
        "street": {"readonly": True},
        "apartment_number": {"readonly": True},
        "city": {"readonly": True},
        "latitude": {"readonly": True},
        "longitude": {"readonly": True},
        "po_box": {"readonly": True},
    }

    _attribute_map = {
        "match": {"key": "match", "type": "bool"},
        "formatted": {"key": "formatted", "type": "str"},
        "postal_code": {"key": "postalCode", "type": "str"},
        "state": {"key": "state", "type": "str"},
        "state_code": {"key": "stateCode", "type": "str"},
        "country": {"key": "country", "type": "str"},
        "country_code": {"key": "countryCode", "type": "str"},
        "raw_input": {"key": "rawInput", "type": "str"},
        "street_number": {"key": "streetNumber", "type": "str"},
        "street": {"key": "street", "type": "str"},
        "apartment_number": {"key": "apartmentNumber", "type": "str"},
        "city": {"key": "city", "type": "str"},
        "latitude": {"key": "latitude", "type": "float"},
        "longitude": {"key": "longitude", "type": "float"},
        "po_box": {"key": "poBox", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword match:
        :paramtype match: bool
        :keyword raw_input: Required.
        :paramtype raw_input: str
        """
        super(ResumeSearchDetailLocationValue, self).__init__(**kwargs)
        self.match = kwargs.get("match", None)
        self.formatted = None
        self.postal_code = None
        self.state = None
        self.state_code = None
        self.country = None
        self.country_code = None
        self.raw_input = kwargs["raw_input"]
        self.street_number = None
        self.street = None
        self.apartment_number = None
        self.city = None
        self.latitude = None
        self.longitude = None
        self.po_box = None


class ResumeSearchDetailManagementLevel(msrest.serialization.Model):
    """ResumeSearchDetailManagementLevel.

    :ivar level: Known values are: "None", "Low", "Mid", "Upper".
    :vartype level: str or ~affinda.models.ManagementLevel
    :ivar match:
    :vartype match: bool
    """

    _attribute_map = {
        "level": {"key": "level", "type": "str"},
        "match": {"key": "match", "type": "bool"},
    }

    def __init__(self, **kwargs):
        """
        :keyword level: Known values are: "None", "Low", "Mid", "Upper".
        :paramtype level: str or ~affinda.models.ManagementLevel
        :keyword match:
        :paramtype match: bool
        """
        super(ResumeSearchDetailManagementLevel, self).__init__(**kwargs)
        self.level = kwargs.get("level", None)
        self.match = kwargs.get("match", None)


class ResumeSearchDetailOccupationGroup(msrest.serialization.Model):
    """ResumeSearchDetailOccupationGroup.

    :ivar missing:
    :vartype missing: list[int]
    :ivar value:
    :vartype value: list[~affinda.models.OccupationGroupSearchResult]
    """

    _attribute_map = {
        "missing": {"key": "missing", "type": "[int]"},
        "value": {"key": "value", "type": "[OccupationGroupSearchResult]"},
    }

    def __init__(self, **kwargs):
        """
        :keyword missing:
        :paramtype missing: list[int]
        :keyword value:
        :paramtype value: list[~affinda.models.OccupationGroupSearchResult]
        """
        super(ResumeSearchDetailOccupationGroup, self).__init__(**kwargs)
        self.missing = kwargs.get("missing", None)
        self.value = kwargs.get("value", None)


class ResumeSearchDetailSearchExpression(msrest.serialization.Model):
    """ResumeSearchDetailSearchExpression.

    :ivar missing:
    :vartype missing: list[str]
    :ivar value:
    :vartype value: list[str]
    """

    _attribute_map = {
        "missing": {"key": "missing", "type": "[str]"},
        "value": {"key": "value", "type": "[str]"},
    }

    def __init__(self, **kwargs):
        """
        :keyword missing:
        :paramtype missing: list[str]
        :keyword value:
        :paramtype value: list[str]
        """
        super(ResumeSearchDetailSearchExpression, self).__init__(**kwargs)
        self.missing = kwargs.get("missing", None)
        self.value = kwargs.get("value", None)


class ResumeSearchDetailSkills(msrest.serialization.Model):
    """ResumeSearchDetailSkills.

    :ivar missing:
    :vartype missing: list[~affinda.models.ResumeSearchParametersSkill]
    :ivar value:
    :vartype value: list[~affinda.models.ResumeSearchDetailSkillsValueItem]
    """

    _attribute_map = {
        "missing": {"key": "missing", "type": "[ResumeSearchParametersSkill]"},
        "value": {"key": "value", "type": "[ResumeSearchDetailSkillsValueItem]"},
    }

    def __init__(self, **kwargs):
        """
        :keyword missing:
        :paramtype missing: list[~affinda.models.ResumeSearchParametersSkill]
        :keyword value:
        :paramtype value: list[~affinda.models.ResumeSearchDetailSkillsValueItem]
        """
        super(ResumeSearchDetailSkills, self).__init__(**kwargs)
        self.missing = kwargs.get("missing", None)
        self.value = kwargs.get("value", None)


class ResumeSearchDetailSkillsValueItem(
    ResumeSkill,
    ComponentsH65QjbSchemasResumesearchdetailPropertiesSkillsPropertiesValueItemsAllof1,
):
    """ResumeSearchDetailSkillsValueItem.

    :ivar match:
    :vartype match: bool
    :ivar name:
    :vartype name: str
    :ivar last_used:
    :vartype last_used: str
    :ivar number_of_months:
    :vartype number_of_months: int
    :ivar type:
    :vartype type: str
    :ivar sources:
    :vartype sources: list[~affinda.models.ResumeSkillSourcesItem]
    """

    _validation = {
        "number_of_months": {"minimum": 0},
    }

    _attribute_map = {
        "match": {"key": "match", "type": "bool"},
        "name": {"key": "name", "type": "str"},
        "last_used": {"key": "lastUsed", "type": "str"},
        "number_of_months": {"key": "numberOfMonths", "type": "int"},
        "type": {"key": "type", "type": "str"},
        "sources": {"key": "sources", "type": "[ResumeSkillSourcesItem]"},
    }

    def __init__(self, **kwargs):
        """
        :keyword match:
        :paramtype match: bool
        :keyword name:
        :paramtype name: str
        :keyword last_used:
        :paramtype last_used: str
        :keyword number_of_months:
        :paramtype number_of_months: int
        :keyword type:
        :paramtype type: str
        :keyword sources:
        :paramtype sources: list[~affinda.models.ResumeSkillSourcesItem]
        """
        super(ResumeSearchDetailSkillsValueItem, self).__init__(**kwargs)
        self.match = kwargs.get("match", None)
        self.name = kwargs.get("name", None)
        self.last_used = kwargs.get("last_used", None)
        self.number_of_months = kwargs.get("number_of_months", None)
        self.type = kwargs.get("type", None)
        self.sources = kwargs.get("sources", None)


class ResumeSearchEmbed(msrest.serialization.Model):
    """ResumeSearchEmbed.

    :ivar url: The signed URL for the embedable search tool.
    :vartype url: str
    """

    _attribute_map = {
        "url": {"key": "url", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword url: The signed URL for the embedable search tool.
        :paramtype url: str
        """
        super(ResumeSearchEmbed, self).__init__(**kwargs)
        self.url = kwargs.get("url", None)


class ResumeSearchMatch(msrest.serialization.Model):
    """ResumeSearchMatch.

    :ivar score: The matching score between the provided resume and job description.
    :vartype score: float
    :ivar details:
    :vartype details: ~affinda.models.ResumeSearchMatchDetails
    """

    _validation = {
        "score": {"maximum": 1, "minimum": 0},
    }

    _attribute_map = {
        "score": {"key": "score", "type": "float"},
        "details": {"key": "details", "type": "ResumeSearchMatchDetails"},
    }

    def __init__(self, **kwargs):
        """
        :keyword score: The matching score between the provided resume and job description.
        :paramtype score: float
        :keyword details:
        :paramtype details: ~affinda.models.ResumeSearchMatchDetails
        """
        super(ResumeSearchMatch, self).__init__(**kwargs)
        self.score = kwargs.get("score", None)
        self.details = kwargs.get("details", None)


class ResumeSearchMatchDetails(msrest.serialization.Model):
    """ResumeSearchMatchDetails.

    :ivar job_title:
    :vartype job_title: ~affinda.models.JobTitleSearchScoreComponent
    :ivar management_level:
    :vartype management_level: ~affinda.models.ManagementLevelSearchScoreComponent
    :ivar experience:
    :vartype experience: ~affinda.models.ExperienceSearchScoreComponent
    :ivar skills:
    :vartype skills: ~affinda.models.SkillsSearchScoreComponent
    :ivar languages:
    :vartype languages: ~affinda.models.LanguagesSearchScoreComponent
    :ivar location:
    :vartype location: ~affinda.models.LocationSearchScoreComponent
    :ivar education:
    :vartype education: ~affinda.models.EducationSearchScoreComponent
    :ivar occupation_group:
    :vartype occupation_group: ~affinda.models.OccupationGroupSearchScoreComponent
    :ivar search_expression:
    :vartype search_expression: ~affinda.models.SearchExpressionSearchScoreComponent
    """

    _attribute_map = {
        "job_title": {"key": "jobTitle", "type": "JobTitleSearchScoreComponent"},
        "management_level": {
            "key": "managementLevel",
            "type": "ManagementLevelSearchScoreComponent",
        },
        "experience": {"key": "experience", "type": "ExperienceSearchScoreComponent"},
        "skills": {"key": "skills", "type": "SkillsSearchScoreComponent"},
        "languages": {"key": "languages", "type": "LanguagesSearchScoreComponent"},
        "location": {"key": "location", "type": "LocationSearchScoreComponent"},
        "education": {"key": "education", "type": "EducationSearchScoreComponent"},
        "occupation_group": {
            "key": "occupationGroup",
            "type": "OccupationGroupSearchScoreComponent",
        },
        "search_expression": {
            "key": "searchExpression",
            "type": "SearchExpressionSearchScoreComponent",
        },
    }

    def __init__(self, **kwargs):
        """
        :keyword job_title:
        :paramtype job_title: ~affinda.models.JobTitleSearchScoreComponent
        :keyword management_level:
        :paramtype management_level: ~affinda.models.ManagementLevelSearchScoreComponent
        :keyword experience:
        :paramtype experience: ~affinda.models.ExperienceSearchScoreComponent
        :keyword skills:
        :paramtype skills: ~affinda.models.SkillsSearchScoreComponent
        :keyword languages:
        :paramtype languages: ~affinda.models.LanguagesSearchScoreComponent
        :keyword location:
        :paramtype location: ~affinda.models.LocationSearchScoreComponent
        :keyword education:
        :paramtype education: ~affinda.models.EducationSearchScoreComponent
        :keyword occupation_group:
        :paramtype occupation_group: ~affinda.models.OccupationGroupSearchScoreComponent
        :keyword search_expression:
        :paramtype search_expression: ~affinda.models.SearchExpressionSearchScoreComponent
        """
        super(ResumeSearchMatchDetails, self).__init__(**kwargs)
        self.job_title = kwargs.get("job_title", None)
        self.management_level = kwargs.get("management_level", None)
        self.experience = kwargs.get("experience", None)
        self.skills = kwargs.get("skills", None)
        self.languages = kwargs.get("languages", None)
        self.location = kwargs.get("location", None)
        self.education = kwargs.get("education", None)
        self.occupation_group = kwargs.get("occupation_group", None)
        self.search_expression = kwargs.get("search_expression", None)


class ResumeSearchParameters(msrest.serialization.Model):
    """ResumeSearchParameters.

    All required parameters must be populated in order to send to Azure.

    :ivar indices: Required.
    :vartype indices: list[str]
    :ivar job_description: A random string that uniquely identify the resource.
    :vartype job_description: str
    :ivar resume: A random string that uniquely identify the resource.
    :vartype resume: str
    :ivar job_titles:
    :vartype job_titles: list[str]
    :ivar job_titles_current_only: Search only through the canditate's current job.
    :vartype job_titles_current_only: bool
    :ivar job_titles_required:
    :vartype job_titles_required: bool
    :ivar job_titles_weight:
    :vartype job_titles_weight: float
    :ivar years_experience_min: Minimum years of total work experience.
    :vartype years_experience_min: int
    :ivar years_experience_max: Maximum years of total work experience.
    :vartype years_experience_max: int
    :ivar years_experience_required:
    :vartype years_experience_required: bool
    :ivar years_experience_weight:
    :vartype years_experience_weight: float
    :ivar locations: Search by location name or by coordinates.
    :vartype locations: list[~affinda.models.ResumeSearchParametersLocation]
    :ivar locations_weight:
    :vartype locations_weight: float
    :ivar locations_required:
    :vartype locations_required: bool
    :ivar skills:
    :vartype skills: list[~affinda.models.ResumeSearchParametersSkill]
    :ivar skills_weight:
    :vartype skills_weight: float
    :ivar languages:
    :vartype languages: list[~affinda.models.ResumeSearchParametersSkill]
    :ivar languages_weight:
    :vartype languages_weight: float
    :ivar institutions:
    :vartype institutions: list[str]
    :ivar institutions_required:
    :vartype institutions_required: bool
    :ivar degrees:
    :vartype degrees: list[str]
    :ivar degrees_required:
    :vartype degrees_required: bool
    :ivar highest_degree_types:
    :vartype highest_degree_types: list[str or ~affinda.models.EducationLevel]
    :ivar highest_degree_types_required:
    :vartype highest_degree_types_required: bool
    :ivar is_current_student: Search for student canditates.
    :vartype is_current_student: bool
    :ivar is_current_student_required:
    :vartype is_current_student_required: bool
    :ivar is_recent_graduate: Search for canditates that graduated less than a year ago.
    :vartype is_recent_graduate: bool
    :ivar is_recent_graduate_required:
    :vartype is_recent_graduate_required: bool
    :ivar education_weight:
    :vartype education_weight: float
    :ivar search_expression: Search through resumes' raw text.
    :vartype search_expression: str
    :ivar search_expression_required:
    :vartype search_expression_required: bool
    :ivar search_expression_weight:
    :vartype search_expression_weight: float
    :ivar soc_codes:
    :vartype soc_codes: list[int]
    :ivar soc_codes_weight:
    :vartype soc_codes_weight: float
    :ivar soc_codes_required:
    :vartype soc_codes_required: bool
    :ivar management_level: Known values are: "None", "Low", "Mid", "Upper".
    :vartype management_level: str or ~affinda.models.ManagementLevel
    :ivar management_level_required:
    :vartype management_level_required: bool
    :ivar management_level_weight:
    :vartype management_level_weight: float
    :ivar custom_data:
    :vartype custom_data: list[~affinda.models.ResumeSearchParametersCustomData]
    """

    _validation = {
        "indices": {"required": True},
        "job_titles_weight": {"maximum": 1, "minimum": 0},
        "years_experience_min": {"minimum": 0},
        "years_experience_max": {"minimum": 0},
        "years_experience_weight": {"maximum": 1, "minimum": 0},
        "locations_weight": {"maximum": 1, "minimum": 0},
        "skills_weight": {"maximum": 1, "minimum": 0},
        "languages_weight": {"maximum": 1, "minimum": 0},
        "highest_degree_types": {"unique": True},
        "education_weight": {"maximum": 1, "minimum": 0},
        "search_expression_weight": {"maximum": 1, "minimum": 0},
        "soc_codes_weight": {"maximum": 1, "minimum": 0},
        "management_level_weight": {"maximum": 1, "minimum": 0},
    }

    _attribute_map = {
        "indices": {"key": "indices", "type": "[str]"},
        "job_description": {"key": "jobDescription", "type": "str"},
        "resume": {"key": "resume", "type": "str"},
        "job_titles": {"key": "jobTitles", "type": "[str]"},
        "job_titles_current_only": {"key": "jobTitlesCurrentOnly", "type": "bool"},
        "job_titles_required": {"key": "jobTitlesRequired", "type": "bool"},
        "job_titles_weight": {"key": "jobTitlesWeight", "type": "float"},
        "years_experience_min": {"key": "yearsExperienceMin", "type": "int"},
        "years_experience_max": {"key": "yearsExperienceMax", "type": "int"},
        "years_experience_required": {"key": "yearsExperienceRequired", "type": "bool"},
        "years_experience_weight": {"key": "yearsExperienceWeight", "type": "float"},
        "locations": {"key": "locations", "type": "[ResumeSearchParametersLocation]"},
        "locations_weight": {"key": "locationsWeight", "type": "float"},
        "locations_required": {"key": "locationsRequired", "type": "bool"},
        "skills": {"key": "skills", "type": "[ResumeSearchParametersSkill]"},
        "skills_weight": {"key": "skillsWeight", "type": "float"},
        "languages": {"key": "languages", "type": "[ResumeSearchParametersSkill]"},
        "languages_weight": {"key": "languagesWeight", "type": "float"},
        "institutions": {"key": "institutions", "type": "[str]"},
        "institutions_required": {"key": "institutionsRequired", "type": "bool"},
        "degrees": {"key": "degrees", "type": "[str]"},
        "degrees_required": {"key": "degreesRequired", "type": "bool"},
        "highest_degree_types": {"key": "highestDegreeTypes", "type": "[str]"},
        "highest_degree_types_required": {"key": "highestDegreeTypesRequired", "type": "bool"},
        "is_current_student": {"key": "isCurrentStudent", "type": "bool"},
        "is_current_student_required": {"key": "isCurrentStudentRequired", "type": "bool"},
        "is_recent_graduate": {"key": "isRecentGraduate", "type": "bool"},
        "is_recent_graduate_required": {"key": "isRecentGraduateRequired", "type": "bool"},
        "education_weight": {"key": "educationWeight", "type": "float"},
        "search_expression": {"key": "searchExpression", "type": "str"},
        "search_expression_required": {"key": "searchExpressionRequired", "type": "bool"},
        "search_expression_weight": {"key": "searchExpressionWeight", "type": "float"},
        "soc_codes": {"key": "socCodes", "type": "[int]"},
        "soc_codes_weight": {"key": "socCodesWeight", "type": "float"},
        "soc_codes_required": {"key": "socCodesRequired", "type": "bool"},
        "management_level": {"key": "managementLevel", "type": "str"},
        "management_level_required": {"key": "managementLevelRequired", "type": "bool"},
        "management_level_weight": {"key": "managementLevelWeight", "type": "float"},
        "custom_data": {"key": "customData", "type": "[ResumeSearchParametersCustomData]"},
    }

    def __init__(self, **kwargs):
        """
        :keyword indices: Required.
        :paramtype indices: list[str]
        :keyword job_description: A random string that uniquely identify the resource.
        :paramtype job_description: str
        :keyword resume: A random string that uniquely identify the resource.
        :paramtype resume: str
        :keyword job_titles:
        :paramtype job_titles: list[str]
        :keyword job_titles_current_only: Search only through the canditate's current job.
        :paramtype job_titles_current_only: bool
        :keyword job_titles_required:
        :paramtype job_titles_required: bool
        :keyword job_titles_weight:
        :paramtype job_titles_weight: float
        :keyword years_experience_min: Minimum years of total work experience.
        :paramtype years_experience_min: int
        :keyword years_experience_max: Maximum years of total work experience.
        :paramtype years_experience_max: int
        :keyword years_experience_required:
        :paramtype years_experience_required: bool
        :keyword years_experience_weight:
        :paramtype years_experience_weight: float
        :keyword locations: Search by location name or by coordinates.
        :paramtype locations: list[~affinda.models.ResumeSearchParametersLocation]
        :keyword locations_weight:
        :paramtype locations_weight: float
        :keyword locations_required:
        :paramtype locations_required: bool
        :keyword skills:
        :paramtype skills: list[~affinda.models.ResumeSearchParametersSkill]
        :keyword skills_weight:
        :paramtype skills_weight: float
        :keyword languages:
        :paramtype languages: list[~affinda.models.ResumeSearchParametersSkill]
        :keyword languages_weight:
        :paramtype languages_weight: float
        :keyword institutions:
        :paramtype institutions: list[str]
        :keyword institutions_required:
        :paramtype institutions_required: bool
        :keyword degrees:
        :paramtype degrees: list[str]
        :keyword degrees_required:
        :paramtype degrees_required: bool
        :keyword highest_degree_types:
        :paramtype highest_degree_types: list[str or ~affinda.models.EducationLevel]
        :keyword highest_degree_types_required:
        :paramtype highest_degree_types_required: bool
        :keyword is_current_student: Search for student canditates.
        :paramtype is_current_student: bool
        :keyword is_current_student_required:
        :paramtype is_current_student_required: bool
        :keyword is_recent_graduate: Search for canditates that graduated less than a year ago.
        :paramtype is_recent_graduate: bool
        :keyword is_recent_graduate_required:
        :paramtype is_recent_graduate_required: bool
        :keyword education_weight:
        :paramtype education_weight: float
        :keyword search_expression: Search through resumes' raw text.
        :paramtype search_expression: str
        :keyword search_expression_required:
        :paramtype search_expression_required: bool
        :keyword search_expression_weight:
        :paramtype search_expression_weight: float
        :keyword soc_codes:
        :paramtype soc_codes: list[int]
        :keyword soc_codes_weight:
        :paramtype soc_codes_weight: float
        :keyword soc_codes_required:
        :paramtype soc_codes_required: bool
        :keyword management_level: Known values are: "None", "Low", "Mid", "Upper".
        :paramtype management_level: str or ~affinda.models.ManagementLevel
        :keyword management_level_required:
        :paramtype management_level_required: bool
        :keyword management_level_weight:
        :paramtype management_level_weight: float
        :keyword custom_data:
        :paramtype custom_data: list[~affinda.models.ResumeSearchParametersCustomData]
        """
        super(ResumeSearchParameters, self).__init__(**kwargs)
        self.indices = kwargs["indices"]
        self.job_description = kwargs.get("job_description", None)
        self.resume = kwargs.get("resume", None)
        self.job_titles = kwargs.get("job_titles", None)
        self.job_titles_current_only = kwargs.get("job_titles_current_only", None)
        self.job_titles_required = kwargs.get("job_titles_required", None)
        self.job_titles_weight = kwargs.get("job_titles_weight", None)
        self.years_experience_min = kwargs.get("years_experience_min", None)
        self.years_experience_max = kwargs.get("years_experience_max", None)
        self.years_experience_required = kwargs.get("years_experience_required", None)
        self.years_experience_weight = kwargs.get("years_experience_weight", None)
        self.locations = kwargs.get("locations", None)
        self.locations_weight = kwargs.get("locations_weight", None)
        self.locations_required = kwargs.get("locations_required", None)
        self.skills = kwargs.get("skills", None)
        self.skills_weight = kwargs.get("skills_weight", None)
        self.languages = kwargs.get("languages", None)
        self.languages_weight = kwargs.get("languages_weight", None)
        self.institutions = kwargs.get("institutions", None)
        self.institutions_required = kwargs.get("institutions_required", None)
        self.degrees = kwargs.get("degrees", None)
        self.degrees_required = kwargs.get("degrees_required", None)
        self.highest_degree_types = kwargs.get("highest_degree_types", None)
        self.highest_degree_types_required = kwargs.get("highest_degree_types_required", None)
        self.is_current_student = kwargs.get("is_current_student", None)
        self.is_current_student_required = kwargs.get("is_current_student_required", None)
        self.is_recent_graduate = kwargs.get("is_recent_graduate", None)
        self.is_recent_graduate_required = kwargs.get("is_recent_graduate_required", None)
        self.education_weight = kwargs.get("education_weight", None)
        self.search_expression = kwargs.get("search_expression", None)
        self.search_expression_required = kwargs.get("search_expression_required", None)
        self.search_expression_weight = kwargs.get("search_expression_weight", None)
        self.soc_codes = kwargs.get("soc_codes", None)
        self.soc_codes_weight = kwargs.get("soc_codes_weight", None)
        self.soc_codes_required = kwargs.get("soc_codes_required", None)
        self.management_level = kwargs.get("management_level", None)
        self.management_level_required = kwargs.get("management_level_required", None)
        self.management_level_weight = kwargs.get("management_level_weight", None)
        self.custom_data = kwargs.get("custom_data", None)


class SearchParametersCustomData(msrest.serialization.Model):
    """SearchParametersCustomData.

    All required parameters must be populated in order to send to Azure.

    :ivar filter_type: Required. Data points of "text" type support only "equals" filterType,
     others support both "equals" and "range". Known values are: "equals", "range".
    :vartype filter_type: str or ~affinda.models.SearchParametersCustomDataFilterType
    :ivar data_point: Required. The data point's slug.
    :vartype data_point: str
    :ivar query: Required. "equals" searches require the "value" key inside the query, and "range"
     searches require at least one of "gte" (greater than or equal) and "lte" (less than or equal).
    :vartype query: any
    :ivar required:
    :vartype required: bool
    :ivar weight:
    :vartype weight: float
    """

    _validation = {
        "filter_type": {"required": True},
        "data_point": {"required": True},
        "query": {"required": True},
        "weight": {"maximum": 1, "minimum": 0},
    }

    _attribute_map = {
        "filter_type": {"key": "filterType", "type": "str"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "query": {"key": "query", "type": "object"},
        "required": {"key": "required", "type": "bool"},
        "weight": {"key": "weight", "type": "float"},
    }

    def __init__(self, **kwargs):
        """
        :keyword filter_type: Required. Data points of "text" type support only "equals" filterType,
         others support both "equals" and "range". Known values are: "equals", "range".
        :paramtype filter_type: str or ~affinda.models.SearchParametersCustomDataFilterType
        :keyword data_point: Required. The data point's slug.
        :paramtype data_point: str
        :keyword query: Required. "equals" searches require the "value" key inside the query, and
         "range" searches require at least one of "gte" (greater than or equal) and "lte" (less than or
         equal).
        :paramtype query: any
        :keyword required:
        :paramtype required: bool
        :keyword weight:
        :paramtype weight: float
        """
        super(SearchParametersCustomData, self).__init__(**kwargs)
        self.filter_type = kwargs["filter_type"]
        self.data_point = kwargs["data_point"]
        self.query = kwargs["query"]
        self.required = kwargs.get("required", None)
        self.weight = kwargs.get("weight", None)


class ResumeSearchParametersCustomData(SearchParametersCustomData):
    """ResumeSearchParametersCustomData.

    All required parameters must be populated in order to send to Azure.

    :ivar filter_type: Required. Data points of "text" type support only "equals" filterType,
     others support both "equals" and "range". Known values are: "equals", "range".
    :vartype filter_type: str or ~affinda.models.SearchParametersCustomDataFilterType
    :ivar data_point: Required. The data point's slug.
    :vartype data_point: str
    :ivar query: Required. "equals" searches require the "value" key inside the query, and "range"
     searches require at least one of "gte" (greater than or equal) and "lte" (less than or equal).
    :vartype query: any
    :ivar required:
    :vartype required: bool
    :ivar weight:
    :vartype weight: float
    """

    _validation = {
        "filter_type": {"required": True},
        "data_point": {"required": True},
        "query": {"required": True},
        "weight": {"maximum": 1, "minimum": 0},
    }

    _attribute_map = {
        "filter_type": {"key": "filterType", "type": "str"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "query": {"key": "query", "type": "object"},
        "required": {"key": "required", "type": "bool"},
        "weight": {"key": "weight", "type": "float"},
    }

    def __init__(self, **kwargs):
        """
        :keyword filter_type: Required. Data points of "text" type support only "equals" filterType,
         others support both "equals" and "range". Known values are: "equals", "range".
        :paramtype filter_type: str or ~affinda.models.SearchParametersCustomDataFilterType
        :keyword data_point: Required. The data point's slug.
        :paramtype data_point: str
        :keyword query: Required. "equals" searches require the "value" key inside the query, and
         "range" searches require at least one of "gte" (greater than or equal) and "lte" (less than or
         equal).
        :paramtype query: any
        :keyword required:
        :paramtype required: bool
        :keyword weight:
        :paramtype weight: float
        """
        super(ResumeSearchParametersCustomData, self).__init__(**kwargs)


class ResumeSearchParametersLocation(msrest.serialization.Model):
    """ResumeSearchParametersLocation.

    :ivar name:
    :vartype name: str
    :ivar coordinates:
    :vartype coordinates: ~affinda.models.ResumeSearchParametersLocationCoordinates
    :ivar distance:
    :vartype distance: int
    :ivar unit: Known values are: "km", "mi". Default value: "km".
    :vartype unit: str or ~affinda.models.SearchLocationUnit
    """

    _validation = {
        "distance": {"minimum": 1},
    }

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "coordinates": {"key": "coordinates", "type": "ResumeSearchParametersLocationCoordinates"},
        "distance": {"key": "distance", "type": "int"},
        "unit": {"key": "unit", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword name:
        :paramtype name: str
        :keyword coordinates:
        :paramtype coordinates: ~affinda.models.ResumeSearchParametersLocationCoordinates
        :keyword distance:
        :paramtype distance: int
        :keyword unit: Known values are: "km", "mi". Default value: "km".
        :paramtype unit: str or ~affinda.models.SearchLocationUnit
        """
        super(ResumeSearchParametersLocation, self).__init__(**kwargs)
        self.name = kwargs.get("name", "")
        self.coordinates = kwargs.get("coordinates", None)
        self.distance = kwargs.get("distance", 100)
        self.unit = kwargs.get("unit", "km")


class ResumeSearchParametersLocationCoordinates(msrest.serialization.Model):
    """ResumeSearchParametersLocationCoordinates.

    :ivar latitude:
    :vartype latitude: float
    :ivar longitude:
    :vartype longitude: float
    """

    _attribute_map = {
        "latitude": {"key": "latitude", "type": "float"},
        "longitude": {"key": "longitude", "type": "float"},
    }

    def __init__(self, **kwargs):
        """
        :keyword latitude:
        :paramtype latitude: float
        :keyword longitude:
        :paramtype longitude: float
        """
        super(ResumeSearchParametersLocationCoordinates, self).__init__(**kwargs)
        self.latitude = kwargs.get("latitude", None)
        self.longitude = kwargs.get("longitude", None)


class ResumeSearchParametersSkill(msrest.serialization.Model):
    """ResumeSearchParametersSkill.

    :ivar name:
    :vartype name: str
    :ivar required:
    :vartype required: bool
    """

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "required": {"key": "required", "type": "bool"},
    }

    def __init__(self, **kwargs):
        """
        :keyword name:
        :paramtype name: str
        :keyword required:
        :paramtype required: bool
        """
        super(ResumeSearchParametersSkill, self).__init__(**kwargs)
        self.name = kwargs.get("name", None)
        self.required = kwargs.get("required", None)


class ResumeSearchResult(msrest.serialization.Model):
    """ResumeSearchResult.

    All required parameters must be populated in order to send to Azure.

    :ivar identifier: Required. A random string that uniquely identify the resource.
    :vartype identifier: str
    :ivar score: Required.
    :vartype score: float
    :ivar pdf: Required.
    :vartype pdf: str
    :ivar name:
    :vartype name: str
    :ivar job_title: Required.
    :vartype job_title: ~affinda.models.JobTitleSearchScoreComponent
    :ivar management_level: Required.
    :vartype management_level: ~affinda.models.ManagementLevelSearchScoreComponent
    :ivar experience: Required.
    :vartype experience: ~affinda.models.ExperienceSearchScoreComponent
    :ivar skills: Required.
    :vartype skills: ~affinda.models.SkillsSearchScoreComponent
    :ivar languages: Required.
    :vartype languages: ~affinda.models.LanguagesSearchScoreComponent
    :ivar location: Required.
    :vartype location: ~affinda.models.LocationSearchScoreComponent
    :ivar education: Required.
    :vartype education: ~affinda.models.EducationSearchScoreComponent
    :ivar occupation_group: Required.
    :vartype occupation_group: ~affinda.models.OccupationGroupSearchScoreComponent
    :ivar search_expression: Required.
    :vartype search_expression: ~affinda.models.SearchExpressionSearchScoreComponent
    :ivar custom_data: Required. Dictionary of
     <componentsnqbw24schemascustomdatasearchscorecomponentadditionalproperties>.
    :vartype custom_data: dict[str,
     ~affinda.models.ComponentsNqbw24SchemasCustomdatasearchscorecomponentAdditionalproperties]
    """

    _validation = {
        "identifier": {"required": True},
        "score": {"required": True},
        "pdf": {"required": True},
        "job_title": {"required": True},
        "management_level": {"required": True},
        "experience": {"required": True},
        "skills": {"required": True},
        "languages": {"required": True},
        "location": {"required": True},
        "education": {"required": True},
        "occupation_group": {"required": True},
        "search_expression": {"required": True},
        "custom_data": {"required": True},
    }

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
        "score": {"key": "score", "type": "float"},
        "pdf": {"key": "pdf", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "job_title": {"key": "jobTitle", "type": "JobTitleSearchScoreComponent"},
        "management_level": {
            "key": "managementLevel",
            "type": "ManagementLevelSearchScoreComponent",
        },
        "experience": {"key": "experience", "type": "ExperienceSearchScoreComponent"},
        "skills": {"key": "skills", "type": "SkillsSearchScoreComponent"},
        "languages": {"key": "languages", "type": "LanguagesSearchScoreComponent"},
        "location": {"key": "location", "type": "LocationSearchScoreComponent"},
        "education": {"key": "education", "type": "EducationSearchScoreComponent"},
        "occupation_group": {
            "key": "occupationGroup",
            "type": "OccupationGroupSearchScoreComponent",
        },
        "search_expression": {
            "key": "searchExpression",
            "type": "SearchExpressionSearchScoreComponent",
        },
        "custom_data": {
            "key": "customData",
            "type": "{ComponentsNqbw24SchemasCustomdatasearchscorecomponentAdditionalproperties}",
        },
    }

    def __init__(self, **kwargs):
        """
        :keyword identifier: Required. A random string that uniquely identify the resource.
        :paramtype identifier: str
        :keyword score: Required.
        :paramtype score: float
        :keyword pdf: Required.
        :paramtype pdf: str
        :keyword name:
        :paramtype name: str
        :keyword job_title: Required.
        :paramtype job_title: ~affinda.models.JobTitleSearchScoreComponent
        :keyword management_level: Required.
        :paramtype management_level: ~affinda.models.ManagementLevelSearchScoreComponent
        :keyword experience: Required.
        :paramtype experience: ~affinda.models.ExperienceSearchScoreComponent
        :keyword skills: Required.
        :paramtype skills: ~affinda.models.SkillsSearchScoreComponent
        :keyword languages: Required.
        :paramtype languages: ~affinda.models.LanguagesSearchScoreComponent
        :keyword location: Required.
        :paramtype location: ~affinda.models.LocationSearchScoreComponent
        :keyword education: Required.
        :paramtype education: ~affinda.models.EducationSearchScoreComponent
        :keyword occupation_group: Required.
        :paramtype occupation_group: ~affinda.models.OccupationGroupSearchScoreComponent
        :keyword search_expression: Required.
        :paramtype search_expression: ~affinda.models.SearchExpressionSearchScoreComponent
        :keyword custom_data: Required. Dictionary of
         <componentsnqbw24schemascustomdatasearchscorecomponentadditionalproperties>.
        :paramtype custom_data: dict[str,
         ~affinda.models.ComponentsNqbw24SchemasCustomdatasearchscorecomponentAdditionalproperties]
        """
        super(ResumeSearchResult, self).__init__(**kwargs)
        self.identifier = kwargs["identifier"]
        self.score = kwargs["score"]
        self.pdf = kwargs["pdf"]
        self.name = kwargs.get("name", None)
        self.job_title = kwargs["job_title"]
        self.management_level = kwargs["management_level"]
        self.experience = kwargs["experience"]
        self.skills = kwargs["skills"]
        self.languages = kwargs["languages"]
        self.location = kwargs["location"]
        self.education = kwargs["education"]
        self.occupation_group = kwargs["occupation_group"]
        self.search_expression = kwargs["search_expression"]
        self.custom_data = kwargs["custom_data"]


class ResumeSkillSourcesItem(msrest.serialization.Model):
    """ResumeSkillSourcesItem.

    :ivar section: Known values are: "Achievements", "AdditionalInformation", "Education",
     "Extracurriculars", "Organisations", "Other", "PersonalDetails", "Projects", "Publications",
     "Referees", "Skills", "Summary", "Training", "WorkExperience", "NotPopulated", "Header",
     "Footer", "Skills/Interests/Languages", "Training/Certifications",
     "Extracurriculars/Leadership".
    :vartype section: str or ~affinda.models.ResumeSkillSourcesItemSection
    :ivar position:
    :vartype position: int
    """

    _validation = {
        "position": {"minimum": 0},
    }

    _attribute_map = {
        "section": {"key": "section", "type": "str"},
        "position": {"key": "position", "type": "int"},
    }

    def __init__(self, **kwargs):
        """
        :keyword section: Known values are: "Achievements", "AdditionalInformation", "Education",
         "Extracurriculars", "Organisations", "Other", "PersonalDetails", "Projects", "Publications",
         "Referees", "Skills", "Summary", "Training", "WorkExperience", "NotPopulated", "Header",
         "Footer", "Skills/Interests/Languages", "Training/Certifications",
         "Extracurriculars/Leadership".
        :paramtype section: str or ~affinda.models.ResumeSkillSourcesItemSection
        :keyword position:
        :paramtype position: int
        """
        super(ResumeSkillSourcesItem, self).__init__(**kwargs)
        self.section = kwargs.get("section", None)
        self.position = kwargs.get("position", None)


class RowAnnotation(Annotation):
    """RowAnnotation.

    All required parameters must be populated in order to send to Azure.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id: Required. Annotation's ID.
    :vartype id: int
    :ivar rectangle: Required. x/y coordinates for the rectangular bounding box containing the
     data.
    :vartype rectangle: ~affinda.models.Rectangle
    :ivar rectangles: Required. x/y coordinates for the rectangles containing the data. An
     annotation can be contained within multiple rectangles.
    :vartype rectangles: list[~affinda.models.Rectangle]
    :ivar document: Required. Unique identifier for the document.
    :vartype document: str
    :ivar page_index: Required. The page number within the document, starting from 0.
    :vartype page_index: int
    :ivar raw: Required. Raw data extracted from the before any post-processing.
    :vartype raw: str
    :ivar confidence: Required. The overall confidence that the model's prediction is correct.
    :vartype confidence: float
    :ivar classification_confidence: Required. The model's confidence that the text has been
     classified correctly.
    :vartype classification_confidence: float
    :ivar text_extraction_confidence: Required. If the document was submitted as an image, this is
     the confidence that the text in the image has been correctly read by the model.
    :vartype text_extraction_confidence: float
    :ivar is_verified: Required. Indicates whether the data has been validated, either by a human
     using our validation tool or through auto-validation rules.
    :vartype is_verified: bool
    :ivar is_client_verified: Required. Indicates whether the data has been validated by a human.
    :vartype is_client_verified: bool
    :ivar is_auto_verified: Required. Indicates whether the data has been auto-validated.
    :vartype is_auto_verified: bool
    :ivar data_point: Required. Data point's identifier.
    :vartype data_point: str
    :ivar content_type: Required. The different data types of annotations. Known values are:
     "text", "integer", "float", "decimal", "date", "datetime", "daterange", "boolean", "enum",
     "location", "phonenumber", "json", "table", "expectedremuneration", "jobtitle", "language",
     "skill", "yearsexperience", "group", "table_deprecated", "url", "image".
    :vartype content_type: str or ~affinda.models.AnnotationContentType
    :ivar parent: The parent annotation's ID.
    :vartype parent: int
    :ivar parsed:
    :vartype parsed: ~affinda.models.RowAnnotationParsed
    """

    _validation = {
        "id": {"required": True, "minimum": 1},
        "rectangle": {"required": True},
        "rectangles": {"required": True},
        "document": {"required": True},
        "page_index": {"required": True, "minimum": 0},
        "raw": {"required": True},
        "confidence": {"required": True},
        "classification_confidence": {"required": True},
        "text_extraction_confidence": {"required": True},
        "is_verified": {"required": True},
        "is_client_verified": {"required": True},
        "is_auto_verified": {"required": True},
        "data_point": {"required": True},
        "content_type": {"required": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "int"},
        "rectangle": {"key": "rectangle", "type": "Rectangle"},
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "document": {"key": "document", "type": "str"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "confidence": {"key": "confidence", "type": "float"},
        "classification_confidence": {"key": "classificationConfidence", "type": "float"},
        "text_extraction_confidence": {"key": "textExtractionConfidence", "type": "float"},
        "is_verified": {"key": "isVerified", "type": "bool"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "is_auto_verified": {"key": "isAutoVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "content_type": {"key": "contentType", "type": "str"},
        "parent": {"key": "parent", "type": "int"},
        "parsed": {"key": "parsed", "type": "RowAnnotationParsed"},
    }

    def __init__(self, **kwargs):
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword id: Required. Annotation's ID.
        :paramtype id: int
        :keyword rectangle: Required. x/y coordinates for the rectangular bounding box containing the
         data.
        :paramtype rectangle: ~affinda.models.Rectangle
        :keyword rectangles: Required. x/y coordinates for the rectangles containing the data. An
         annotation can be contained within multiple rectangles.
        :paramtype rectangles: list[~affinda.models.Rectangle]
        :keyword document: Required. Unique identifier for the document.
        :paramtype document: str
        :keyword page_index: Required. The page number within the document, starting from 0.
        :paramtype page_index: int
        :keyword raw: Required. Raw data extracted from the before any post-processing.
        :paramtype raw: str
        :keyword confidence: Required. The overall confidence that the model's prediction is correct.
        :paramtype confidence: float
        :keyword classification_confidence: Required. The model's confidence that the text has been
         classified correctly.
        :paramtype classification_confidence: float
        :keyword text_extraction_confidence: Required. If the document was submitted as an image, this
         is the confidence that the text in the image has been correctly read by the model.
        :paramtype text_extraction_confidence: float
        :keyword is_verified: Required. Indicates whether the data has been validated, either by a
         human using our validation tool or through auto-validation rules.
        :paramtype is_verified: bool
        :keyword is_client_verified: Required. Indicates whether the data has been validated by a
         human.
        :paramtype is_client_verified: bool
        :keyword is_auto_verified: Required. Indicates whether the data has been auto-validated.
        :paramtype is_auto_verified: bool
        :keyword data_point: Required. Data point's identifier.
        :paramtype data_point: str
        :keyword content_type: Required. The different data types of annotations. Known values are:
         "text", "integer", "float", "decimal", "date", "datetime", "daterange", "boolean", "enum",
         "location", "phonenumber", "json", "table", "expectedremuneration", "jobtitle", "language",
         "skill", "yearsexperience", "group", "table_deprecated", "url", "image".
        :paramtype content_type: str or ~affinda.models.AnnotationContentType
        :keyword parent: The parent annotation's ID.
        :paramtype parent: int
        :keyword parsed:
        :paramtype parsed: ~affinda.models.RowAnnotationParsed
        """
        super(RowAnnotation, self).__init__(**kwargs)
        self.parsed = kwargs.get("parsed", None)


class RowAnnotationParsed(msrest.serialization.Model):
    """RowAnnotationParsed.

    :ivar item_code:
    :vartype item_code: ~affinda.models.TextAnnotation
    :ivar item_date:
    :vartype item_date: ~affinda.models.DateAnnotation
    :ivar item_description:
    :vartype item_description: ~affinda.models.TextAnnotation
    :ivar item_unit:
    :vartype item_unit: ~affinda.models.TextAnnotation
    :ivar item_unit_price:
    :vartype item_unit_price: ~affinda.models.FloatAnnotation
    :ivar item_quantity:
    :vartype item_quantity: ~affinda.models.FloatAnnotation
    :ivar item_discount:
    :vartype item_discount: ~affinda.models.TextAnnotation
    :ivar item_base_total:
    :vartype item_base_total: ~affinda.models.FloatAnnotation
    :ivar item_tax_rate:
    :vartype item_tax_rate: ~affinda.models.TextAnnotation
    :ivar item_tax_total:
    :vartype item_tax_total: ~affinda.models.FloatAnnotation
    :ivar item_total:
    :vartype item_total: ~affinda.models.FloatAnnotation
    :ivar item_other:
    :vartype item_other: ~affinda.models.TextAnnotation
    """

    _attribute_map = {
        "item_code": {"key": "itemCode", "type": "TextAnnotation"},
        "item_date": {"key": "itemDate", "type": "DateAnnotation"},
        "item_description": {"key": "itemDescription", "type": "TextAnnotation"},
        "item_unit": {"key": "itemUnit", "type": "TextAnnotation"},
        "item_unit_price": {"key": "itemUnitPrice", "type": "FloatAnnotation"},
        "item_quantity": {"key": "itemQuantity", "type": "FloatAnnotation"},
        "item_discount": {"key": "itemDiscount", "type": "TextAnnotation"},
        "item_base_total": {"key": "itemBaseTotal", "type": "FloatAnnotation"},
        "item_tax_rate": {"key": "itemTaxRate", "type": "TextAnnotation"},
        "item_tax_total": {"key": "itemTaxTotal", "type": "FloatAnnotation"},
        "item_total": {"key": "itemTotal", "type": "FloatAnnotation"},
        "item_other": {"key": "itemOther", "type": "TextAnnotation"},
    }

    def __init__(self, **kwargs):
        """
        :keyword item_code:
        :paramtype item_code: ~affinda.models.TextAnnotation
        :keyword item_date:
        :paramtype item_date: ~affinda.models.DateAnnotation
        :keyword item_description:
        :paramtype item_description: ~affinda.models.TextAnnotation
        :keyword item_unit:
        :paramtype item_unit: ~affinda.models.TextAnnotation
        :keyword item_unit_price:
        :paramtype item_unit_price: ~affinda.models.FloatAnnotation
        :keyword item_quantity:
        :paramtype item_quantity: ~affinda.models.FloatAnnotation
        :keyword item_discount:
        :paramtype item_discount: ~affinda.models.TextAnnotation
        :keyword item_base_total:
        :paramtype item_base_total: ~affinda.models.FloatAnnotation
        :keyword item_tax_rate:
        :paramtype item_tax_rate: ~affinda.models.TextAnnotation
        :keyword item_tax_total:
        :paramtype item_tax_total: ~affinda.models.FloatAnnotation
        :keyword item_total:
        :paramtype item_total: ~affinda.models.FloatAnnotation
        :keyword item_other:
        :paramtype item_other: ~affinda.models.TextAnnotation
        """
        super(RowAnnotationParsed, self).__init__(**kwargs)
        self.item_code = kwargs.get("item_code", None)
        self.item_date = kwargs.get("item_date", None)
        self.item_description = kwargs.get("item_description", None)
        self.item_unit = kwargs.get("item_unit", None)
        self.item_unit_price = kwargs.get("item_unit_price", None)
        self.item_quantity = kwargs.get("item_quantity", None)
        self.item_discount = kwargs.get("item_discount", None)
        self.item_base_total = kwargs.get("item_base_total", None)
        self.item_tax_rate = kwargs.get("item_tax_rate", None)
        self.item_tax_total = kwargs.get("item_tax_total", None)
        self.item_total = kwargs.get("item_total", None)
        self.item_other = kwargs.get("item_other", None)


class RowBetaAnnotation(Annotation):
    """RowBetaAnnotation.

    All required parameters must be populated in order to send to Azure.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id: Required. Annotation's ID.
    :vartype id: int
    :ivar rectangle: Required. x/y coordinates for the rectangular bounding box containing the
     data.
    :vartype rectangle: ~affinda.models.Rectangle
    :ivar rectangles: Required. x/y coordinates for the rectangles containing the data. An
     annotation can be contained within multiple rectangles.
    :vartype rectangles: list[~affinda.models.Rectangle]
    :ivar document: Required. Unique identifier for the document.
    :vartype document: str
    :ivar page_index: Required. The page number within the document, starting from 0.
    :vartype page_index: int
    :ivar raw: Required. Raw data extracted from the before any post-processing.
    :vartype raw: str
    :ivar confidence: Required. The overall confidence that the model's prediction is correct.
    :vartype confidence: float
    :ivar classification_confidence: Required. The model's confidence that the text has been
     classified correctly.
    :vartype classification_confidence: float
    :ivar text_extraction_confidence: Required. If the document was submitted as an image, this is
     the confidence that the text in the image has been correctly read by the model.
    :vartype text_extraction_confidence: float
    :ivar is_verified: Required. Indicates whether the data has been validated, either by a human
     using our validation tool or through auto-validation rules.
    :vartype is_verified: bool
    :ivar is_client_verified: Required. Indicates whether the data has been validated by a human.
    :vartype is_client_verified: bool
    :ivar is_auto_verified: Required. Indicates whether the data has been auto-validated.
    :vartype is_auto_verified: bool
    :ivar data_point: Required. Data point's identifier.
    :vartype data_point: str
    :ivar content_type: Required. The different data types of annotations. Known values are:
     "text", "integer", "float", "decimal", "date", "datetime", "daterange", "boolean", "enum",
     "location", "phonenumber", "json", "table", "expectedremuneration", "jobtitle", "language",
     "skill", "yearsexperience", "group", "table_deprecated", "url", "image".
    :vartype content_type: str or ~affinda.models.AnnotationContentType
    :ivar parent: The parent annotation's ID.
    :vartype parent: int
    :ivar parsed:
    :vartype parsed: ~affinda.models.RowBetaAnnotationParsed
    """

    _validation = {
        "id": {"required": True, "minimum": 1},
        "rectangle": {"required": True},
        "rectangles": {"required": True},
        "document": {"required": True},
        "page_index": {"required": True, "minimum": 0},
        "raw": {"required": True},
        "confidence": {"required": True},
        "classification_confidence": {"required": True},
        "text_extraction_confidence": {"required": True},
        "is_verified": {"required": True},
        "is_client_verified": {"required": True},
        "is_auto_verified": {"required": True},
        "data_point": {"required": True},
        "content_type": {"required": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "int"},
        "rectangle": {"key": "rectangle", "type": "Rectangle"},
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "document": {"key": "document", "type": "str"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "confidence": {"key": "confidence", "type": "float"},
        "classification_confidence": {"key": "classificationConfidence", "type": "float"},
        "text_extraction_confidence": {"key": "textExtractionConfidence", "type": "float"},
        "is_verified": {"key": "isVerified", "type": "bool"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "is_auto_verified": {"key": "isAutoVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "content_type": {"key": "contentType", "type": "str"},
        "parent": {"key": "parent", "type": "int"},
        "parsed": {"key": "parsed", "type": "RowBetaAnnotationParsed"},
    }

    def __init__(self, **kwargs):
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword id: Required. Annotation's ID.
        :paramtype id: int
        :keyword rectangle: Required. x/y coordinates for the rectangular bounding box containing the
         data.
        :paramtype rectangle: ~affinda.models.Rectangle
        :keyword rectangles: Required. x/y coordinates for the rectangles containing the data. An
         annotation can be contained within multiple rectangles.
        :paramtype rectangles: list[~affinda.models.Rectangle]
        :keyword document: Required. Unique identifier for the document.
        :paramtype document: str
        :keyword page_index: Required. The page number within the document, starting from 0.
        :paramtype page_index: int
        :keyword raw: Required. Raw data extracted from the before any post-processing.
        :paramtype raw: str
        :keyword confidence: Required. The overall confidence that the model's prediction is correct.
        :paramtype confidence: float
        :keyword classification_confidence: Required. The model's confidence that the text has been
         classified correctly.
        :paramtype classification_confidence: float
        :keyword text_extraction_confidence: Required. If the document was submitted as an image, this
         is the confidence that the text in the image has been correctly read by the model.
        :paramtype text_extraction_confidence: float
        :keyword is_verified: Required. Indicates whether the data has been validated, either by a
         human using our validation tool or through auto-validation rules.
        :paramtype is_verified: bool
        :keyword is_client_verified: Required. Indicates whether the data has been validated by a
         human.
        :paramtype is_client_verified: bool
        :keyword is_auto_verified: Required. Indicates whether the data has been auto-validated.
        :paramtype is_auto_verified: bool
        :keyword data_point: Required. Data point's identifier.
        :paramtype data_point: str
        :keyword content_type: Required. The different data types of annotations. Known values are:
         "text", "integer", "float", "decimal", "date", "datetime", "daterange", "boolean", "enum",
         "location", "phonenumber", "json", "table", "expectedremuneration", "jobtitle", "language",
         "skill", "yearsexperience", "group", "table_deprecated", "url", "image".
        :paramtype content_type: str or ~affinda.models.AnnotationContentType
        :keyword parent: The parent annotation's ID.
        :paramtype parent: int
        :keyword parsed:
        :paramtype parsed: ~affinda.models.RowBetaAnnotationParsed
        """
        super(RowBetaAnnotation, self).__init__(**kwargs)
        self.parsed = kwargs.get("parsed", None)


class RowBetaAnnotationParsed(msrest.serialization.Model):
    """RowBetaAnnotationParsed.

    :ivar item_code_beta:
    :vartype item_code_beta: ~affinda.models.TextAnnotation
    :ivar item_date_beta:
    :vartype item_date_beta: ~affinda.models.DateAnnotation
    :ivar item_description_beta:
    :vartype item_description_beta: ~affinda.models.TextAnnotation
    :ivar item_unit_beta:
    :vartype item_unit_beta: ~affinda.models.TextAnnotation
    :ivar item_unit_price_beta:
    :vartype item_unit_price_beta: ~affinda.models.FloatAnnotation
    :ivar item_quantity_beta:
    :vartype item_quantity_beta: ~affinda.models.FloatAnnotation
    :ivar item_discount_beta:
    :vartype item_discount_beta: ~affinda.models.TextAnnotation
    :ivar item_base_total_beta:
    :vartype item_base_total_beta: ~affinda.models.FloatAnnotation
    :ivar item_tax_rate_beta:
    :vartype item_tax_rate_beta: ~affinda.models.TextAnnotation
    :ivar item_tax_total_beta:
    :vartype item_tax_total_beta: ~affinda.models.FloatAnnotation
    :ivar item_total_beta:
    :vartype item_total_beta: ~affinda.models.FloatAnnotation
    :ivar item_other_beta:
    :vartype item_other_beta: ~affinda.models.TextAnnotation
    """

    _attribute_map = {
        "item_code_beta": {"key": "itemCodeBeta", "type": "TextAnnotation"},
        "item_date_beta": {"key": "itemDateBeta", "type": "DateAnnotation"},
        "item_description_beta": {"key": "itemDescriptionBeta", "type": "TextAnnotation"},
        "item_unit_beta": {"key": "itemUnitBeta", "type": "TextAnnotation"},
        "item_unit_price_beta": {"key": "itemUnitPriceBeta", "type": "FloatAnnotation"},
        "item_quantity_beta": {"key": "itemQuantityBeta", "type": "FloatAnnotation"},
        "item_discount_beta": {"key": "itemDiscountBeta", "type": "TextAnnotation"},
        "item_base_total_beta": {"key": "itemBaseTotalBeta", "type": "FloatAnnotation"},
        "item_tax_rate_beta": {"key": "itemTaxRateBeta", "type": "TextAnnotation"},
        "item_tax_total_beta": {"key": "itemTaxTotalBeta", "type": "FloatAnnotation"},
        "item_total_beta": {"key": "itemTotalBeta", "type": "FloatAnnotation"},
        "item_other_beta": {"key": "itemOtherBeta", "type": "TextAnnotation"},
    }

    def __init__(self, **kwargs):
        """
        :keyword item_code_beta:
        :paramtype item_code_beta: ~affinda.models.TextAnnotation
        :keyword item_date_beta:
        :paramtype item_date_beta: ~affinda.models.DateAnnotation
        :keyword item_description_beta:
        :paramtype item_description_beta: ~affinda.models.TextAnnotation
        :keyword item_unit_beta:
        :paramtype item_unit_beta: ~affinda.models.TextAnnotation
        :keyword item_unit_price_beta:
        :paramtype item_unit_price_beta: ~affinda.models.FloatAnnotation
        :keyword item_quantity_beta:
        :paramtype item_quantity_beta: ~affinda.models.FloatAnnotation
        :keyword item_discount_beta:
        :paramtype item_discount_beta: ~affinda.models.TextAnnotation
        :keyword item_base_total_beta:
        :paramtype item_base_total_beta: ~affinda.models.FloatAnnotation
        :keyword item_tax_rate_beta:
        :paramtype item_tax_rate_beta: ~affinda.models.TextAnnotation
        :keyword item_tax_total_beta:
        :paramtype item_tax_total_beta: ~affinda.models.FloatAnnotation
        :keyword item_total_beta:
        :paramtype item_total_beta: ~affinda.models.FloatAnnotation
        :keyword item_other_beta:
        :paramtype item_other_beta: ~affinda.models.TextAnnotation
        """
        super(RowBetaAnnotationParsed, self).__init__(**kwargs)
        self.item_code_beta = kwargs.get("item_code_beta", None)
        self.item_date_beta = kwargs.get("item_date_beta", None)
        self.item_description_beta = kwargs.get("item_description_beta", None)
        self.item_unit_beta = kwargs.get("item_unit_beta", None)
        self.item_unit_price_beta = kwargs.get("item_unit_price_beta", None)
        self.item_quantity_beta = kwargs.get("item_quantity_beta", None)
        self.item_discount_beta = kwargs.get("item_discount_beta", None)
        self.item_base_total_beta = kwargs.get("item_base_total_beta", None)
        self.item_tax_rate_beta = kwargs.get("item_tax_rate_beta", None)
        self.item_tax_total_beta = kwargs.get("item_tax_total_beta", None)
        self.item_total_beta = kwargs.get("item_total_beta", None)
        self.item_other_beta = kwargs.get("item_other_beta", None)


class SearchConfigAction(msrest.serialization.Model):
    """SearchConfigAction.

    All required parameters must be populated in order to send to Azure.

    :ivar label: Required. Human readable label to display in the UI.
    :vartype label: str
    :ivar event_name: Required. Name of the event to be triggered.
    :vartype event_name: str
    """

    _validation = {
        "label": {"required": True},
        "event_name": {"required": True},
    }

    _attribute_map = {
        "label": {"key": "label", "type": "str"},
        "event_name": {"key": "eventName", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword label: Required. Human readable label to display in the UI.
        :paramtype label: str
        :keyword event_name: Required. Name of the event to be triggered.
        :paramtype event_name: str
        """
        super(SearchConfigAction, self).__init__(**kwargs)
        self.label = kwargs["label"]
        self.event_name = kwargs["event_name"]


class SearchExpressionSearchScoreComponent(msrest.serialization.Model):
    """SearchExpressionSearchScoreComponent.

    All required parameters must be populated in order to send to Azure.

    :ivar label: Required.
    :vartype label: str
    :ivar value:
    :vartype value: str
    :ivar score:
    :vartype score: float
    """

    _validation = {
        "label": {"required": True},
    }

    _attribute_map = {
        "label": {"key": "label", "type": "str"},
        "value": {"key": "value", "type": "str"},
        "score": {"key": "score", "type": "float"},
    }

    def __init__(self, **kwargs):
        """
        :keyword label: Required.
        :paramtype label: str
        :keyword value:
        :paramtype value: str
        :keyword score:
        :paramtype score: float
        """
        super(SearchExpressionSearchScoreComponent, self).__init__(**kwargs)
        self.label = kwargs["label"]
        self.value = kwargs.get("value", None)
        self.score = kwargs.get("score", None)


class SkillAnnotation(Annotation):
    """SkillAnnotation.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id: Required. Annotation's ID.
    :vartype id: int
    :ivar rectangle: Required. x/y coordinates for the rectangular bounding box containing the
     data.
    :vartype rectangle: ~affinda.models.Rectangle
    :ivar rectangles: Required. x/y coordinates for the rectangles containing the data. An
     annotation can be contained within multiple rectangles.
    :vartype rectangles: list[~affinda.models.Rectangle]
    :ivar document: Required. Unique identifier for the document.
    :vartype document: str
    :ivar page_index: Required. The page number within the document, starting from 0.
    :vartype page_index: int
    :ivar raw: Required. Raw data extracted from the before any post-processing.
    :vartype raw: str
    :ivar confidence: Required. The overall confidence that the model's prediction is correct.
    :vartype confidence: float
    :ivar classification_confidence: Required. The model's confidence that the text has been
     classified correctly.
    :vartype classification_confidence: float
    :ivar text_extraction_confidence: Required. If the document was submitted as an image, this is
     the confidence that the text in the image has been correctly read by the model.
    :vartype text_extraction_confidence: float
    :ivar is_verified: Required. Indicates whether the data has been validated, either by a human
     using our validation tool or through auto-validation rules.
    :vartype is_verified: bool
    :ivar is_client_verified: Required. Indicates whether the data has been validated by a human.
    :vartype is_client_verified: bool
    :ivar is_auto_verified: Required. Indicates whether the data has been auto-validated.
    :vartype is_auto_verified: bool
    :ivar data_point: Required. Data point's identifier.
    :vartype data_point: str
    :ivar content_type: Required. The different data types of annotations. Known values are:
     "text", "integer", "float", "decimal", "date", "datetime", "daterange", "boolean", "enum",
     "location", "phonenumber", "json", "table", "expectedremuneration", "jobtitle", "language",
     "skill", "yearsexperience", "group", "table_deprecated", "url", "image".
    :vartype content_type: str or ~affinda.models.AnnotationContentType
    :ivar parent: The parent annotation's ID.
    :vartype parent: int
    :ivar parsed:
    :vartype parsed: str
    """

    _validation = {
        "id": {"required": True, "minimum": 1},
        "rectangle": {"required": True},
        "rectangles": {"required": True},
        "document": {"required": True},
        "page_index": {"required": True, "minimum": 0},
        "raw": {"required": True},
        "confidence": {"required": True},
        "classification_confidence": {"required": True},
        "text_extraction_confidence": {"required": True},
        "is_verified": {"required": True},
        "is_client_verified": {"required": True},
        "is_auto_verified": {"required": True},
        "data_point": {"required": True},
        "content_type": {"required": True},
        "parsed": {"readonly": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "int"},
        "rectangle": {"key": "rectangle", "type": "Rectangle"},
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "document": {"key": "document", "type": "str"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "confidence": {"key": "confidence", "type": "float"},
        "classification_confidence": {"key": "classificationConfidence", "type": "float"},
        "text_extraction_confidence": {"key": "textExtractionConfidence", "type": "float"},
        "is_verified": {"key": "isVerified", "type": "bool"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "is_auto_verified": {"key": "isAutoVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "content_type": {"key": "contentType", "type": "str"},
        "parent": {"key": "parent", "type": "int"},
        "parsed": {"key": "parsed", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword id: Required. Annotation's ID.
        :paramtype id: int
        :keyword rectangle: Required. x/y coordinates for the rectangular bounding box containing the
         data.
        :paramtype rectangle: ~affinda.models.Rectangle
        :keyword rectangles: Required. x/y coordinates for the rectangles containing the data. An
         annotation can be contained within multiple rectangles.
        :paramtype rectangles: list[~affinda.models.Rectangle]
        :keyword document: Required. Unique identifier for the document.
        :paramtype document: str
        :keyword page_index: Required. The page number within the document, starting from 0.
        :paramtype page_index: int
        :keyword raw: Required. Raw data extracted from the before any post-processing.
        :paramtype raw: str
        :keyword confidence: Required. The overall confidence that the model's prediction is correct.
        :paramtype confidence: float
        :keyword classification_confidence: Required. The model's confidence that the text has been
         classified correctly.
        :paramtype classification_confidence: float
        :keyword text_extraction_confidence: Required. If the document was submitted as an image, this
         is the confidence that the text in the image has been correctly read by the model.
        :paramtype text_extraction_confidence: float
        :keyword is_verified: Required. Indicates whether the data has been validated, either by a
         human using our validation tool or through auto-validation rules.
        :paramtype is_verified: bool
        :keyword is_client_verified: Required. Indicates whether the data has been validated by a
         human.
        :paramtype is_client_verified: bool
        :keyword is_auto_verified: Required. Indicates whether the data has been auto-validated.
        :paramtype is_auto_verified: bool
        :keyword data_point: Required. Data point's identifier.
        :paramtype data_point: str
        :keyword content_type: Required. The different data types of annotations. Known values are:
         "text", "integer", "float", "decimal", "date", "datetime", "daterange", "boolean", "enum",
         "location", "phonenumber", "json", "table", "expectedremuneration", "jobtitle", "language",
         "skill", "yearsexperience", "group", "table_deprecated", "url", "image".
        :paramtype content_type: str or ~affinda.models.AnnotationContentType
        :keyword parent: The parent annotation's ID.
        :paramtype parent: int
        """
        super(SkillAnnotation, self).__init__(**kwargs)
        self.parsed = None


class SkillAnnotationUpdate(AnnotationBase):
    """SkillAnnotationUpdate.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id:
    :vartype id: int
    :ivar rectangle:
    :vartype rectangle: ~affinda.models.Rectangle
    :ivar rectangles:
    :vartype rectangles: list[~affinda.models.Rectangle]
    :ivar page_index:
    :vartype page_index: int
    :ivar raw:
    :vartype raw: str
    :ivar confidence: The overall confidence that the model's prediction is correct.
    :vartype confidence: float
    :ivar classification_confidence: The model's confidence that the text has been classified
     correctly.
    :vartype classification_confidence: float
    :ivar text_extraction_confidence: If the document was submitted as an image, this is the
     confidence that the text in the image has been correctly read by the model.
    :vartype text_extraction_confidence: float
    :ivar is_verified:
    :vartype is_verified: bool
    :ivar is_client_verified:
    :vartype is_client_verified: bool
    :ivar is_auto_verified:
    :vartype is_auto_verified: bool
    :ivar data_point:
    :vartype data_point: str
    :ivar content_type:
    :vartype content_type: str
    :ivar parsed:
    :vartype parsed: str
    """

    _validation = {
        "rectangles": {"readonly": True},
        "parsed": {"readonly": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "int"},
        "rectangle": {"key": "rectangle", "type": "Rectangle"},
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "confidence": {"key": "confidence", "type": "float"},
        "classification_confidence": {"key": "classificationConfidence", "type": "float"},
        "text_extraction_confidence": {"key": "textExtractionConfidence", "type": "float"},
        "is_verified": {"key": "isVerified", "type": "bool"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "is_auto_verified": {"key": "isAutoVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "content_type": {"key": "contentType", "type": "str"},
        "parsed": {"key": "parsed", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword id:
        :paramtype id: int
        :keyword rectangle:
        :paramtype rectangle: ~affinda.models.Rectangle
        :keyword page_index:
        :paramtype page_index: int
        :keyword raw:
        :paramtype raw: str
        :keyword confidence: The overall confidence that the model's prediction is correct.
        :paramtype confidence: float
        :keyword classification_confidence: The model's confidence that the text has been classified
         correctly.
        :paramtype classification_confidence: float
        :keyword text_extraction_confidence: If the document was submitted as an image, this is the
         confidence that the text in the image has been correctly read by the model.
        :paramtype text_extraction_confidence: float
        :keyword is_verified:
        :paramtype is_verified: bool
        :keyword is_client_verified:
        :paramtype is_client_verified: bool
        :keyword is_auto_verified:
        :paramtype is_auto_verified: bool
        :keyword data_point:
        :paramtype data_point: str
        :keyword content_type:
        :paramtype content_type: str
        """
        super(SkillAnnotationUpdate, self).__init__(**kwargs)
        self.parsed = None


class SkillsSearchScoreComponent(msrest.serialization.Model):
    """SkillsSearchScoreComponent.

    All required parameters must be populated in order to send to Azure.

    :ivar value:
    :vartype value: str
    :ivar label: Required.
    :vartype label: str
    :ivar score:
    :vartype score: float
    """

    _validation = {
        "label": {"required": True},
    }

    _attribute_map = {
        "value": {"key": "value", "type": "str"},
        "label": {"key": "label", "type": "str"},
        "score": {"key": "score", "type": "float"},
    }

    def __init__(self, **kwargs):
        """
        :keyword value:
        :paramtype value: str
        :keyword label: Required.
        :paramtype label: str
        :keyword score:
        :paramtype score: float
        """
        super(SkillsSearchScoreComponent, self).__init__(**kwargs)
        self.value = kwargs.get("value", None)
        self.label = kwargs["label"]
        self.score = kwargs.get("score", None)


class TableAnnotation(Annotation):
    """TableAnnotation.

    All required parameters must be populated in order to send to Azure.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id: Required. Annotation's ID.
    :vartype id: int
    :ivar rectangle: Required. x/y coordinates for the rectangular bounding box containing the
     data.
    :vartype rectangle: ~affinda.models.Rectangle
    :ivar rectangles: Required. x/y coordinates for the rectangles containing the data. An
     annotation can be contained within multiple rectangles.
    :vartype rectangles: list[~affinda.models.Rectangle]
    :ivar document: Required. Unique identifier for the document.
    :vartype document: str
    :ivar page_index: Required. The page number within the document, starting from 0.
    :vartype page_index: int
    :ivar raw: Required. Raw data extracted from the before any post-processing.
    :vartype raw: str
    :ivar confidence: Required. The overall confidence that the model's prediction is correct.
    :vartype confidence: float
    :ivar classification_confidence: Required. The model's confidence that the text has been
     classified correctly.
    :vartype classification_confidence: float
    :ivar text_extraction_confidence: Required. If the document was submitted as an image, this is
     the confidence that the text in the image has been correctly read by the model.
    :vartype text_extraction_confidence: float
    :ivar is_verified: Required. Indicates whether the data has been validated, either by a human
     using our validation tool or through auto-validation rules.
    :vartype is_verified: bool
    :ivar is_client_verified: Required. Indicates whether the data has been validated by a human.
    :vartype is_client_verified: bool
    :ivar is_auto_verified: Required. Indicates whether the data has been auto-validated.
    :vartype is_auto_verified: bool
    :ivar data_point: Required. Data point's identifier.
    :vartype data_point: str
    :ivar content_type: Required. The different data types of annotations. Known values are:
     "text", "integer", "float", "decimal", "date", "datetime", "daterange", "boolean", "enum",
     "location", "phonenumber", "json", "table", "expectedremuneration", "jobtitle", "language",
     "skill", "yearsexperience", "group", "table_deprecated", "url", "image".
    :vartype content_type: str or ~affinda.models.AnnotationContentType
    :ivar parent: The parent annotation's ID.
    :vartype parent: int
    :ivar parsed:
    :vartype parsed: ~affinda.models.TableAnnotationParsed
    """

    _validation = {
        "id": {"required": True, "minimum": 1},
        "rectangle": {"required": True},
        "rectangles": {"required": True},
        "document": {"required": True},
        "page_index": {"required": True, "minimum": 0},
        "raw": {"required": True},
        "confidence": {"required": True},
        "classification_confidence": {"required": True},
        "text_extraction_confidence": {"required": True},
        "is_verified": {"required": True},
        "is_client_verified": {"required": True},
        "is_auto_verified": {"required": True},
        "data_point": {"required": True},
        "content_type": {"required": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "int"},
        "rectangle": {"key": "rectangle", "type": "Rectangle"},
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "document": {"key": "document", "type": "str"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "confidence": {"key": "confidence", "type": "float"},
        "classification_confidence": {"key": "classificationConfidence", "type": "float"},
        "text_extraction_confidence": {"key": "textExtractionConfidence", "type": "float"},
        "is_verified": {"key": "isVerified", "type": "bool"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "is_auto_verified": {"key": "isAutoVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "content_type": {"key": "contentType", "type": "str"},
        "parent": {"key": "parent", "type": "int"},
        "parsed": {"key": "parsed", "type": "TableAnnotationParsed"},
    }

    def __init__(self, **kwargs):
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword id: Required. Annotation's ID.
        :paramtype id: int
        :keyword rectangle: Required. x/y coordinates for the rectangular bounding box containing the
         data.
        :paramtype rectangle: ~affinda.models.Rectangle
        :keyword rectangles: Required. x/y coordinates for the rectangles containing the data. An
         annotation can be contained within multiple rectangles.
        :paramtype rectangles: list[~affinda.models.Rectangle]
        :keyword document: Required. Unique identifier for the document.
        :paramtype document: str
        :keyword page_index: Required. The page number within the document, starting from 0.
        :paramtype page_index: int
        :keyword raw: Required. Raw data extracted from the before any post-processing.
        :paramtype raw: str
        :keyword confidence: Required. The overall confidence that the model's prediction is correct.
        :paramtype confidence: float
        :keyword classification_confidence: Required. The model's confidence that the text has been
         classified correctly.
        :paramtype classification_confidence: float
        :keyword text_extraction_confidence: Required. If the document was submitted as an image, this
         is the confidence that the text in the image has been correctly read by the model.
        :paramtype text_extraction_confidence: float
        :keyword is_verified: Required. Indicates whether the data has been validated, either by a
         human using our validation tool or through auto-validation rules.
        :paramtype is_verified: bool
        :keyword is_client_verified: Required. Indicates whether the data has been validated by a
         human.
        :paramtype is_client_verified: bool
        :keyword is_auto_verified: Required. Indicates whether the data has been auto-validated.
        :paramtype is_auto_verified: bool
        :keyword data_point: Required. Data point's identifier.
        :paramtype data_point: str
        :keyword content_type: Required. The different data types of annotations. Known values are:
         "text", "integer", "float", "decimal", "date", "datetime", "daterange", "boolean", "enum",
         "location", "phonenumber", "json", "table", "expectedremuneration", "jobtitle", "language",
         "skill", "yearsexperience", "group", "table_deprecated", "url", "image".
        :paramtype content_type: str or ~affinda.models.AnnotationContentType
        :keyword parent: The parent annotation's ID.
        :paramtype parent: int
        :keyword parsed:
        :paramtype parsed: ~affinda.models.TableAnnotationParsed
        """
        super(TableAnnotation, self).__init__(**kwargs)
        self.parsed = kwargs.get("parsed", None)


class TableAnnotationParsed(msrest.serialization.Model):
    """TableAnnotationParsed.

    :ivar rows:
    :vartype rows: list[~affinda.models.RowAnnotation]
    """

    _attribute_map = {
        "rows": {"key": "rows", "type": "[RowAnnotation]"},
    }

    def __init__(self, **kwargs):
        """
        :keyword rows:
        :paramtype rows: list[~affinda.models.RowAnnotation]
        """
        super(TableAnnotationParsed, self).__init__(**kwargs)
        self.rows = kwargs.get("rows", None)


class TableBetaAnnotation(Annotation):
    """TableBetaAnnotation.

    All required parameters must be populated in order to send to Azure.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id: Required. Annotation's ID.
    :vartype id: int
    :ivar rectangle: Required. x/y coordinates for the rectangular bounding box containing the
     data.
    :vartype rectangle: ~affinda.models.Rectangle
    :ivar rectangles: Required. x/y coordinates for the rectangles containing the data. An
     annotation can be contained within multiple rectangles.
    :vartype rectangles: list[~affinda.models.Rectangle]
    :ivar document: Required. Unique identifier for the document.
    :vartype document: str
    :ivar page_index: Required. The page number within the document, starting from 0.
    :vartype page_index: int
    :ivar raw: Required. Raw data extracted from the before any post-processing.
    :vartype raw: str
    :ivar confidence: Required. The overall confidence that the model's prediction is correct.
    :vartype confidence: float
    :ivar classification_confidence: Required. The model's confidence that the text has been
     classified correctly.
    :vartype classification_confidence: float
    :ivar text_extraction_confidence: Required. If the document was submitted as an image, this is
     the confidence that the text in the image has been correctly read by the model.
    :vartype text_extraction_confidence: float
    :ivar is_verified: Required. Indicates whether the data has been validated, either by a human
     using our validation tool or through auto-validation rules.
    :vartype is_verified: bool
    :ivar is_client_verified: Required. Indicates whether the data has been validated by a human.
    :vartype is_client_verified: bool
    :ivar is_auto_verified: Required. Indicates whether the data has been auto-validated.
    :vartype is_auto_verified: bool
    :ivar data_point: Required. Data point's identifier.
    :vartype data_point: str
    :ivar content_type: Required. The different data types of annotations. Known values are:
     "text", "integer", "float", "decimal", "date", "datetime", "daterange", "boolean", "enum",
     "location", "phonenumber", "json", "table", "expectedremuneration", "jobtitle", "language",
     "skill", "yearsexperience", "group", "table_deprecated", "url", "image".
    :vartype content_type: str or ~affinda.models.AnnotationContentType
    :ivar parent: The parent annotation's ID.
    :vartype parent: int
    :ivar parsed:
    :vartype parsed: ~affinda.models.TableBetaAnnotationParsed
    """

    _validation = {
        "id": {"required": True, "minimum": 1},
        "rectangle": {"required": True},
        "rectangles": {"required": True},
        "document": {"required": True},
        "page_index": {"required": True, "minimum": 0},
        "raw": {"required": True},
        "confidence": {"required": True},
        "classification_confidence": {"required": True},
        "text_extraction_confidence": {"required": True},
        "is_verified": {"required": True},
        "is_client_verified": {"required": True},
        "is_auto_verified": {"required": True},
        "data_point": {"required": True},
        "content_type": {"required": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "int"},
        "rectangle": {"key": "rectangle", "type": "Rectangle"},
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "document": {"key": "document", "type": "str"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "confidence": {"key": "confidence", "type": "float"},
        "classification_confidence": {"key": "classificationConfidence", "type": "float"},
        "text_extraction_confidence": {"key": "textExtractionConfidence", "type": "float"},
        "is_verified": {"key": "isVerified", "type": "bool"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "is_auto_verified": {"key": "isAutoVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "content_type": {"key": "contentType", "type": "str"},
        "parent": {"key": "parent", "type": "int"},
        "parsed": {"key": "parsed", "type": "TableBetaAnnotationParsed"},
    }

    def __init__(self, **kwargs):
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword id: Required. Annotation's ID.
        :paramtype id: int
        :keyword rectangle: Required. x/y coordinates for the rectangular bounding box containing the
         data.
        :paramtype rectangle: ~affinda.models.Rectangle
        :keyword rectangles: Required. x/y coordinates for the rectangles containing the data. An
         annotation can be contained within multiple rectangles.
        :paramtype rectangles: list[~affinda.models.Rectangle]
        :keyword document: Required. Unique identifier for the document.
        :paramtype document: str
        :keyword page_index: Required. The page number within the document, starting from 0.
        :paramtype page_index: int
        :keyword raw: Required. Raw data extracted from the before any post-processing.
        :paramtype raw: str
        :keyword confidence: Required. The overall confidence that the model's prediction is correct.
        :paramtype confidence: float
        :keyword classification_confidence: Required. The model's confidence that the text has been
         classified correctly.
        :paramtype classification_confidence: float
        :keyword text_extraction_confidence: Required. If the document was submitted as an image, this
         is the confidence that the text in the image has been correctly read by the model.
        :paramtype text_extraction_confidence: float
        :keyword is_verified: Required. Indicates whether the data has been validated, either by a
         human using our validation tool or through auto-validation rules.
        :paramtype is_verified: bool
        :keyword is_client_verified: Required. Indicates whether the data has been validated by a
         human.
        :paramtype is_client_verified: bool
        :keyword is_auto_verified: Required. Indicates whether the data has been auto-validated.
        :paramtype is_auto_verified: bool
        :keyword data_point: Required. Data point's identifier.
        :paramtype data_point: str
        :keyword content_type: Required. The different data types of annotations. Known values are:
         "text", "integer", "float", "decimal", "date", "datetime", "daterange", "boolean", "enum",
         "location", "phonenumber", "json", "table", "expectedremuneration", "jobtitle", "language",
         "skill", "yearsexperience", "group", "table_deprecated", "url", "image".
        :paramtype content_type: str or ~affinda.models.AnnotationContentType
        :keyword parent: The parent annotation's ID.
        :paramtype parent: int
        :keyword parsed:
        :paramtype parsed: ~affinda.models.TableBetaAnnotationParsed
        """
        super(TableBetaAnnotation, self).__init__(**kwargs)
        self.parsed = kwargs.get("parsed", None)


class TableBetaAnnotationParsed(msrest.serialization.Model):
    """TableBetaAnnotationParsed.

    :ivar rows:
    :vartype rows: list[~affinda.models.RowBetaAnnotation]
    """

    _attribute_map = {
        "rows": {"key": "rows", "type": "[RowBetaAnnotation]"},
    }

    def __init__(self, **kwargs):
        """
        :keyword rows:
        :paramtype rows: list[~affinda.models.RowBetaAnnotation]
        """
        super(TableBetaAnnotationParsed, self).__init__(**kwargs)
        self.rows = kwargs.get("rows", None)


class Tag(msrest.serialization.Model):
    """Tag.

    All required parameters must be populated in order to send to Azure.

    :ivar id: Required. Uniquely identify a tag.
    :vartype id: int
    :ivar name: Required.
    :vartype name: str
    :ivar workspace: Required. Uniquely identify a workspace.
    :vartype workspace: str
    :ivar document_count: Required. Number of documents tagged with this.
    :vartype document_count: int
    """

    _validation = {
        "id": {"required": True, "minimum": 1},
        "name": {"required": True},
        "workspace": {"required": True},
        "document_count": {"required": True, "minimum": 0},
    }

    _attribute_map = {
        "id": {"key": "id", "type": "int"},
        "name": {"key": "name", "type": "str"},
        "workspace": {"key": "workspace", "type": "str"},
        "document_count": {"key": "documentCount", "type": "int"},
    }

    def __init__(self, **kwargs):
        """
        :keyword id: Required. Uniquely identify a tag.
        :paramtype id: int
        :keyword name: Required.
        :paramtype name: str
        :keyword workspace: Required. Uniquely identify a workspace.
        :paramtype workspace: str
        :keyword document_count: Required. Number of documents tagged with this.
        :paramtype document_count: int
        """
        super(Tag, self).__init__(**kwargs)
        self.id = kwargs["id"]
        self.name = kwargs["name"]
        self.workspace = kwargs["workspace"]
        self.document_count = kwargs["document_count"]


class TagCreate(msrest.serialization.Model):
    """TagCreate.

    All required parameters must be populated in order to send to Azure.

    :ivar name: Required.
    :vartype name: str
    :ivar workspace: Required. Uniquely identify a workspace.
    :vartype workspace: str
    """

    _validation = {
        "name": {"required": True},
        "workspace": {"required": True},
    }

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "workspace": {"key": "workspace", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword name: Required.
        :paramtype name: str
        :keyword workspace: Required. Uniquely identify a workspace.
        :paramtype workspace: str
        """
        super(TagCreate, self).__init__(**kwargs)
        self.name = kwargs["name"]
        self.workspace = kwargs["workspace"]


class TagUpdate(msrest.serialization.Model):
    """TagUpdate.

    :ivar name:
    :vartype name: str
    :ivar workspace: Uniquely identify a workspace.
    :vartype workspace: str
    """

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "workspace": {"key": "workspace", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword name:
        :paramtype name: str
        :keyword workspace: Uniquely identify a workspace.
        :paramtype workspace: str
        """
        super(TagUpdate, self).__init__(**kwargs)
        self.name = kwargs.get("name", None)
        self.workspace = kwargs.get("workspace", None)


class TextAnnotation(Annotation):
    """TextAnnotation.

    All required parameters must be populated in order to send to Azure.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id: Required. Annotation's ID.
    :vartype id: int
    :ivar rectangle: Required. x/y coordinates for the rectangular bounding box containing the
     data.
    :vartype rectangle: ~affinda.models.Rectangle
    :ivar rectangles: Required. x/y coordinates for the rectangles containing the data. An
     annotation can be contained within multiple rectangles.
    :vartype rectangles: list[~affinda.models.Rectangle]
    :ivar document: Required. Unique identifier for the document.
    :vartype document: str
    :ivar page_index: Required. The page number within the document, starting from 0.
    :vartype page_index: int
    :ivar raw: Required. Raw data extracted from the before any post-processing.
    :vartype raw: str
    :ivar confidence: Required. The overall confidence that the model's prediction is correct.
    :vartype confidence: float
    :ivar classification_confidence: Required. The model's confidence that the text has been
     classified correctly.
    :vartype classification_confidence: float
    :ivar text_extraction_confidence: Required. If the document was submitted as an image, this is
     the confidence that the text in the image has been correctly read by the model.
    :vartype text_extraction_confidence: float
    :ivar is_verified: Required. Indicates whether the data has been validated, either by a human
     using our validation tool or through auto-validation rules.
    :vartype is_verified: bool
    :ivar is_client_verified: Required. Indicates whether the data has been validated by a human.
    :vartype is_client_verified: bool
    :ivar is_auto_verified: Required. Indicates whether the data has been auto-validated.
    :vartype is_auto_verified: bool
    :ivar data_point: Required. Data point's identifier.
    :vartype data_point: str
    :ivar content_type: Required. The different data types of annotations. Known values are:
     "text", "integer", "float", "decimal", "date", "datetime", "daterange", "boolean", "enum",
     "location", "phonenumber", "json", "table", "expectedremuneration", "jobtitle", "language",
     "skill", "yearsexperience", "group", "table_deprecated", "url", "image".
    :vartype content_type: str or ~affinda.models.AnnotationContentType
    :ivar parent: The parent annotation's ID.
    :vartype parent: int
    :ivar parsed:
    :vartype parsed: str
    """

    _validation = {
        "id": {"required": True, "minimum": 1},
        "rectangle": {"required": True},
        "rectangles": {"required": True},
        "document": {"required": True},
        "page_index": {"required": True, "minimum": 0},
        "raw": {"required": True},
        "confidence": {"required": True},
        "classification_confidence": {"required": True},
        "text_extraction_confidence": {"required": True},
        "is_verified": {"required": True},
        "is_client_verified": {"required": True},
        "is_auto_verified": {"required": True},
        "data_point": {"required": True},
        "content_type": {"required": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "int"},
        "rectangle": {"key": "rectangle", "type": "Rectangle"},
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "document": {"key": "document", "type": "str"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "confidence": {"key": "confidence", "type": "float"},
        "classification_confidence": {"key": "classificationConfidence", "type": "float"},
        "text_extraction_confidence": {"key": "textExtractionConfidence", "type": "float"},
        "is_verified": {"key": "isVerified", "type": "bool"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "is_auto_verified": {"key": "isAutoVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "content_type": {"key": "contentType", "type": "str"},
        "parent": {"key": "parent", "type": "int"},
        "parsed": {"key": "parsed", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword id: Required. Annotation's ID.
        :paramtype id: int
        :keyword rectangle: Required. x/y coordinates for the rectangular bounding box containing the
         data.
        :paramtype rectangle: ~affinda.models.Rectangle
        :keyword rectangles: Required. x/y coordinates for the rectangles containing the data. An
         annotation can be contained within multiple rectangles.
        :paramtype rectangles: list[~affinda.models.Rectangle]
        :keyword document: Required. Unique identifier for the document.
        :paramtype document: str
        :keyword page_index: Required. The page number within the document, starting from 0.
        :paramtype page_index: int
        :keyword raw: Required. Raw data extracted from the before any post-processing.
        :paramtype raw: str
        :keyword confidence: Required. The overall confidence that the model's prediction is correct.
        :paramtype confidence: float
        :keyword classification_confidence: Required. The model's confidence that the text has been
         classified correctly.
        :paramtype classification_confidence: float
        :keyword text_extraction_confidence: Required. If the document was submitted as an image, this
         is the confidence that the text in the image has been correctly read by the model.
        :paramtype text_extraction_confidence: float
        :keyword is_verified: Required. Indicates whether the data has been validated, either by a
         human using our validation tool or through auto-validation rules.
        :paramtype is_verified: bool
        :keyword is_client_verified: Required. Indicates whether the data has been validated by a
         human.
        :paramtype is_client_verified: bool
        :keyword is_auto_verified: Required. Indicates whether the data has been auto-validated.
        :paramtype is_auto_verified: bool
        :keyword data_point: Required. Data point's identifier.
        :paramtype data_point: str
        :keyword content_type: Required. The different data types of annotations. Known values are:
         "text", "integer", "float", "decimal", "date", "datetime", "daterange", "boolean", "enum",
         "location", "phonenumber", "json", "table", "expectedremuneration", "jobtitle", "language",
         "skill", "yearsexperience", "group", "table_deprecated", "url", "image".
        :paramtype content_type: str or ~affinda.models.AnnotationContentType
        :keyword parent: The parent annotation's ID.
        :paramtype parent: int
        :keyword parsed:
        :paramtype parsed: str
        """
        super(TextAnnotation, self).__init__(**kwargs)
        self.parsed = kwargs.get("parsed", None)


class TextAnnotationUpdate(AnnotationBase):
    """TextAnnotationUpdate.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id:
    :vartype id: int
    :ivar rectangle:
    :vartype rectangle: ~affinda.models.Rectangle
    :ivar rectangles:
    :vartype rectangles: list[~affinda.models.Rectangle]
    :ivar page_index:
    :vartype page_index: int
    :ivar raw:
    :vartype raw: str
    :ivar confidence: The overall confidence that the model's prediction is correct.
    :vartype confidence: float
    :ivar classification_confidence: The model's confidence that the text has been classified
     correctly.
    :vartype classification_confidence: float
    :ivar text_extraction_confidence: If the document was submitted as an image, this is the
     confidence that the text in the image has been correctly read by the model.
    :vartype text_extraction_confidence: float
    :ivar is_verified:
    :vartype is_verified: bool
    :ivar is_client_verified:
    :vartype is_client_verified: bool
    :ivar is_auto_verified:
    :vartype is_auto_verified: bool
    :ivar data_point:
    :vartype data_point: str
    :ivar content_type:
    :vartype content_type: str
    :ivar parsed:
    :vartype parsed: str
    """

    _validation = {
        "rectangles": {"readonly": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "int"},
        "rectangle": {"key": "rectangle", "type": "Rectangle"},
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "confidence": {"key": "confidence", "type": "float"},
        "classification_confidence": {"key": "classificationConfidence", "type": "float"},
        "text_extraction_confidence": {"key": "textExtractionConfidence", "type": "float"},
        "is_verified": {"key": "isVerified", "type": "bool"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "is_auto_verified": {"key": "isAutoVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "content_type": {"key": "contentType", "type": "str"},
        "parsed": {"key": "parsed", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword id:
        :paramtype id: int
        :keyword rectangle:
        :paramtype rectangle: ~affinda.models.Rectangle
        :keyword page_index:
        :paramtype page_index: int
        :keyword raw:
        :paramtype raw: str
        :keyword confidence: The overall confidence that the model's prediction is correct.
        :paramtype confidence: float
        :keyword classification_confidence: The model's confidence that the text has been classified
         correctly.
        :paramtype classification_confidence: float
        :keyword text_extraction_confidence: If the document was submitted as an image, this is the
         confidence that the text in the image has been correctly read by the model.
        :paramtype text_extraction_confidence: float
        :keyword is_verified:
        :paramtype is_verified: bool
        :keyword is_client_verified:
        :paramtype is_client_verified: bool
        :keyword is_auto_verified:
        :paramtype is_auto_verified: bool
        :keyword data_point:
        :paramtype data_point: str
        :keyword content_type:
        :paramtype content_type: str
        :keyword parsed:
        :paramtype parsed: str
        """
        super(TextAnnotationUpdate, self).__init__(**kwargs)
        self.parsed = kwargs.get("parsed", None)


class ThemeConfigPalette(msrest.serialization.Model):
    """ThemeConfigPalette.

    :ivar mode: Known values are: "light", "dark".
    :vartype mode: str or ~affinda.models.ThemeConfigPaletteMode
    :ivar background: Anything.
    :vartype background: any
    :ivar text:
    :vartype text: ~affinda.models.ThemeConfigPaletteText
    :ivar divider:
    :vartype divider: str
    :ivar primary:
    :vartype primary: ~affinda.models.PaletteColorOptions
    :ivar secondary:
    :vartype secondary: ~affinda.models.PaletteColorOptions
    :ivar success:
    :vartype success: ~affinda.models.PaletteColorOptions
    :ivar annotation:
    :vartype annotation: ~affinda.models.PaletteColorOptions
    :ivar error:
    :vartype error: ~affinda.models.PaletteColorOptions
    :ivar info:
    :vartype info: ~affinda.models.PaletteColorOptions
    :ivar warning:
    :vartype warning: ~affinda.models.PaletteColorOptions
    """

    _attribute_map = {
        "mode": {"key": "mode", "type": "str"},
        "background": {"key": "background", "type": "object"},
        "text": {"key": "text", "type": "ThemeConfigPaletteText"},
        "divider": {"key": "divider", "type": "str"},
        "primary": {"key": "primary", "type": "PaletteColorOptions"},
        "secondary": {"key": "secondary", "type": "PaletteColorOptions"},
        "success": {"key": "success", "type": "PaletteColorOptions"},
        "annotation": {"key": "annotation", "type": "PaletteColorOptions"},
        "error": {"key": "error", "type": "PaletteColorOptions"},
        "info": {"key": "info", "type": "PaletteColorOptions"},
        "warning": {"key": "warning", "type": "PaletteColorOptions"},
    }

    def __init__(self, **kwargs):
        """
        :keyword mode: Known values are: "light", "dark".
        :paramtype mode: str or ~affinda.models.ThemeConfigPaletteMode
        :keyword background: Anything.
        :paramtype background: any
        :keyword text:
        :paramtype text: ~affinda.models.ThemeConfigPaletteText
        :keyword divider:
        :paramtype divider: str
        :keyword primary:
        :paramtype primary: ~affinda.models.PaletteColorOptions
        :keyword secondary:
        :paramtype secondary: ~affinda.models.PaletteColorOptions
        :keyword success:
        :paramtype success: ~affinda.models.PaletteColorOptions
        :keyword annotation:
        :paramtype annotation: ~affinda.models.PaletteColorOptions
        :keyword error:
        :paramtype error: ~affinda.models.PaletteColorOptions
        :keyword info:
        :paramtype info: ~affinda.models.PaletteColorOptions
        :keyword warning:
        :paramtype warning: ~affinda.models.PaletteColorOptions
        """
        super(ThemeConfigPalette, self).__init__(**kwargs)
        self.mode = kwargs.get("mode", None)
        self.background = kwargs.get("background", None)
        self.text = kwargs.get("text", None)
        self.divider = kwargs.get("divider", None)
        self.primary = kwargs.get("primary", None)
        self.secondary = kwargs.get("secondary", None)
        self.success = kwargs.get("success", None)
        self.annotation = kwargs.get("annotation", None)
        self.error = kwargs.get("error", None)
        self.info = kwargs.get("info", None)
        self.warning = kwargs.get("warning", None)


class ThemeConfigPaletteText(msrest.serialization.Model):
    """ThemeConfigPaletteText.

    :ivar primary:
    :vartype primary: str
    :ivar secondary:
    :vartype secondary: str
    :ivar disabled:
    :vartype disabled: str
    """

    _attribute_map = {
        "primary": {"key": "primary", "type": "str"},
        "secondary": {"key": "secondary", "type": "str"},
        "disabled": {"key": "disabled", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword primary:
        :paramtype primary: str
        :keyword secondary:
        :paramtype secondary: str
        :keyword disabled:
        :paramtype disabled: str
        """
        super(ThemeConfigPaletteText, self).__init__(**kwargs)
        self.primary = kwargs.get("primary", None)
        self.secondary = kwargs.get("secondary", None)
        self.disabled = kwargs.get("disabled", None)


class ThemeConfigTypography(msrest.serialization.Model):
    """ThemeConfigTypography.

    :ivar font_family:
    :vartype font_family: str
    :ivar font_size: Anything.
    :vartype font_size: any
    :ivar font_weight_regular:
    :vartype font_weight_regular: str
    :ivar font_weight_medium:
    :vartype font_weight_medium: str
    :ivar font_weight_bold:
    :vartype font_weight_bold: str
    """

    _attribute_map = {
        "font_family": {"key": "fontFamily", "type": "str"},
        "font_size": {"key": "fontSize", "type": "object"},
        "font_weight_regular": {"key": "fontWeightRegular", "type": "str"},
        "font_weight_medium": {"key": "fontWeightMedium", "type": "str"},
        "font_weight_bold": {"key": "fontWeightBold", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword font_family:
        :paramtype font_family: str
        :keyword font_size: Anything.
        :paramtype font_size: any
        :keyword font_weight_regular:
        :paramtype font_weight_regular: str
        :keyword font_weight_medium:
        :paramtype font_weight_medium: str
        :keyword font_weight_bold:
        :paramtype font_weight_bold: str
        """
        super(ThemeConfigTypography, self).__init__(**kwargs)
        self.font_family = kwargs.get("font_family", None)
        self.font_size = kwargs.get("font_size", None)
        self.font_weight_regular = kwargs.get("font_weight_regular", None)
        self.font_weight_medium = kwargs.get("font_weight_medium", None)
        self.font_weight_bold = kwargs.get("font_weight_bold", None)


class UrlAnnotation(Annotation):
    """UrlAnnotation.

    All required parameters must be populated in order to send to Azure.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id: Required. Annotation's ID.
    :vartype id: int
    :ivar rectangle: Required. x/y coordinates for the rectangular bounding box containing the
     data.
    :vartype rectangle: ~affinda.models.Rectangle
    :ivar rectangles: Required. x/y coordinates for the rectangles containing the data. An
     annotation can be contained within multiple rectangles.
    :vartype rectangles: list[~affinda.models.Rectangle]
    :ivar document: Required. Unique identifier for the document.
    :vartype document: str
    :ivar page_index: Required. The page number within the document, starting from 0.
    :vartype page_index: int
    :ivar raw: Required. Raw data extracted from the before any post-processing.
    :vartype raw: str
    :ivar confidence: Required. The overall confidence that the model's prediction is correct.
    :vartype confidence: float
    :ivar classification_confidence: Required. The model's confidence that the text has been
     classified correctly.
    :vartype classification_confidence: float
    :ivar text_extraction_confidence: Required. If the document was submitted as an image, this is
     the confidence that the text in the image has been correctly read by the model.
    :vartype text_extraction_confidence: float
    :ivar is_verified: Required. Indicates whether the data has been validated, either by a human
     using our validation tool or through auto-validation rules.
    :vartype is_verified: bool
    :ivar is_client_verified: Required. Indicates whether the data has been validated by a human.
    :vartype is_client_verified: bool
    :ivar is_auto_verified: Required. Indicates whether the data has been auto-validated.
    :vartype is_auto_verified: bool
    :ivar data_point: Required. Data point's identifier.
    :vartype data_point: str
    :ivar content_type: Required. The different data types of annotations. Known values are:
     "text", "integer", "float", "decimal", "date", "datetime", "daterange", "boolean", "enum",
     "location", "phonenumber", "json", "table", "expectedremuneration", "jobtitle", "language",
     "skill", "yearsexperience", "group", "table_deprecated", "url", "image".
    :vartype content_type: str or ~affinda.models.AnnotationContentType
    :ivar parent: The parent annotation's ID.
    :vartype parent: int
    :ivar parsed:
    :vartype parsed: ~affinda.models.UrlAnnotationParsed
    """

    _validation = {
        "id": {"required": True, "minimum": 1},
        "rectangle": {"required": True},
        "rectangles": {"required": True},
        "document": {"required": True},
        "page_index": {"required": True, "minimum": 0},
        "raw": {"required": True},
        "confidence": {"required": True},
        "classification_confidence": {"required": True},
        "text_extraction_confidence": {"required": True},
        "is_verified": {"required": True},
        "is_client_verified": {"required": True},
        "is_auto_verified": {"required": True},
        "data_point": {"required": True},
        "content_type": {"required": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "int"},
        "rectangle": {"key": "rectangle", "type": "Rectangle"},
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "document": {"key": "document", "type": "str"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "confidence": {"key": "confidence", "type": "float"},
        "classification_confidence": {"key": "classificationConfidence", "type": "float"},
        "text_extraction_confidence": {"key": "textExtractionConfidence", "type": "float"},
        "is_verified": {"key": "isVerified", "type": "bool"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "is_auto_verified": {"key": "isAutoVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "content_type": {"key": "contentType", "type": "str"},
        "parent": {"key": "parent", "type": "int"},
        "parsed": {"key": "parsed", "type": "UrlAnnotationParsed"},
    }

    def __init__(self, **kwargs):
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword id: Required. Annotation's ID.
        :paramtype id: int
        :keyword rectangle: Required. x/y coordinates for the rectangular bounding box containing the
         data.
        :paramtype rectangle: ~affinda.models.Rectangle
        :keyword rectangles: Required. x/y coordinates for the rectangles containing the data. An
         annotation can be contained within multiple rectangles.
        :paramtype rectangles: list[~affinda.models.Rectangle]
        :keyword document: Required. Unique identifier for the document.
        :paramtype document: str
        :keyword page_index: Required. The page number within the document, starting from 0.
        :paramtype page_index: int
        :keyword raw: Required. Raw data extracted from the before any post-processing.
        :paramtype raw: str
        :keyword confidence: Required. The overall confidence that the model's prediction is correct.
        :paramtype confidence: float
        :keyword classification_confidence: Required. The model's confidence that the text has been
         classified correctly.
        :paramtype classification_confidence: float
        :keyword text_extraction_confidence: Required. If the document was submitted as an image, this
         is the confidence that the text in the image has been correctly read by the model.
        :paramtype text_extraction_confidence: float
        :keyword is_verified: Required. Indicates whether the data has been validated, either by a
         human using our validation tool or through auto-validation rules.
        :paramtype is_verified: bool
        :keyword is_client_verified: Required. Indicates whether the data has been validated by a
         human.
        :paramtype is_client_verified: bool
        :keyword is_auto_verified: Required. Indicates whether the data has been auto-validated.
        :paramtype is_auto_verified: bool
        :keyword data_point: Required. Data point's identifier.
        :paramtype data_point: str
        :keyword content_type: Required. The different data types of annotations. Known values are:
         "text", "integer", "float", "decimal", "date", "datetime", "daterange", "boolean", "enum",
         "location", "phonenumber", "json", "table", "expectedremuneration", "jobtitle", "language",
         "skill", "yearsexperience", "group", "table_deprecated", "url", "image".
        :paramtype content_type: str or ~affinda.models.AnnotationContentType
        :keyword parent: The parent annotation's ID.
        :paramtype parent: int
        :keyword parsed:
        :paramtype parsed: ~affinda.models.UrlAnnotationParsed
        """
        super(UrlAnnotation, self).__init__(**kwargs)
        self.parsed = kwargs.get("parsed", None)


class UrlAnnotationParsed(msrest.serialization.Model):
    """UrlAnnotationParsed.

    :ivar url:
    :vartype url: str
    :ivar domain:
    :vartype domain: str
    """

    _attribute_map = {
        "url": {"key": "url", "type": "str"},
        "domain": {"key": "domain", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword url:
        :paramtype url: str
        :keyword domain:
        :paramtype domain: str
        """
        super(UrlAnnotationParsed, self).__init__(**kwargs)
        self.url = kwargs.get("url", None)
        self.domain = kwargs.get("domain", None)


class UsageByCollection(msrest.serialization.Model):
    """Monthly credits consumption.

    All required parameters must be populated in order to send to Azure.

    :ivar month: Required. Month of the usage.
    :vartype month: str
    :ivar count: Required. Usage count.
    :vartype count: int
    """

    _validation = {
        "month": {"required": True},
        "count": {"required": True},
    }

    _attribute_map = {
        "month": {"key": "month", "type": "str"},
        "count": {"key": "count", "type": "int"},
    }

    def __init__(self, **kwargs):
        """
        :keyword month: Required. Month of the usage.
        :paramtype month: str
        :keyword count: Required. Usage count.
        :paramtype count: int
        """
        super(UsageByCollection, self).__init__(**kwargs)
        self.month = kwargs["month"]
        self.count = kwargs["count"]


class UsageByWorkspace(msrest.serialization.Model):
    """Monthly credits consumption.

    All required parameters must be populated in order to send to Azure.

    :ivar month: Required. Month of the usage.
    :vartype month: str
    :ivar count: Required. Usage count.
    :vartype count: int
    """

    _validation = {
        "month": {"required": True},
        "count": {"required": True},
    }

    _attribute_map = {
        "month": {"key": "month", "type": "str"},
        "count": {"key": "count", "type": "int"},
    }

    def __init__(self, **kwargs):
        """
        :keyword month: Required. Month of the usage.
        :paramtype month: str
        :keyword count: Required. Usage count.
        :paramtype count: int
        """
        super(UsageByWorkspace, self).__init__(**kwargs)
        self.month = kwargs["month"]
        self.count = kwargs["count"]


class UserNullable(msrest.serialization.Model):
    """UserNullable.

    :ivar id: Uniquely identify a user.
    :vartype id: int
    :ivar name:
    :vartype name: str
    :ivar username:
    :vartype username: str
    :ivar email:
    :vartype email: str
    :ivar avatar: URL of the user's avatar.
    :vartype avatar: str
    """

    _validation = {
        "id": {"minimum": 1},
    }

    _attribute_map = {
        "id": {"key": "id", "type": "int"},
        "name": {"key": "name", "type": "str"},
        "username": {"key": "username", "type": "str"},
        "email": {"key": "email", "type": "str"},
        "avatar": {"key": "avatar", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword id: Uniquely identify a user.
        :paramtype id: int
        :keyword name:
        :paramtype name: str
        :keyword username:
        :paramtype username: str
        :keyword email:
        :paramtype email: str
        :keyword avatar: URL of the user's avatar.
        :paramtype avatar: str
        """
        super(UserNullable, self).__init__(**kwargs)
        self.id = kwargs.get("id", None)
        self.name = kwargs.get("name", None)
        self.username = kwargs.get("username", None)
        self.email = kwargs.get("email", None)
        self.avatar = kwargs.get("avatar", None)


class ValidationResult(msrest.serialization.Model):
    """Validation result arising from a ValidationRule.

    All required parameters must be populated in order to send to Azure.

    :ivar id: Required. Validation Result's ID.
    :vartype id: int
    :ivar annotations: Required. List of annotation ids that were validated.
    :vartype annotations: list[int]
    :ivar passed: Required. Whether the validation passed or not, null if the validation was not
     applicable.
    :vartype passed: bool
    :ivar rule_slug: Required. The hot-dog case slug of the validation rule that was applied.
    :vartype rule_slug: str
    :ivar message: Required. Message explaining why the validation failed.
    :vartype message: str
    :ivar document: Required. Unique identifier for the document.
    :vartype document: str
    """

    _validation = {
        "id": {"required": True, "minimum": 1},
        "annotations": {"required": True},
        "passed": {"required": True},
        "rule_slug": {"required": True, "pattern": r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"},
        "message": {"required": True},
        "document": {"required": True},
    }

    _attribute_map = {
        "id": {"key": "id", "type": "int"},
        "annotations": {"key": "annotations", "type": "[int]"},
        "passed": {"key": "passed", "type": "bool"},
        "rule_slug": {"key": "ruleSlug", "type": "str"},
        "message": {"key": "message", "type": "str"},
        "document": {"key": "document", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword id: Required. Validation Result's ID.
        :paramtype id: int
        :keyword annotations: Required. List of annotation ids that were validated.
        :paramtype annotations: list[int]
        :keyword passed: Required. Whether the validation passed or not, null if the validation was not
         applicable.
        :paramtype passed: bool
        :keyword rule_slug: Required. The hot-dog case slug of the validation rule that was applied.
        :paramtype rule_slug: str
        :keyword message: Required. Message explaining why the validation failed.
        :paramtype message: str
        :keyword document: Required. Unique identifier for the document.
        :paramtype document: str
        """
        super(ValidationResult, self).__init__(**kwargs)
        self.id = kwargs["id"]
        self.annotations = kwargs["annotations"]
        self.passed = kwargs["passed"]
        self.rule_slug = kwargs["rule_slug"]
        self.message = kwargs["message"]
        self.document = kwargs["document"]


class ValidationResultCreate(msrest.serialization.Model):
    """ValidationResultCreate.

    All required parameters must be populated in order to send to Azure.

    :ivar annotations: Required. List of annotation ids that were validated.
    :vartype annotations: list[int]
    :ivar passed: Whether the validation passed or not, null if the validation was not applicable.
    :vartype passed: bool
    :ivar rule_slug: Required. The hot-dog case slug of the validation rule that was applied.
    :vartype rule_slug: str
    :ivar message: Required. Message explaining why the validation failed.
    :vartype message: str
    :ivar document: Required. Unique identifier for the document.
    :vartype document: str
    """

    _validation = {
        "annotations": {"required": True},
        "rule_slug": {"required": True, "pattern": r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"},
        "message": {"required": True},
        "document": {"required": True},
    }

    _attribute_map = {
        "annotations": {"key": "annotations", "type": "[int]"},
        "passed": {"key": "passed", "type": "bool"},
        "rule_slug": {"key": "ruleSlug", "type": "str"},
        "message": {"key": "message", "type": "str"},
        "document": {"key": "document", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword annotations: Required. List of annotation ids that were validated.
        :paramtype annotations: list[int]
        :keyword passed: Whether the validation passed or not, null if the validation was not
         applicable.
        :paramtype passed: bool
        :keyword rule_slug: Required. The hot-dog case slug of the validation rule that was applied.
        :paramtype rule_slug: str
        :keyword message: Required. Message explaining why the validation failed.
        :paramtype message: str
        :keyword document: Required. Unique identifier for the document.
        :paramtype document: str
        """
        super(ValidationResultCreate, self).__init__(**kwargs)
        self.annotations = kwargs["annotations"]
        self.passed = kwargs.get("passed", None)
        self.rule_slug = kwargs["rule_slug"]
        self.message = kwargs["message"]
        self.document = kwargs["document"]


class ValidationResultUpdate(msrest.serialization.Model):
    """ValidationResultUpdate.

    :ivar annotations: List of annotation ids that were validated.
    :vartype annotations: list[int]
    :ivar passed: Whether the validation passed or not, null if the validation was not applicable.
    :vartype passed: bool
    :ivar rule_slug: The hot-dog case slug of the validation rule that was applied.
    :vartype rule_slug: str
    :ivar message: Message explaining why the validation failed.
    :vartype message: str
    :ivar document: Unique identifier for the document.
    :vartype document: str
    """

    _validation = {
        "rule_slug": {"pattern": r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"},
    }

    _attribute_map = {
        "annotations": {"key": "annotations", "type": "[int]"},
        "passed": {"key": "passed", "type": "bool"},
        "rule_slug": {"key": "ruleSlug", "type": "str"},
        "message": {"key": "message", "type": "str"},
        "document": {"key": "document", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword annotations: List of annotation ids that were validated.
        :paramtype annotations: list[int]
        :keyword passed: Whether the validation passed or not, null if the validation was not
         applicable.
        :paramtype passed: bool
        :keyword rule_slug: The hot-dog case slug of the validation rule that was applied.
        :paramtype rule_slug: str
        :keyword message: Message explaining why the validation failed.
        :paramtype message: str
        :keyword document: Unique identifier for the document.
        :paramtype document: str
        """
        super(ValidationResultUpdate, self).__init__(**kwargs)
        self.annotations = kwargs.get("annotations", None)
        self.passed = kwargs.get("passed", None)
        self.rule_slug = kwargs.get("rule_slug", None)
        self.message = kwargs.get("message", None)
        self.document = kwargs.get("document", None)


class ValidationRule(msrest.serialization.Model):
    """A validation rule for a collection.

    All required parameters must be populated in order to send to Azure.

    :ivar slug: Required. The slug of the validation rule, in lowercase snake_case.
    :vartype slug: str
    :ivar data_points: Required. The data point identifier that this validation rule applies to,
     can be an empty list if the rule doens't use any data points as sources.
    :vartype data_points: list[str]
    """

    _validation = {
        "slug": {"required": True, "pattern": r"^[a-z0-9_]+$"},
        "data_points": {"required": True},
    }

    _attribute_map = {
        "slug": {"key": "slug", "type": "str"},
        "data_points": {"key": "dataPoints", "type": "[str]"},
    }

    def __init__(self, **kwargs):
        """
        :keyword slug: Required. The slug of the validation rule, in lowercase snake_case.
        :paramtype slug: str
        :keyword data_points: Required. The data point identifier that this validation rule applies to,
         can be an empty list if the rule doens't use any data points as sources.
        :paramtype data_points: list[str]
        """
        super(ValidationRule, self).__init__(**kwargs)
        self.slug = kwargs["slug"]
        self.data_points = kwargs["data_points"]


class ValidationToolConfig(msrest.serialization.Model):
    """Configuration of the embeddable validation tool.

    :ivar theme:
    :vartype theme: ~affinda.models.ThemeConfig
    :ivar hide_actions: Hide the confirm document button and other actions.
    :vartype hide_actions: bool
    :ivar hide_collection: Hide the collection selector.
    :vartype hide_collection: bool
    :ivar hide_edit_pages: Hide the edit pages button.
    :vartype hide_edit_pages: bool
    :ivar hide_export: Hide the export menu.
    :vartype hide_export: bool
    :ivar hide_filename: Hide the filename input.
    :vartype hide_filename: bool
    :ivar hide_reject: Hide the reject document button.
    :vartype hide_reject: bool
    :ivar hide_reparse: Hide the reparse button.
    :vartype hide_reparse: bool
    :ivar hide_run_ocr: Hide the run OCR button.
    :vartype hide_run_ocr: bool
    :ivar hide_tags: Hide the tags editor.
    :vartype hide_tags: bool
    :ivar hide_warnings: Hide the warnings panel.
    :vartype hide_warnings: bool
    :ivar restrict_document_splitting: Disable the page editor after a document has been split
     once.
    :vartype restrict_document_splitting: bool
    :ivar disable_currency_formatting: Disable currency formatting of decimals values.
    :vartype disable_currency_formatting: bool
    :ivar disable_edit_document_metadata: Disable editing document metadata. Makes the collection
     selector, filename input and tags editor read only.
    :vartype disable_edit_document_metadata: bool
    """

    _attribute_map = {
        "theme": {"key": "theme", "type": "ThemeConfig"},
        "hide_actions": {"key": "hideActions", "type": "bool"},
        "hide_collection": {"key": "hideCollection", "type": "bool"},
        "hide_edit_pages": {"key": "hideEditPages", "type": "bool"},
        "hide_export": {"key": "hideExport", "type": "bool"},
        "hide_filename": {"key": "hideFilename", "type": "bool"},
        "hide_reject": {"key": "hideReject", "type": "bool"},
        "hide_reparse": {"key": "hideReparse", "type": "bool"},
        "hide_run_ocr": {"key": "hideRunOcr", "type": "bool"},
        "hide_tags": {"key": "hideTags", "type": "bool"},
        "hide_warnings": {"key": "hideWarnings", "type": "bool"},
        "restrict_document_splitting": {"key": "restrictDocumentSplitting", "type": "bool"},
        "disable_currency_formatting": {"key": "disableCurrencyFormatting", "type": "bool"},
        "disable_edit_document_metadata": {"key": "disableEditDocumentMetadata", "type": "bool"},
    }

    def __init__(self, **kwargs):
        """
        :keyword theme:
        :paramtype theme: ~affinda.models.ThemeConfig
        :keyword hide_actions: Hide the confirm document button and other actions.
        :paramtype hide_actions: bool
        :keyword hide_collection: Hide the collection selector.
        :paramtype hide_collection: bool
        :keyword hide_edit_pages: Hide the edit pages button.
        :paramtype hide_edit_pages: bool
        :keyword hide_export: Hide the export menu.
        :paramtype hide_export: bool
        :keyword hide_filename: Hide the filename input.
        :paramtype hide_filename: bool
        :keyword hide_reject: Hide the reject document button.
        :paramtype hide_reject: bool
        :keyword hide_reparse: Hide the reparse button.
        :paramtype hide_reparse: bool
        :keyword hide_run_ocr: Hide the run OCR button.
        :paramtype hide_run_ocr: bool
        :keyword hide_tags: Hide the tags editor.
        :paramtype hide_tags: bool
        :keyword hide_warnings: Hide the warnings panel.
        :paramtype hide_warnings: bool
        :keyword restrict_document_splitting: Disable the page editor after a document has been split
         once.
        :paramtype restrict_document_splitting: bool
        :keyword disable_currency_formatting: Disable currency formatting of decimals values.
        :paramtype disable_currency_formatting: bool
        :keyword disable_edit_document_metadata: Disable editing document metadata. Makes the
         collection selector, filename input and tags editor read only.
        :paramtype disable_edit_document_metadata: bool
        """
        super(ValidationToolConfig, self).__init__(**kwargs)
        self.theme = kwargs.get("theme", None)
        self.hide_actions = kwargs.get("hide_actions", None)
        self.hide_collection = kwargs.get("hide_collection", None)
        self.hide_edit_pages = kwargs.get("hide_edit_pages", None)
        self.hide_export = kwargs.get("hide_export", None)
        self.hide_filename = kwargs.get("hide_filename", None)
        self.hide_reject = kwargs.get("hide_reject", None)
        self.hide_reparse = kwargs.get("hide_reparse", None)
        self.hide_run_ocr = kwargs.get("hide_run_ocr", None)
        self.hide_tags = kwargs.get("hide_tags", None)
        self.hide_warnings = kwargs.get("hide_warnings", None)
        self.restrict_document_splitting = kwargs.get("restrict_document_splitting", None)
        self.disable_currency_formatting = kwargs.get("disable_currency_formatting", None)
        self.disable_edit_document_metadata = kwargs.get("disable_edit_document_metadata", None)


class Workspace(msrest.serialization.Model):
    """Workspace.

    All required parameters must be populated in order to send to Azure.

    :ivar identifier: Required. Uniquely identify a workspace.
    :vartype identifier: str
    :ivar organization:
    :vartype organization: ~affinda.models.Organization
    :ivar name:
    :vartype name: str
    :ivar visibility: Visibility "organization" means everyone in the organization can access the
     workspace. Visibility "private" means only people explicitly added can access the workspace.
     Known values are: "organization", "private".
    :vartype visibility: str or ~affinda.models.WorkspaceVisibility
    :ivar collections:
    :vartype collections: list[~affinda.models.WorkspaceCollectionsItem]
    :ivar reject_invalid_documents: If true, the uploaded document will be rejected if it's of the
     wrong document type, or if its document type cannot be determined. No credits will be consumed.
    :vartype reject_invalid_documents: bool
    :ivar reject_duplicates: If "true", parsing will fail when the uploaded document is duplicate
     of an existing document, no credits will be consumed. If "false", will parse the document
     normally whether its a duplicate or not. If not provided, will fallback to the workspace
     settings.
    :vartype reject_duplicates: bool
    :ivar members:
    :vartype members: list[~affinda.models.User]
    :ivar unvalidated_docs_count: Number of unvalidated documents in the workspace.
    :vartype unvalidated_docs_count: int
    :ivar confirmed_docs_count: Number of validated documents in the workspace.
    :vartype confirmed_docs_count: int
    :ivar ingest_email: When you send email to this address, any document attached in the body will
     be uploaded to this workspace.
    :vartype ingest_email: str
    :ivar whitelist_ingest_addresses: If specified, only emails from these addresses will be
     ingested for parsing. Wild cards are allowed, e.g. "*@eyefind.info".
    :vartype whitelist_ingest_addresses: list[str]
    :ivar document_splitter: Option "leave" means no document splitting at all. Option
     "conservative" means we don't actually split documents the documents, but will add a warning to
     documents that may require a split. Option "recommended" means we split documents that are
     highly likely to require a split, and add warnings to documents that might require one. Option
     "aggressive" means we split all documents that are likely to require a split. Known values are:
     "leave", "conservative", "recommended", "aggressive".
    :vartype document_splitter: str or ~affinda.models.WorkspaceSplitDocumentsOptions
    """

    _validation = {
        "identifier": {"required": True},
        "unvalidated_docs_count": {"minimum": 0},
        "confirmed_docs_count": {"minimum": 0},
    }

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
        "organization": {"key": "organization", "type": "Organization"},
        "name": {"key": "name", "type": "str"},
        "visibility": {"key": "visibility", "type": "str"},
        "collections": {"key": "collections", "type": "[WorkspaceCollectionsItem]"},
        "reject_invalid_documents": {"key": "rejectInvalidDocuments", "type": "bool"},
        "reject_duplicates": {"key": "rejectDuplicates", "type": "bool"},
        "members": {"key": "members", "type": "[User]"},
        "unvalidated_docs_count": {"key": "unvalidatedDocsCount", "type": "int"},
        "confirmed_docs_count": {"key": "confirmedDocsCount", "type": "int"},
        "ingest_email": {"key": "ingestEmail", "type": "str"},
        "whitelist_ingest_addresses": {"key": "whitelistIngestAddresses", "type": "[str]"},
        "document_splitter": {"key": "documentSplitter", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword identifier: Required. Uniquely identify a workspace.
        :paramtype identifier: str
        :keyword organization:
        :paramtype organization: ~affinda.models.Organization
        :keyword name:
        :paramtype name: str
        :keyword visibility: Visibility "organization" means everyone in the organization can access
         the workspace. Visibility "private" means only people explicitly added can access the
         workspace. Known values are: "organization", "private".
        :paramtype visibility: str or ~affinda.models.WorkspaceVisibility
        :keyword collections:
        :paramtype collections: list[~affinda.models.WorkspaceCollectionsItem]
        :keyword reject_invalid_documents: If true, the uploaded document will be rejected if it's of
         the wrong document type, or if its document type cannot be determined. No credits will be
         consumed.
        :paramtype reject_invalid_documents: bool
        :keyword reject_duplicates: If "true", parsing will fail when the uploaded document is
         duplicate of an existing document, no credits will be consumed. If "false", will parse the
         document normally whether its a duplicate or not. If not provided, will fallback to the
         workspace settings.
        :paramtype reject_duplicates: bool
        :keyword members:
        :paramtype members: list[~affinda.models.User]
        :keyword unvalidated_docs_count: Number of unvalidated documents in the workspace.
        :paramtype unvalidated_docs_count: int
        :keyword confirmed_docs_count: Number of validated documents in the workspace.
        :paramtype confirmed_docs_count: int
        :keyword ingest_email: When you send email to this address, any document attached in the body
         will be uploaded to this workspace.
        :paramtype ingest_email: str
        :keyword whitelist_ingest_addresses: If specified, only emails from these addresses will be
         ingested for parsing. Wild cards are allowed, e.g. "*@eyefind.info".
        :paramtype whitelist_ingest_addresses: list[str]
        :keyword document_splitter: Option "leave" means no document splitting at all. Option
         "conservative" means we don't actually split documents the documents, but will add a warning to
         documents that may require a split. Option "recommended" means we split documents that are
         highly likely to require a split, and add warnings to documents that might require one. Option
         "aggressive" means we split all documents that are likely to require a split. Known values are:
         "leave", "conservative", "recommended", "aggressive".
        :paramtype document_splitter: str or ~affinda.models.WorkspaceSplitDocumentsOptions
        """
        super(Workspace, self).__init__(**kwargs)
        self.identifier = kwargs["identifier"]
        self.organization = kwargs.get("organization", None)
        self.name = kwargs.get("name", None)
        self.visibility = kwargs.get("visibility", None)
        self.collections = kwargs.get("collections", None)
        self.reject_invalid_documents = kwargs.get("reject_invalid_documents", None)
        self.reject_duplicates = kwargs.get("reject_duplicates", None)
        self.members = kwargs.get("members", None)
        self.unvalidated_docs_count = kwargs.get("unvalidated_docs_count", None)
        self.confirmed_docs_count = kwargs.get("confirmed_docs_count", None)
        self.ingest_email = kwargs.get("ingest_email", None)
        self.whitelist_ingest_addresses = kwargs.get("whitelist_ingest_addresses", None)
        self.document_splitter = kwargs.get("document_splitter", None)


class WorkspaceCollectionsItem(msrest.serialization.Model):
    """WorkspaceCollectionsItem.

    All required parameters must be populated in order to send to Azure.

    :ivar identifier: Required. Uniquely identify a collection.
    :vartype identifier: str
    :ivar name: Required.
    :vartype name: str
    :ivar extractor: Required.
    :vartype extractor: ~affinda.models.WorkspaceCollectionsItemExtractor
    :ivar unvalidated_docs_count: Number of unvalidated documents in the collection.
    :vartype unvalidated_docs_count: int
    :ivar confirmed_docs_count: Number of validated documents in the collection.
    :vartype confirmed_docs_count: int
    """

    _validation = {
        "identifier": {"required": True},
        "name": {"required": True},
        "extractor": {"required": True},
        "unvalidated_docs_count": {"minimum": 0},
        "confirmed_docs_count": {"minimum": 0},
    }

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "extractor": {"key": "extractor", "type": "WorkspaceCollectionsItemExtractor"},
        "unvalidated_docs_count": {"key": "unvalidatedDocsCount", "type": "int"},
        "confirmed_docs_count": {"key": "confirmedDocsCount", "type": "int"},
    }

    def __init__(self, **kwargs):
        """
        :keyword identifier: Required. Uniquely identify a collection.
        :paramtype identifier: str
        :keyword name: Required.
        :paramtype name: str
        :keyword extractor: Required.
        :paramtype extractor: ~affinda.models.WorkspaceCollectionsItemExtractor
        :keyword unvalidated_docs_count: Number of unvalidated documents in the collection.
        :paramtype unvalidated_docs_count: int
        :keyword confirmed_docs_count: Number of validated documents in the collection.
        :paramtype confirmed_docs_count: int
        """
        super(WorkspaceCollectionsItem, self).__init__(**kwargs)
        self.identifier = kwargs["identifier"]
        self.name = kwargs["name"]
        self.extractor = kwargs["extractor"]
        self.unvalidated_docs_count = kwargs.get("unvalidated_docs_count", None)
        self.confirmed_docs_count = kwargs.get("confirmed_docs_count", None)


class WorkspaceCollectionsItemExtractor(msrest.serialization.Model):
    """WorkspaceCollectionsItemExtractor.

    All required parameters must be populated in order to send to Azure.

    :ivar identifier: Required. Uniquely identify an extractor.
    :vartype identifier: str
    :ivar name: Required.
    :vartype name: str
    :ivar name_plural: Required.
    :vartype name_plural: str
    :ivar base_extractor:
    :vartype base_extractor: ~affinda.models.BaseExtractor
    :ivar category:
    :vartype category: str
    :ivar validatable: Required.
    :vartype validatable: bool
    :ivar is_custom:
    :vartype is_custom: bool
    :ivar created_dt:
    :vartype created_dt: ~datetime.datetime
    """

    _validation = {
        "identifier": {"required": True},
        "name": {"required": True},
        "name_plural": {"required": True},
        "validatable": {"required": True},
    }

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "name_plural": {"key": "namePlural", "type": "str"},
        "base_extractor": {"key": "baseExtractor", "type": "BaseExtractor"},
        "category": {"key": "category", "type": "str"},
        "validatable": {"key": "validatable", "type": "bool"},
        "is_custom": {"key": "isCustom", "type": "bool"},
        "created_dt": {"key": "createdDt", "type": "iso-8601"},
    }

    def __init__(self, **kwargs):
        """
        :keyword identifier: Required. Uniquely identify an extractor.
        :paramtype identifier: str
        :keyword name: Required.
        :paramtype name: str
        :keyword name_plural: Required.
        :paramtype name_plural: str
        :keyword base_extractor:
        :paramtype base_extractor: ~affinda.models.BaseExtractor
        :keyword category:
        :paramtype category: str
        :keyword validatable: Required.
        :paramtype validatable: bool
        :keyword is_custom:
        :paramtype is_custom: bool
        :keyword created_dt:
        :paramtype created_dt: ~datetime.datetime
        """
        super(WorkspaceCollectionsItemExtractor, self).__init__(**kwargs)
        self.identifier = kwargs["identifier"]
        self.name = kwargs["name"]
        self.name_plural = kwargs["name_plural"]
        self.base_extractor = kwargs.get("base_extractor", None)
        self.category = kwargs.get("category", None)
        self.validatable = kwargs["validatable"]
        self.is_custom = kwargs.get("is_custom", None)
        self.created_dt = kwargs.get("created_dt", None)


class WorkspaceCreate(msrest.serialization.Model):
    """WorkspaceCreate.

    All required parameters must be populated in order to send to Azure.

    :ivar organization: Required. Uniquely identify an organization.
    :vartype organization: str
    :ivar name: Required.
    :vartype name: str
    :ivar visibility: Visibility "organization" means everyone in the organization can access the
     workspace. Visibility "private" means only people explicitly added can access the workspace.
     Known values are: "organization", "private".
    :vartype visibility: str or ~affinda.models.WorkspaceVisibility
    :ivar reject_invalid_documents: If true, the uploaded document will be rejected if it's of the
     wrong document type, or if its document type cannot be determined. No credits will be consumed.
    :vartype reject_invalid_documents: bool
    :ivar reject_duplicates: If "true", parsing will fail when the uploaded document is duplicate
     of an existing document, no credits will be consumed. If "false", will parse the document
     normally whether its a duplicate or not. If not provided, will fallback to the workspace
     settings.
    :vartype reject_duplicates: bool
    :ivar whitelist_ingest_addresses: If specified, only emails from these addresses will be
     ingested for parsing. Wild cards are allowed, e.g. "*@eyefind.info".
    :vartype whitelist_ingest_addresses: list[str]
    :ivar document_splitter: Option "leave" means no document splitting at all. Option
     "conservative" means we don't actually split documents the documents, but will add a warning to
     documents that may require a split. Option "recommended" means we split documents that are
     highly likely to require a split, and add warnings to documents that might require one. Option
     "aggressive" means we split all documents that are likely to require a split. Known values are:
     "leave", "conservative", "recommended", "aggressive".
    :vartype document_splitter: str or ~affinda.models.WorkspaceSplitDocumentsOptions
    """

    _validation = {
        "organization": {"required": True},
        "name": {"required": True},
    }

    _attribute_map = {
        "organization": {"key": "organization", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "visibility": {"key": "visibility", "type": "str"},
        "reject_invalid_documents": {"key": "rejectInvalidDocuments", "type": "bool"},
        "reject_duplicates": {"key": "rejectDuplicates", "type": "bool"},
        "whitelist_ingest_addresses": {"key": "whitelistIngestAddresses", "type": "[str]"},
        "document_splitter": {"key": "documentSplitter", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword organization: Required. Uniquely identify an organization.
        :paramtype organization: str
        :keyword name: Required.
        :paramtype name: str
        :keyword visibility: Visibility "organization" means everyone in the organization can access
         the workspace. Visibility "private" means only people explicitly added can access the
         workspace. Known values are: "organization", "private".
        :paramtype visibility: str or ~affinda.models.WorkspaceVisibility
        :keyword reject_invalid_documents: If true, the uploaded document will be rejected if it's of
         the wrong document type, or if its document type cannot be determined. No credits will be
         consumed.
        :paramtype reject_invalid_documents: bool
        :keyword reject_duplicates: If "true", parsing will fail when the uploaded document is
         duplicate of an existing document, no credits will be consumed. If "false", will parse the
         document normally whether its a duplicate or not. If not provided, will fallback to the
         workspace settings.
        :paramtype reject_duplicates: bool
        :keyword whitelist_ingest_addresses: If specified, only emails from these addresses will be
         ingested for parsing. Wild cards are allowed, e.g. "*@eyefind.info".
        :paramtype whitelist_ingest_addresses: list[str]
        :keyword document_splitter: Option "leave" means no document splitting at all. Option
         "conservative" means we don't actually split documents the documents, but will add a warning to
         documents that may require a split. Option "recommended" means we split documents that are
         highly likely to require a split, and add warnings to documents that might require one. Option
         "aggressive" means we split all documents that are likely to require a split. Known values are:
         "leave", "conservative", "recommended", "aggressive".
        :paramtype document_splitter: str or ~affinda.models.WorkspaceSplitDocumentsOptions
        """
        super(WorkspaceCreate, self).__init__(**kwargs)
        self.organization = kwargs["organization"]
        self.name = kwargs["name"]
        self.visibility = kwargs.get("visibility", None)
        self.reject_invalid_documents = kwargs.get("reject_invalid_documents", None)
        self.reject_duplicates = kwargs.get("reject_duplicates", None)
        self.whitelist_ingest_addresses = kwargs.get("whitelist_ingest_addresses", None)
        self.document_splitter = kwargs.get("document_splitter", None)


class WorkspaceMembership(msrest.serialization.Model):
    """WorkspaceMembership.

    :ivar identifier: Uniquely identify a membership.
    :vartype identifier: str
    :ivar workspace: Uniquely identify a workspace.
    :vartype workspace: str
    :ivar user:
    :vartype user: ~affinda.models.User
    """

    _attribute_map = {
        "identifier": {"key": "identifier", "type": "str"},
        "workspace": {"key": "workspace", "type": "str"},
        "user": {"key": "user", "type": "User"},
    }

    def __init__(self, **kwargs):
        """
        :keyword identifier: Uniquely identify a membership.
        :paramtype identifier: str
        :keyword workspace: Uniquely identify a workspace.
        :paramtype workspace: str
        :keyword user:
        :paramtype user: ~affinda.models.User
        """
        super(WorkspaceMembership, self).__init__(**kwargs)
        self.identifier = kwargs.get("identifier", None)
        self.workspace = kwargs.get("workspace", None)
        self.user = kwargs.get("user", None)


class WorkspaceMembershipCreate(msrest.serialization.Model):
    """WorkspaceMembershipCreate.

    :ivar workspace: Uniquely identify a workspace.
    :vartype workspace: str
    :ivar user: Uniquely identify a user.
    :vartype user: int
    """

    _validation = {
        "user": {"minimum": 1},
    }

    _attribute_map = {
        "workspace": {"key": "workspace", "type": "str"},
        "user": {"key": "user", "type": "int"},
    }

    def __init__(self, **kwargs):
        """
        :keyword workspace: Uniquely identify a workspace.
        :paramtype workspace: str
        :keyword user: Uniquely identify a user.
        :paramtype user: int
        """
        super(WorkspaceMembershipCreate, self).__init__(**kwargs)
        self.workspace = kwargs.get("workspace", None)
        self.user = kwargs.get("user", None)


class WorkspaceUpdate(msrest.serialization.Model):
    """WorkspaceUpdate.

    :ivar name:
    :vartype name: str
    :ivar visibility: Visibility "organization" means everyone in the organization can access the
     workspace. Visibility "private" means only people explicitly added can access the workspace.
     Known values are: "organization", "private".
    :vartype visibility: str or ~affinda.models.WorkspaceVisibility
    :ivar reject_invalid_documents: If true, the uploaded document will be rejected if it's of the
     wrong document type, or if its document type cannot be determined. No credits will be consumed.
    :vartype reject_invalid_documents: bool
    :ivar reject_duplicates: If "true", parsing will fail when the uploaded document is duplicate
     of an existing document, no credits will be consumed. If "false", will parse the document
     normally whether its a duplicate or not. If not provided, will fallback to the workspace
     settings.
    :vartype reject_duplicates: bool
    :ivar whitelist_ingest_addresses: If specified, only emails from these addresses will be
     ingested for parsing. Wild cards are allowed, e.g. "*@eyefind.info".
    :vartype whitelist_ingest_addresses: list[str]
    :ivar document_splitter: Option "leave" means no document splitting at all. Option
     "conservative" means we don't actually split documents the documents, but will add a warning to
     documents that may require a split. Option "recommended" means we split documents that are
     highly likely to require a split, and add warnings to documents that might require one. Option
     "aggressive" means we split all documents that are likely to require a split. Known values are:
     "leave", "conservative", "recommended", "aggressive".
    :vartype document_splitter: str or ~affinda.models.WorkspaceSplitDocumentsOptions
    """

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "visibility": {"key": "visibility", "type": "str"},
        "reject_invalid_documents": {"key": "rejectInvalidDocuments", "type": "bool"},
        "reject_duplicates": {"key": "rejectDuplicates", "type": "bool"},
        "whitelist_ingest_addresses": {"key": "whitelistIngestAddresses", "type": "[str]"},
        "document_splitter": {"key": "documentSplitter", "type": "str"},
    }

    def __init__(self, **kwargs):
        """
        :keyword name:
        :paramtype name: str
        :keyword visibility: Visibility "organization" means everyone in the organization can access
         the workspace. Visibility "private" means only people explicitly added can access the
         workspace. Known values are: "organization", "private".
        :paramtype visibility: str or ~affinda.models.WorkspaceVisibility
        :keyword reject_invalid_documents: If true, the uploaded document will be rejected if it's of
         the wrong document type, or if its document type cannot be determined. No credits will be
         consumed.
        :paramtype reject_invalid_documents: bool
        :keyword reject_duplicates: If "true", parsing will fail when the uploaded document is
         duplicate of an existing document, no credits will be consumed. If "false", will parse the
         document normally whether its a duplicate or not. If not provided, will fallback to the
         workspace settings.
        :paramtype reject_duplicates: bool
        :keyword whitelist_ingest_addresses: If specified, only emails from these addresses will be
         ingested for parsing. Wild cards are allowed, e.g. "*@eyefind.info".
        :paramtype whitelist_ingest_addresses: list[str]
        :keyword document_splitter: Option "leave" means no document splitting at all. Option
         "conservative" means we don't actually split documents the documents, but will add a warning to
         documents that may require a split. Option "recommended" means we split documents that are
         highly likely to require a split, and add warnings to documents that might require one. Option
         "aggressive" means we split all documents that are likely to require a split. Known values are:
         "leave", "conservative", "recommended", "aggressive".
        :paramtype document_splitter: str or ~affinda.models.WorkspaceSplitDocumentsOptions
        """
        super(WorkspaceUpdate, self).__init__(**kwargs)
        self.name = kwargs.get("name", None)
        self.visibility = kwargs.get("visibility", None)
        self.reject_invalid_documents = kwargs.get("reject_invalid_documents", None)
        self.reject_duplicates = kwargs.get("reject_duplicates", None)
        self.whitelist_ingest_addresses = kwargs.get("whitelist_ingest_addresses", None)
        self.document_splitter = kwargs.get("document_splitter", None)


class YearsExperienceAnnotation(Annotation):
    """YearsExperienceAnnotation.

    All required parameters must be populated in order to send to Azure.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id: Required. Annotation's ID.
    :vartype id: int
    :ivar rectangle: Required. x/y coordinates for the rectangular bounding box containing the
     data.
    :vartype rectangle: ~affinda.models.Rectangle
    :ivar rectangles: Required. x/y coordinates for the rectangles containing the data. An
     annotation can be contained within multiple rectangles.
    :vartype rectangles: list[~affinda.models.Rectangle]
    :ivar document: Required. Unique identifier for the document.
    :vartype document: str
    :ivar page_index: Required. The page number within the document, starting from 0.
    :vartype page_index: int
    :ivar raw: Required. Raw data extracted from the before any post-processing.
    :vartype raw: str
    :ivar confidence: Required. The overall confidence that the model's prediction is correct.
    :vartype confidence: float
    :ivar classification_confidence: Required. The model's confidence that the text has been
     classified correctly.
    :vartype classification_confidence: float
    :ivar text_extraction_confidence: Required. If the document was submitted as an image, this is
     the confidence that the text in the image has been correctly read by the model.
    :vartype text_extraction_confidence: float
    :ivar is_verified: Required. Indicates whether the data has been validated, either by a human
     using our validation tool or through auto-validation rules.
    :vartype is_verified: bool
    :ivar is_client_verified: Required. Indicates whether the data has been validated by a human.
    :vartype is_client_verified: bool
    :ivar is_auto_verified: Required. Indicates whether the data has been auto-validated.
    :vartype is_auto_verified: bool
    :ivar data_point: Required. Data point's identifier.
    :vartype data_point: str
    :ivar content_type: Required. The different data types of annotations. Known values are:
     "text", "integer", "float", "decimal", "date", "datetime", "daterange", "boolean", "enum",
     "location", "phonenumber", "json", "table", "expectedremuneration", "jobtitle", "language",
     "skill", "yearsexperience", "group", "table_deprecated", "url", "image".
    :vartype content_type: str or ~affinda.models.AnnotationContentType
    :ivar parent: The parent annotation's ID.
    :vartype parent: int
    :ivar parsed: Years of experience range.
    :vartype parsed: ~affinda.models.YearsExperienceAnnotationParsed
    """

    _validation = {
        "id": {"required": True, "minimum": 1},
        "rectangle": {"required": True},
        "rectangles": {"required": True},
        "document": {"required": True},
        "page_index": {"required": True, "minimum": 0},
        "raw": {"required": True},
        "confidence": {"required": True},
        "classification_confidence": {"required": True},
        "text_extraction_confidence": {"required": True},
        "is_verified": {"required": True},
        "is_client_verified": {"required": True},
        "is_auto_verified": {"required": True},
        "data_point": {"required": True},
        "content_type": {"required": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "int"},
        "rectangle": {"key": "rectangle", "type": "Rectangle"},
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "document": {"key": "document", "type": "str"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "confidence": {"key": "confidence", "type": "float"},
        "classification_confidence": {"key": "classificationConfidence", "type": "float"},
        "text_extraction_confidence": {"key": "textExtractionConfidence", "type": "float"},
        "is_verified": {"key": "isVerified", "type": "bool"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "is_auto_verified": {"key": "isAutoVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "content_type": {"key": "contentType", "type": "str"},
        "parent": {"key": "parent", "type": "int"},
        "parsed": {"key": "parsed", "type": "YearsExperienceAnnotationParsed"},
    }

    def __init__(self, **kwargs):
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword id: Required. Annotation's ID.
        :paramtype id: int
        :keyword rectangle: Required. x/y coordinates for the rectangular bounding box containing the
         data.
        :paramtype rectangle: ~affinda.models.Rectangle
        :keyword rectangles: Required. x/y coordinates for the rectangles containing the data. An
         annotation can be contained within multiple rectangles.
        :paramtype rectangles: list[~affinda.models.Rectangle]
        :keyword document: Required. Unique identifier for the document.
        :paramtype document: str
        :keyword page_index: Required. The page number within the document, starting from 0.
        :paramtype page_index: int
        :keyword raw: Required. Raw data extracted from the before any post-processing.
        :paramtype raw: str
        :keyword confidence: Required. The overall confidence that the model's prediction is correct.
        :paramtype confidence: float
        :keyword classification_confidence: Required. The model's confidence that the text has been
         classified correctly.
        :paramtype classification_confidence: float
        :keyword text_extraction_confidence: Required. If the document was submitted as an image, this
         is the confidence that the text in the image has been correctly read by the model.
        :paramtype text_extraction_confidence: float
        :keyword is_verified: Required. Indicates whether the data has been validated, either by a
         human using our validation tool or through auto-validation rules.
        :paramtype is_verified: bool
        :keyword is_client_verified: Required. Indicates whether the data has been validated by a
         human.
        :paramtype is_client_verified: bool
        :keyword is_auto_verified: Required. Indicates whether the data has been auto-validated.
        :paramtype is_auto_verified: bool
        :keyword data_point: Required. Data point's identifier.
        :paramtype data_point: str
        :keyword content_type: Required. The different data types of annotations. Known values are:
         "text", "integer", "float", "decimal", "date", "datetime", "daterange", "boolean", "enum",
         "location", "phonenumber", "json", "table", "expectedremuneration", "jobtitle", "language",
         "skill", "yearsexperience", "group", "table_deprecated", "url", "image".
        :paramtype content_type: str or ~affinda.models.AnnotationContentType
        :keyword parent: The parent annotation's ID.
        :paramtype parent: int
        :keyword parsed: Years of experience range.
        :paramtype parsed: ~affinda.models.YearsExperienceAnnotationParsed
        """
        super(YearsExperienceAnnotation, self).__init__(**kwargs)
        self.parsed = kwargs.get("parsed", None)


class YearsExperienceAnnotationParsed(msrest.serialization.Model):
    """Years of experience range.

    :ivar minimum: Minimum years of experience.
    :vartype minimum: float
    :ivar maximum: Maximum years of experience.
    :vartype maximum: float
    """

    _attribute_map = {
        "minimum": {"key": "minimum", "type": "float"},
        "maximum": {"key": "maximum", "type": "float"},
    }

    def __init__(self, **kwargs):
        """
        :keyword minimum: Minimum years of experience.
        :paramtype minimum: float
        :keyword maximum: Maximum years of experience.
        :paramtype maximum: float
        """
        super(YearsExperienceAnnotationParsed, self).__init__(**kwargs)
        self.minimum = kwargs.get("minimum", None)
        self.maximum = kwargs.get("maximum", None)


class YearsExperienceAnnotationUpdate(AnnotationBase):
    """YearsExperienceAnnotationUpdate.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id:
    :vartype id: int
    :ivar rectangle:
    :vartype rectangle: ~affinda.models.Rectangle
    :ivar rectangles:
    :vartype rectangles: list[~affinda.models.Rectangle]
    :ivar page_index:
    :vartype page_index: int
    :ivar raw:
    :vartype raw: str
    :ivar confidence: The overall confidence that the model's prediction is correct.
    :vartype confidence: float
    :ivar classification_confidence: The model's confidence that the text has been classified
     correctly.
    :vartype classification_confidence: float
    :ivar text_extraction_confidence: If the document was submitted as an image, this is the
     confidence that the text in the image has been correctly read by the model.
    :vartype text_extraction_confidence: float
    :ivar is_verified:
    :vartype is_verified: bool
    :ivar is_client_verified:
    :vartype is_client_verified: bool
    :ivar is_auto_verified:
    :vartype is_auto_verified: bool
    :ivar data_point:
    :vartype data_point: str
    :ivar content_type:
    :vartype content_type: str
    :ivar parsed: Years of experience range.
    :vartype parsed: ~affinda.models.YearsExperienceAnnotationUpdateParsed
    """

    _validation = {
        "rectangles": {"readonly": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "int"},
        "rectangle": {"key": "rectangle", "type": "Rectangle"},
        "rectangles": {"key": "rectangles", "type": "[Rectangle]"},
        "page_index": {"key": "pageIndex", "type": "int"},
        "raw": {"key": "raw", "type": "str"},
        "confidence": {"key": "confidence", "type": "float"},
        "classification_confidence": {"key": "classificationConfidence", "type": "float"},
        "text_extraction_confidence": {"key": "textExtractionConfidence", "type": "float"},
        "is_verified": {"key": "isVerified", "type": "bool"},
        "is_client_verified": {"key": "isClientVerified", "type": "bool"},
        "is_auto_verified": {"key": "isAutoVerified", "type": "bool"},
        "data_point": {"key": "dataPoint", "type": "str"},
        "content_type": {"key": "contentType", "type": "str"},
        "parsed": {"key": "parsed", "type": "YearsExperienceAnnotationUpdateParsed"},
    }

    def __init__(self, **kwargs):
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword id:
        :paramtype id: int
        :keyword rectangle:
        :paramtype rectangle: ~affinda.models.Rectangle
        :keyword page_index:
        :paramtype page_index: int
        :keyword raw:
        :paramtype raw: str
        :keyword confidence: The overall confidence that the model's prediction is correct.
        :paramtype confidence: float
        :keyword classification_confidence: The model's confidence that the text has been classified
         correctly.
        :paramtype classification_confidence: float
        :keyword text_extraction_confidence: If the document was submitted as an image, this is the
         confidence that the text in the image has been correctly read by the model.
        :paramtype text_extraction_confidence: float
        :keyword is_verified:
        :paramtype is_verified: bool
        :keyword is_client_verified:
        :paramtype is_client_verified: bool
        :keyword is_auto_verified:
        :paramtype is_auto_verified: bool
        :keyword data_point:
        :paramtype data_point: str
        :keyword content_type:
        :paramtype content_type: str
        :keyword parsed: Years of experience range.
        :paramtype parsed: ~affinda.models.YearsExperienceAnnotationUpdateParsed
        """
        super(YearsExperienceAnnotationUpdate, self).__init__(**kwargs)
        self.parsed = kwargs.get("parsed", None)


class YearsExperienceAnnotationUpdateParsed(msrest.serialization.Model):
    """Years of experience range.

    :ivar minimum: Minimum years of experience.
    :vartype minimum: float
    :ivar maximum: Maximum years of experience.
    :vartype maximum: float
    """

    _attribute_map = {
        "minimum": {"key": "minimum", "type": "float"},
        "maximum": {"key": "maximum", "type": "float"},
    }

    def __init__(self, **kwargs):
        """
        :keyword minimum: Minimum years of experience.
        :paramtype minimum: float
        :keyword maximum: Maximum years of experience.
        :paramtype maximum: float
        """
        super(YearsExperienceAnnotationUpdateParsed, self).__init__(**kwargs)
        self.minimum = kwargs.get("minimum", None)
        self.maximum = kwargs.get("maximum", None)
